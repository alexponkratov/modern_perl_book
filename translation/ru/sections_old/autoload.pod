=encoding utf-8

=head1 AUTOLOAD

Z<autoload>

Perl не требует от вас объявлять каждую функцию, прежде чем её вызывать. Perl
охотно попытается вызвать функцию, даже если она не существует. Расмотрим
программу:

=begin programlisting

    use Modern::Perl;

    bake_pie( filling => 'apple' );

=end programlisting

Когда вы её запустите, Perl вызовет исключение по причине вызова неопределённой
функции C<backe_pie()>.

Теперь добавьте функцию, называемую C<AUTOLOAD()>:

=begin programlisting

    sub AUTOLOAD {}

=end programlisting

Теперь, когда вы запустите программу, ничего очевидного не произойдёт. Perl вызовет
функцию пакета с именем C<AUTOLOAD()> E<mdash> если она существует E<mdash> в
случае, если обычная диспетчеризация не сработает. Измените C<AUTOLOAD()> для
вывода сообщения:

=begin programlisting

    sub AUTOLOAD { B<say 'In AUTOLOAD()!'> }

=end programlisting

E<hellip>чтобы продемонстрировать, что она вызывается.

=head2 Основные возможности AUTOLOAD

X<C<$AUTOLOAD>>


Функция C<AUTOLOAD()> получает аргументы, переданные в неопределённую функцию,
напрямую в C<@_>, а I<имя> неопределённой функции доступно в глобальной
переменной пакета C<$AUTOLOAD>. Манипулируйте этими аргументами по своему
усмотрению:

=begin programlisting

    sub AUTOLOAD
    {
        B<our $AUTOLOAD;>

        # оформленный вывод аргументов
        local $" = ', ';
        say "In AUTOLOAD(@_) B<for $AUTOLOAD>!"
    }

=end programlisting

Объявление C<our> (L<our>) ограничивает C<$AUTOLOAD> в пределах тела функции.
Переменная содержит полностью определённое имя неопределённой функции (в данном
случае C<main::bake_pie>). Удалить имя пакета можно с помощью регулярного
выражения (L<regex>):

=begin programlisting

    sub AUTOLOAD
    {
        B<my ($name) = our $AUTOLOAD =~ /::(\w+)$/;>

        # оформленный вывод аргументов
        local $" = ', ';
        say "In AUTOLOAD(@_) B<for $name>!"
    }

=end programlisting

Оригинальный вызов получит то, что вернёт C<AUTOLOAD()>:

=begin programlisting

    say secret_tangent( -1 );

    sub AUTOLOAD { return 'mu' }

=end programlisting

До сих пор приведённые примеры всего лишь перехватывали вызовы к неопределённым
функциям. Но есть и другие возможности.

=head2 Редиспетчеризация методов в AUTOLOAD()

X<C<AUTOLOAD>; redispatch>
X<C<AUTOLOAD>; delegation>
X<OO; delegation>
X<delegation>
X<OO; proxying>
X<proxying>

Распространённый шаблон в ОО-программировании (L<moose>) E<mdash>
I<делегировать> или I<проксировать> определённые методы одного объекта другому,
зачастую содержащемуся в первом или доступному из него каким-либо иным способом.
Проксирование логирования может помочь с отладкой:

=begin programlisting

    package Proxy::Log;

    sub new
    {
        my ($class, $proxied) = @_;
        bless \$proxied, $class;
    }

    sub AUTOLOAD
    {
        my ($name) = our $AUTOLOAD =~ /::(\w+)$/;
        Log::method_call( $name, @_ );

        my $self = shift;
        return $$self->$name( @_ );
    }

=end programlisting

Эта функция C<AUTOLOAD()> логирует вызов метода. Затем она разыменовывает
проксируемый объект из благословлённой скалярной ссылки, извлекает имя
неопределённого метода, а затем вызывает этот метод на проксируемом объекте с
переданными параметрами.

=head2 Генерация кода в AUTOLOAD()

X<C<AUTOLOAD>; code installation>

Эта двойная диспетчеризация легка для написания, но неэффективна. Каждый вызов
метода на прокси должен провалить нормальную диспетчеризацию, чтобы попасть в
C<AUTOLOAD()>. Вы можете заплатить эту цену лишь раз, устанавливая новые методы
в прокси-класс по мере того, как они понадобятся программе:

=begin programlisting

    sub AUTOLOAD
    {
        B<my ($name) = our $AUTOLOAD =~ /::(\w+)$/;>

        my $method = sub
        {
            Log::method_call( $name, @_ );

            my $self = shift;
            return $$self->$name( @_ );
        }

        B<no strict 'refs';>
        B<*{ $AUTOLOAD } = $method;>
        return $method->( @_ );
    }

=end programlisting

Тело предыдущей функции C<AUTOLOAD()> стало замыканием (L<closures>),
привязанным к I<имени> неопределённого метода. Установка этого замыкания в
соответствующую таблицу символов позволяет всем последующим обращениям к этому
методу найти созданное замыкание (и обойти C<AUTOLOAD()>). Наконец, этот код
вызывает метод напрямую и возвращает результат.

Хотя этот подход чище и почти всегда прозрачнее, чем обработка поведения прямо в
C<AUTOLOAD()>, код, I<вызванный> C<AUTOLOAD()>, может определить, что обращение
прошло через C<AUTOLOAD()>. Короче говоря, C<caller()> будет отображать двойную
диспетчеризацию обеих приведённых техник. Хотя забота о том, что это происходит,
может быть нарушением инкапсуляции, утечка деталей того, I<как> объект
предоставляет метод, тоже может быть нарушением инкапсуляции.

X<tailcalls>
X<C<goto>; tailcall>

Некоторый код использует хвостовые вызовы (L<tailcalls>) для I<замены> текущего
вызова C<AUTOLOAD()> вызовом целевого метода:

=begin programlisting

    sub AUTOLOAD
    {
        B<my ($name) = our $AUTOLOAD =~ /::(\w+)$/;>
        my $method = sub { ... }

        no strict 'refs';
        *{ $AUTOLOAD } = $method;
        B<goto &$method;>
    }

=end programlisting

Это приводит к тому же эффекту, что и вызов C<$method> напрямую, за исключением
того, что C<AUTOLOAD()> не будет появляться в списке вызовов, доступном через
C<caller()>, так что это будет выглядеть так, как будто сгенерированный метод
был просто вызван напрямую.

=head2 Недостатки AUTOLOAD

Z<autoload_drawbacks>

X<C<AUTOLOAD>; drawbacks>
X<C<UNIVERSAL::can>>
X<C<can()>>
X<C<subs> pragma>
X<pragmas; C<subs>>
X<functions; predeclaration>

C<AUTOLOAD()> может быть полезным инструментом, хотя его и непросто использовать
правильно. Наивный подход к генерированию методов во время исполнения означает,
что метод C<can()> не будет выдавать правильную информацию о возможностях
объектов и классов. Самое простое решение E<mdash> предварительно объявить все
функции, которые вы планируете генерировать в C<AUTOLOAD()>, с помощью прагмы
C<subs>:

=begin programlisting

    use subs qw( red green blue ochre teal );

=end programlisting

=begin tip Теперь вы их видите

Предварительные объявления могут пригодиться только в двух редких случаях
использования атрибутов и автозагрузки (L<autoload>).

=end tip

Плюсом этой техники является документирование ваших намерений, но недостаток в
том, что вам придётся поддерживать статический список функций или методов.
Перегрузка C<can()> (L<universal>) иногда работает лучше:

=begin programlisting

    sub can
    {
        my ($self, $method) = @_;

        # использовать результат родительского can()
        my $meth_ref = $self->SUPER::can( $method );
        return $meth_ref if $meth_ref;

        # добавить фильтрацию
        return unless $self->should_generate( $method );

        $meth_ref = sub { ... };
        no strict 'refs';
        return *{ $method } = $meth_ref;
    }

    sub AUTOLOAD
    {
        my ($self) = @_;
        my ($name) = our $AUTOLOAD =~ /::(\w+)$/;>

        return unless my $meth_ref = $self->can( $name );
        goto &$meth_ref;
    }

=end programlisting

C<AUTOLOAD()> E<mdash> большой молоток; он может ловить функции и методы,
которые вы не собирались автозагружать, такие как C<DESTROY()>, деструктор
объектов. Если напишете метод C<DESTROY> без имплементации, Perl с удовольствием
направится к нему вместо C<AUTOLOAD()>:

=begin programlisting

    # пропустить AUTOLOAD()
    sub DESTROY {}

=end programlisting

=begin tip Совершенно особенный метод

Специальные методы C<import()>, C<unimport()> и C<VERSION()> никогда не проходят
через C<AUTOLOAD()>.

=end tip

Если вы смешаете функции и методы в едином пространстве имён, наследующем от
другого пакета, имеющего собственную C<AUTOLOAD()>, вы можете увидеть странную
ошибку:

=begin screen

  Use of inherited AUTOLOAD for non-method
      I<slam_door>() is deprecated

=end screen

Если с вами это произошло, упростите свой код; вы вызвали несуществующую функцию
в пакете, наследующем от класса, содержащего свою собственную C<AUTOLOAD()>.
Проблема состоит из нескольких частей: смешивание функций и методов в одном
пространстве имён зачастую является недостатком дизайна, наследование и C<AUTOLOAD()>
очень быстро становятся сложными, и делать выводы о коде, когда вы не знаете,
какие методы предоставляет объект, трудно.

C<AUTOLOAD()> полезна для быстрого и грязного программирования, но надёжный код
её избегает.
