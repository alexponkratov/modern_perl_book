=encoding utf-8

=head1 Приведение типов

Z<coercion>

X<DWIM>
X<dwimmery>
X<coercion>

Переменная в Perl может содержать в разное время значения разных типов E<mdash>
строки, целые и рациональные числа и т. д. Вместо присоединения информации о
типе к переменным, Perl полагается на контекст, устанавливаемый операторами
(L<value_contexts>) для понимания того, что делать со значениями. По своему
дизайну, Perl пытается делать то, что вы имеете ввидуN<Это называется I<DWIM>,
I<do what i mean> (I<делай то, что я имею ввиду>), или I<DWIM-ность>.>, хотя вы
должны чётко выражать свои намерения. Если вы обращаетесь с переменной,
содержащей число, как со строкой, Perl сделает всё, что сможет, для I<приведения
типа> этого числа к строке.

=head2 Булево приведение типов

Z<boolean_coercion>
X<coercion; boolean>
X<truthiness>

Булево приведение типов происходит, когда вы проверяете I<истинность> значения,
как, например, в условиях C<if> или C<while>. Числовой 0, <undef>, пустая строка и
строка C<'0'> являются ложными значениями. Все остальные значения E<mdash>
включая строки, которые могут быть I<численно> равными нулю (такие как C<'0.0'>,
C<'0e'> и C<'0 but true'>), E<mdash> являются ложными.

Если скаляр имет I<оба> компонента (L<dualvars>), и строковый, и числовой,
Perl 5 предпочтёт проверить на булеву истину строковый компонент.
C<'0 but true'> численно вычисляется в ноль, но это не пустая строка, поэтому в
булевом контексте она вычисляется в истинное значение.

=head2 Строковое приведение типов

X<coercion; string>
X<stringification>

Строковое приведение типов происходит при использовании строковых операторов,
таких как сравнение (C<eq> и C<cmp>), конкатенация, C<split>, C<substr> и
регулярные выражения, а также при использовании значения как ключа хеша.
Неопределённое значение преобразуется в пустую строку, выдавая предупреждение
E<laquo>use of uninitialized valueE<raquo>. Числа I<преобразуются> в строки,
содержащие их значения, то есть значение C<10> преобразуется в строку C<10>. Вы
можете даже разделить число на отдельные цифры с помощью C<split>:

=begin programlisting

    my @digits = split '', 1234567890;

=end programlisting

=head2 Числовое приведение типов

Z<numeric_coercion>
X<coercion; numeric>
X<numification>

Числовое приведение типов происходит при использовании операторов числового
сравнения (таких как C<==> и C<< <=> >>), при выполнении математических операций
и при использовании значения как индекса массива или списка. Неопределённое
значение I<преобразуется> в ноль и выдаёт предупреждение E<laquo>use of
uninitialized valueE<raquo>. Строки, которые не начинаются с числовой части,
тоже преобразуются в ноль и выдают предупреждение E<laquo>Argument isn't
numericE<raquo>. Строки, начинающиеся с символов, разрешённых в числовых
литералах, преобразуются в эти значения, не выдавая предупреждений, то есть
C<10 leptons leaping> преобразуется в C<10>, а C<6.022e23 moles marauding>
E<mdash> в C<6.022e23>.

X<Scalar::Util>
X<Scalar::Util; looks_like_number>

Базовый модуль C<Scalar::Util> содержит функцию C<looks_like_number()>,
которая использует те же правила разбора, что и грамматика Perl 5, для выделения
числа из строки.

=begin tip Радость для математиков

Строки C<Inf> и C<Infinity> обозначают бесконечное значение и ведут себя как
числа. Строка C<NaN> обозначает понятие E<laquo>не числоE<raquo>. Их
преобразование в числа не выдаёт предупреждения E<laquo>Argument isn't
numericE<raquo>.

=end tip

=head2 Ссылочное преобразование типов

X<coercion; reference>
X<autovivification>

Использование операции разыменования ссылки на значении, не являющемся ссылкой,
превращает его I<в> ссылку. Этот процесс автовивификации (L<autovivification>)
удобен при манипулировании вложенными структурами данных
(L<nested_data_structures>):

=begin programlisting

    my %users;

    $users{Brad}{id} = 228;
    $users{Jack}{id} = 229;

=end programlisting

Хотя хеш не содержал значений для ключей C<Brad> и C<Jack>, Perl
создаёт для них ссылки на хеши и присваивает каждому пару ключ/значение с ключом
C<id>.

=head2 Кешированное преобразование типов

Z<cached_coercions>

X<coercion; cached>

Внутреннее представление значений в Perl 5 хранит и строковое, и числовое
значения. Преобразование числа в строку не I<заменяет> числовое значение. Вместо
этого оно I<присоединяет> преобразованное в строку значение, так что
представление будет содержать I<оба> компонента. Аналогично, преобразование строки в
число заполняет числовой компонент, оставляя строковый компонент нетронутым.

Некоторые операции в Perl предпочитают использование одного из компонентов
другому E<mdash> булева проверка, например, предпочитает строки. Если значение
имеет кешированное представление в форме, которую вы не ожидаете, расчёт на
неявную конвертацию может привести к неожиданным результатам. Вам почти никогда
не нужно будет явно указывать, что вы ожидаетеN<Автор может припомнить два таких
случая за более чем десятилетие программирования на Perl 5>, но знание того, что
это кеширование происходит, может однажды помочь вам диагностировать странную
ситуацию.

=head2 Двойные переменные

Z<dualvars>

X<coercion; dualvars>
X<C<dualvar()>>
X<C<Scalar::Util>>
X<dualvars>

Многокомпонентная природа переменных Perl доступна пользователям в виде
I<двойных переменных>. Базовый модуль C<Scalar::Util> предоставляет функцию
C<dualvar()>, которая позволяет вам обойти приведение типов Perl и
манипулировать строковым и числовым компонентами значения по отдельности:

=begin programlisting

    use Scalar::Util 'dualvar';
    my $false_name = dualvar 0, 'Sparkles & Blue';

    say 'Boolean true!'  if        !! $false_name;
    say 'Numeric false!' unless  0  + $false_name;
    say 'String true!'   if     ''  . $false_name;

=end programlisting
