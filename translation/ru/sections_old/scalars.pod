=encoding utf-8

=head1 Скаляры

Z<scalars>

X<scalars>
X<C<$>; sigil>
X<sigils; C<$>>

Основной тип данных Perl 5 E<mdash> это I<скаляр>, одиночное, отдельное
значение. Значение может быть строкой, целым числом, значением с плавающей
точкой, дескриптором файла или ссылкой E<mdash> но это всегда одиночное
значение. Скаляры могут быть лексическими переменными, переменными пакета или
глобальными (L<globals>) переменными. Вы можете объявлять только лексические
переменные и переменные пакетов. Имена скалярных переменных должны
соответствовать стандартным правилам именования переменных (L<names>). Скалярные
переменные всегда начинаются с сигила (L<sigils>) в виде знака доллара (C<$>).

=begin tip Вариантные сигилы и контекст

Скалярные значения и скалярный контекст имеют глубокую связь; присваивание скаляру
создаёт скалярный контекст. Использование скалярного сигила с агрегатной
переменной налагает скалярный контекст для доступа к единственному элементу хеша
или массива.

=end tip

=head2 Скаляры и типы

Скалярная переменная может содержать любой тип скалярного значения без
специальной конвертации или приведения, и тип значения, сохранённого в
переменной, может меняться:

=begin programlisting

    my $value;
    $value = 123.456;
    $value = 77;
    $value = "I am Chuck's big toe.";
    $value = Store::IceCream->new();

=end programlisting

Хотя этот код I<допустим>, изменение типа данных, сохраняемых в скаляре,
E<mdash> признак беспорядка.

Эта гибкость типов часто приводит к приведению типа значения (L<coercion>).
Например, вы можете обращаться с содержимым скаляра как со строкой, даже если
вы явно не назначали ему строку:

=begin programlisting

    my $zip_code       = 97006;
    my $city_state_zip = 'Beaverton, Oregon' . ' ' . $zip_code;

=end programlisting

Также вы можете производить математические операции над строками:

=begin programlisting

    my $call_sign = 'KBMIU';

    # обновить знак и вернуть новое значение
    my $next_sign = ++$call_sign;

    # вернуть старое значение, I<затем> обновить знак
    my $curr_sign = $call_sign++;

    # но I<не работает> в таком виде:
    my $new_sign  = $call_sign + 1;

=end programlisting

X<increment; string>

=begin tip Односторонняя магия инкремента

Это магическое поведение инкремента строки не имеет соответствующего магического
поведения декремента. Вы не сможете получить предыдущее значение строки, написав
C<$call_sign-->.

=end tip

Эта операция инкремента строки превращает C<a> в C<b> и C<z> в C<aa>, учитывая
набор символов и регистр. В то время как C<ZZ9> становится C<AAA0>, C<ZZ09>
становится C<ZZ10> E<mdash> числа проворачиваются до тех пор, пока есть большие
значащие цифры для инкремента, как на автомобильном одометре.

X<stringification>
X<numification>

Вычисление ссылки (L<references>) в строковом контексте возвращает строку.
Вычисление ссылки в числовом контексте возвращает число. Ни одна из этих
операций не модифицирует ссылку, но вы не сможете восстановить ссылку из любого
из результатов:

=begin programlisting

    my $authors     = [qw( Pratchett Vinge Conway )];
    my $stringy_ref = '' . $authors;
    my $numeric_ref =  0 + $authors;

=end programlisting

C<$authors> E<mdash> всё ещё пригодная к употреблению ссылка, но C<$stringy_ref> E<mdash>
строка, не имеющая никакой связи со ссылкой, и C<$numeric_ref> E<mdash> число,
также не имеющее никакой связи со ссылкой.

X<C<Scalar::Util>>
X<dualvars>
X<C<dualvar()>>

Чтобы обеспечить возможность преобразования без потери данных, скаляры Perl 5
могут содержать и числовой, и строковый компоненты. Внутренняя структура данных,
представляющая скаляр в Perl 5, имеет числовой слот и строковый слот. Доступ к
строке в числовом контексте производит скаляр и со строковым, и с числовым
значениями. Функция C<dualvar()> базового модуля C<Scalar::Util> позволяет
вам манипулировать обоими значениями напрямую в одном скаляре.

X<boolean>
X<scalars; boolean values>
X<boolean; true>
X<boolean; false>
X<strings; true>
X<strings; false>
X<numbers; true>
X<numbers; false>

Скаляры не имеют отдельного слота для булевых значений. В булевом контексте
пустая строка (C<''>) и C<'0'> E<mdash> ложны. Все остальные строки E<mdash>
истинны. В булевом контексте числа, равные нулю (C<0>, C<0.0> и C<0e0>), ложны.
Все остальные числа E<mdash> истинны.

=begin tip Что есть истина?

Обратите внимание, что I<строки> C<'0.0'> и C<'0e0'> истинны; это одно из
мест, где Perl 5 делает различие между тем, что выглядит как число, и что на
самом деле число.

=end tip

X<C<undef>>

Ещё одно значение всегда ложно: C<undef>. Это значение неинициализированных
переменных, кроме того, оно может быть и самостоятельным значением.
