=encoding utf-8

=head1 Эквивалентность методов и функций

Z<method_sub_equivalence>

X<builtins; C<sub>>

Объектная система Perl 5 преднамеренно минималистична (L<blessed_references>).
Так как класс является пакетом, Perl не делает различий между функцией и
методом, хранящимися в пакете. Одна и та же встроенная директива, C<sub>,
объявляет и одно, и другое. Документация может прояснить ваши намерения, но Perl
охотно диспетчеризует функцию, вызванную как метод. Подобным же образом вы
можете вызвать метод как если бы он был функцией E<mdash> полностью
определённой, экспортированной или ссылкой E<mdash> если вручную передадите свой
инвокант.

Вызов не того, что нужно, не так, как нужно, вызывает проблемы.

=head2 Вызывающая сторона

Рассмотрим класс с несколькими методами:

=begin programlisting

    package Order;

    use List::Util 'sum';

    ...

    sub calculate_price
    {
        my $self = shift;
        return sum( 0, $self->get_items() );
    }

=end programlisting

Если есть объект C<$o> класса C<Order>, следующие вызовы этого метода I<могут>
выглядеть эквивалентными:

=begin programlisting

    my $price = $o->calculate_price();

    # сломано; не использовать
    my $price = Order::calculate_price( $o );

=end programlisting

Хотя в этом простом случае они дадут один и тот же вывод, последнее нарушает
инкапсуляцию объекта, избегая поиска метода.

X<methods; avoid calling as functions>

Если же C<$o> был бы подклассом или алломорфом (L<roles>) класса C<Order>,
который переопределял бы C<calculate_price()>, обход диспетчеризации метода
привёл бы к вызову неверного метода. Любое изменение реализации
C<calculate_price()>, такое как модификация наследования или делегирования через
C<AUTOLOAD()> E<mdash> могло бы сломать вызывающий код.

X<methods; calling with references>
X<C<UNIVERSAL>; C<can()>>
X<C<can()>>

В Perl есть одно обстоятельство, где это поведение может выглядеть необходимым.
Если вы форсируете разрешение метода без диспетчеризации, как вы вызовете
результирующую ссылку на метод?

=begin programlisting

    my $meth_ref = $o->can( 'apply_discount' );

=end programlisting

Здесь есть две возможности. Первая E<mdash> отбросить возвращаемое значение
метода C<can()>:

=begin programlisting

    $o->apply_discount() if $o->can( 'apply_discount' );

=end programlisting

Вторая E<mdash> использовать саму ссылку посредством синтаксиса вызова метода:

=begin programlisting

    if (my $meth_ref = $o->can( 'apply_discount' ))
    {
        $o->$meth_ref();
    }

=end programlisting

Если C<$meth_ref> содержит ссылку на функцию, Perl вызовет эту ссылку с C<$o> в
качестве инвоканта. Это работает даже со включенным C<strict>, как и при
вызове метода с помощью скаляра, содержащего его имя:

=begin programlisting

    my $name = 'apply_discount';
    $o->$name();

=end programlisting

Есть один небольшой недостаток в вызове метода по ссылке; если структура программы
изменяется между сохранением ссылки и вызовом по ссылке, ссылка может уже не
ссылаться на наиболее соответствующий метод. Если класс C<Order> был изменён так,
что C<Order::apply_discount> уже не является правильным методом для вызова,
ссылка в C<$meth_ref> не будет обновлена.

Когда вы используете эту форму вызова, ограничьте область видимости ссылки.

=head2 Вызываемая сторона

X<methods; avoid calling as functions>
X<functions; avoid calling as methods>

Так как Perl 5 не делает различий между функциями и методами в точке объявления,
и так как I<возможно> (хотя и не рекомендуется) вызвать заданную функцию как
функцию или метод, возможно написать функцию, которую можно вызывать любым из
этих способов. Базовый модуль C<CGI> E<mdash> главный обвиняемый. Его функции
применяют несколько эвристик для определения того, является ли их первый
аргумент инвокантом.

Недостатков этого множество. Трудно точно предсказать, какой инвокант
потенциально валиден для заданного метода, особенно если вам приходится иметь
дело с подклассами. Также труднее создать API, который пользователи не смогут с
лёгкостью неправильно использовать, как и бремя документации становится тяжелее.
Что случится, если одна часть проекта использует процедурный интерфейс, а другая
E<mdash> объектный?

Если вам I<необходимо> предоставить отдельный процедурный и ОО интерфейс к
библиотеке, создайте два отдельных API.
