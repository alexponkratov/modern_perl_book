=encoding utf-8

=head1 Глобальные переменные

Z<globals>

X<super globals>
X<variables; super global>

Perl 5 предоставляет несколько I<суперглобальных переменных>, которые поистине
глобальны, не ограничены областью видимости пакета или файла. К сожалению, их
глобальная доступность означает, что любые прямые или непрямые модификации могут
повлиять на другие части программы E<mdash> и они немногословны. Опытные
программисты на Perl 5 запоминают некоторые из них. Мало кто помнит их все. Лишь
некоторые из них бывают полезны. C<perldoc perlvar> содержит исчерпывающий
список таких переменных.

=head2 Управление суперглобальными переменными

X<super globals; managing>
X<builtins; C<local>>

Perl 5 продолжает перемещать ещё больше глобального поведения в лексическое
поведение, так что вы можете избежать многих из этих глобальных переменных.
Когда вы не можете их избежать, используйте C<local> в наименьшей возможной
области видимости чтобы ограничить любые изменения. Вы всё ещё восприимчивы к
любым изменениям, которые I<вызываемый> вами код сделает с этими глобальными
переменными, но вы уменьшаете вероятность неожиданного кода I<снаружи> вашей
области видимости. Как демонстрирует идиома лёгкого поглощения файла
(L<easy_file_slurping>), C<local> зачастую правильный подход:

=begin programlisting

    my $file; { B<local $/>; $file = <$fh> };

=end programlisting

Эффект локализации C<$/> длится только до конца блока. Невелик шанс, что
какой-либо Perl-код будет выполнен как результат чтения строк из дескриптора
файлаN<Связанный дескриптор файла (L<tie>) E<mdash> одна из немногих
вероятностей.> и изменит значение C<$/> внутри блока C<do>.

Не все случаюи использования суперглобальных переменных так легко защитить, но это
зачастую работает.

X<C<eval>>
X<exceptions; catching>
X<exceptions; C<$@>>

В других случаях вам нужно I<прочитать> значение суперглобальной переменной, и
надеяться, что другой код его не изменил. Отлавливание исключений с помощью
блока C<eval> может быть восприимчиво к условиям гонки, поскольку метод
C<DESTROY()>, вызванный на лексической переменной, которая вышла за пределы
области видимости, может сбросить C<$@>:

=begin programlisting

    local $@;

    eval { ... };

    if (B<my $exception = $@>) { ... }

=end programlisting

Копируйте C<$@> I<сразу же> после поимки исключения, чтобы сохранить её
содержимое. Смотрите также C<Try::Tiny> вместо этого (L<exception_caveats>).

=head2 Английские имена

X<C<English>>

Базовый модуль C<English> предоставляет подробные имена для насыщенных
пунктуацией суперглобальных переменных. Импортируйте их в пространство имён
следующим образом:

=begin programlisting

    use English '-no_match_vars';

=end programlisting

Это позволит вам использовать подробные имена, документированные в C<perldoc
perlvar>, внутри области видимости этой прагмы.

X<C<$&>>
X<global variables; C<$&>>
X<C<$`>>
X<global variables; C<$`>>
X<C<$'>>
X<global variables; C<$'>>

Три связанных с регулярными выражениями суперглобальных переменных (C<$&>, C<$`>
и C<$'>) приводят к снижению производительности I<всех> регулярных
выражений в программе. Если вы забудете C<-no_match_vars> при импорте, ваша
программа получит минус производительности, даже если вы не читаете явно из этих
переменных.

Программы на Современном Perl должны использовать переменную C<@-> как замену
для этих ужасных трёх.

=head2 Полезные суперглобальные переменные

X<super globals; useful>

Большая часть программ на современном Perl 5 может обойтись использованием
только нескольких из суперглобальных переменных. Вы с большой вероятностью
встретите лишь немногие из этих переменных в реальных программах.

X<C<$/>>
X<global variables; C<$/>>
X<C<$INPUT_RECORD_SEPARATOR>>
X<global variables; C<$INPUT_RECORD_SEPARATOR>>
X<C<readline>>

=over 4

=item * C<$/> (или C<$INPUT_RECORD_SEPARATOR> из прагмы C<English>) это строка
из нуля или более символов, обозначающая конец записи при построчном чтении
входных данных. По умолчанию, это платформозависимая последовательность символов
новой строки. Если вы сделаете это значение неопределённым, Perl будет пытаться
прочитать файл в память целиком. Если вы установите это значение в I<ссылку> на
целое число, Perl будет пытаться прочитать именно столько I<байт> на запись (так
что не забывайте о вопросах Юникода). Если вы установите это значение в пустую
строку (C<''>), Perl будет читать по параграфу за раз, где параграф E<mdash> это
порция текста, за которой следует произвольное количество новых строк.

X<C<$.>>
X<global variables; C<$.>>
X<C<$INPUT_LINE_NUMBER>>
X<global variables; C<$INPUT_LINE_NUMBER>>

=item * C<$.> (C<$INPUT_LINE_NUMBER>) содержит количество записей, прочитанных
из дескриптора файла, к которому последний раз осуществлялся доступ. Вы можете
читать из этой переменной, но запись в неё не даст никакого эффекта. Локализация
этой переменной будет локализовать дескриптор файла, на который она ссылается.

X<C<$|>>
X<global variables; C<$|>>
X<C<$OUTPUT_AUTOFLUSH>>
X<global variables; C<$OUTPUT_AUTOFLUSH>>

=item * C<$|> (C<$OUTPUT_AUTOFLUSH>) управляет тем, будет ли Perl сбрасывать
всё, что записано в текущий выбранный дескриптор файла, сразу же, или только
когда буфер Perl заполнится. Небуферизованный вывод полезен при записи в канал,
или сокет, или терминал, который не должен блокироваться ожиданием ввода. Эта
переменная будет приводить любые присвоенные ей значение в булевы.

X<C<@ARGV>>
X<global variables; C<@ARGV>>

=item * C<@ARGV> содержит агрументы командной строки, переданные в программу.

X<C<$!>>
X<global variables; C<$!>>
X<C<$ERRNO>>
X<global variables; C<$ERRNO>>

=item * C<$!> (C<$ERRNO>) это двойная переменная (L<dualvars>), содержащая
результат I<последнего> системного вызова. В числовом контексте она
соответствует значению C<errno> в C, где всё, кроме ноля, обозначает ошибку. В
строковом контексте она возвращает соответствующую строку системной ошибки.
Локализуйте эту переменную, прежде чем выполнить системный вызов (явно или
неявно), чтобы избежать перезаписывания соответствующего значения для другого
кода где бы то ни было. Многие места в самом Perl 5 делают системные вызовы, о
которых вы не знаете, так что значение этой переменной может измениться
независимо от вас. Копируйте его I<сразу же> после выполнения системного вызова
для получения наиболее точных результатов.

X<C<$">>
X<global variables; C<$">>
X<C<$LIST_SEPARATOR>>
X<global variables; C<$LIST_SEPARATOR>>

=item * C<$"> (C<$LIST_SEPARATOR>) это строка, используемая для разделения
элементов массивов и списков, интерполируемых в строку.

X<C<%+>>
X<global variables; C<%+>>

=item * C<%+> содержит именованные захваты из успешного сопоставления
регулярному выражению (L<named_captures>).

X<C<$@>>
X<global variables; C<$@>>
X<C<$EVAL_ERROR>>
X<global variables; C<$EVAL_ERROR>>

=item * C<$@> (C<$EVAL_ERROR>) содержит значение, выброшенное из последнего
исключения  (L<catching_exceptions>).

X<C<$0>>
X<global variables; C<$0>>
X<C<$PROGRAM_NAME>>
X<global variables; C<$PROGRAM_NAME>>

=item * C<$0> (C<$PROGRAM_NAME>) содержит имя выполняемой программы. Вы можете
модифицировать это значение на некоторых Unix-подобных платформах чтобы изменить
имя программы, под которым она предстаёт перед другими программами, такими как
C<ps> или C<top>.

X<C<$$>>
X<global variables; C<$$>>
X<C<$PID>>
X<global variables; C<$PID>>

=item * C<$$> (C<$PID>) содержит идентификатор процесса текущего выполняемого
экземпляра программы, как его понимает операционная система. Он будет
различаться между программами, разветвлёнными с помощью C<fork()>, и I<может>
различаться между потоками в одной и той же программе.

X<C<@INC>>
X<global variables; C<@INC>>

=item * C<@INC> содержит список путей в файловой системе, по которым Perl будет
искать файлы для загрузки с помощью C<use> или C<require>. Смотрите C<perldoc -f
require> для информации о других элементах, которые этот массив может содержать.

X<C<%SIG>>
X<global variables; C<%SIG>>

=item * C<%SIG> ставит в соответствие низкоуровневым сигналам ОС и Perl ссылки
на функции, используемые для обработки этих сигналов. Например, можно отловить
стандартное прерывание по Ctrl-C с помощью сигнала C<INT>. См. C<perldoc
perlipc> для большей информации о сигналах и особенно безопасных сигналах.

=back

=head2 Альтернативы суперглобальным переменным

X<super globals; alternatives>
X<C<Try::Tiny>>

Самые тяжёлые обвинения о воздействии на расстоянии относятся к вводу/выводу и
исключительным условиям. Использование C<Try::Tiny> (L<exception_caveats>)
поможет вам защититься от хитрой семантики правильной обработки исключений.
Локализация и копирование значения C<$!> может помощь вам избежать странных
поведений, когда Perl выполняет неявные системные вызовы. Использование
C<IO::File> и его методов на лексических дескрипторах файлов
(L<file_handling_variables>) поможет предотвратить нежелательные глобальные
изменения поведения ввода/вывода.
