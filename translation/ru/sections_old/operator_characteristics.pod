=encoding utf-8

=head1 Свойства операторов

Z<operator_characteristics>
X<operators; characteristics>

Каждый оператор обладает несколькими важными свойствами, определяющими его поведение:
количество операндов, которыми он оперирует, его отношения с другими операторами
и его синтаксические возможности.

C<perldoc perlop> и C<perldoc perlsyn> предоставляют обширную информацию об
операторах Perl, но документация подразумевает, что вы уже знакомы с некоторыми
деталями того, как они работают. Основные понятия компьютерных наук могут
выглядеть внушительно, но когда вы проберётесь через их названия, они довольно
очевидны. Неявно вы их уже понимаете.

=head2 Приоритет

Z<precedence>
X<precedence>

I<Приоритет> оператора определяет, когда Perl должен вычислить его в выражении.
Порядок вычисления следует от наивысших приоритетов к наинизшим. Так как
приоритет умножения выше, чем приоритет сложения, результатом вычисления
C<7 + 7 * 10> будет C<77>, а не C<140>.

Чтобы заставить какие-либо операторы вычисляться раньше других, сгруппируйте их подвыражения
в круглые скобки. В выражении C<(7 + 7) * 10> группировка сложения в одно целое
приводит к тому, что оно вычисляется раньше умножения. Результатом будет C<140>.

C<perldoc perlop> содержит таблицу приоритетов. Прочитайте её, поймите, но не
утруждайте себя запоминанием (почти никто этого не делает). Лучше сохраняйте
свои выражения простыми и добавляйте скобки для прояснения своего замысла.

В случае, если два оператора имеют одинаковый приоритет, ситуацию разрешают
другие факторы, такие как ассоциативность (L<associativity>) и фиксность
(L<fixity>).

=head2 Ассоциативность

Z<associativity>
X<associativity>
X<associativity; left>
X<left associativity>
X<associativity; right>
X<right associativity>

I<Ассоциативность> оператора определяет, вычисляется он слева направо или справа
налево. Сложение левоассоциативно, поэтому C<2 + 3 + 4> сначала вычисляет
C<2 + 3>, а затем добавляет к результату C<4>. Возведение в степень
правоассоциативно, поэтому C<2 ** 3 ** 4> вычисляет сначала C<3 ** 4>, а затем
возводит C<2> в 81-ую степень.

Стоит запомнить приоритет и ассоциативность распространённых математических
операторов, но, опять-таки, простота вам поможет. Используйте скобки для
прояснения своего замысла.

=begin sidebar

X<C<B::Deparse>>
X<precedence; disambiguation>
X<associativity; disambiguation>

Базовый модуль C<B:Deparse> E<mdash> бесценный отладочный инструмент.
Выполните C<perl -MO=Deparse,-p> с фрагментом кода чтобы уведить в точности как
Perl обрабатывает приоритет и ассоциативность операторов. Флаг C<-p> добавляет
дополнительные групирующие скобки, которые часто проясняют порядок вычисления.

Имейте ввиду, что оптимизатор Perl упростит математические операции как описано
в предыдущих примерах; вместо этого используйте переменные, как в
C<$x ** $y ** $z>.

=end sidebar

=head2 Арность

Z<arity>

X<arity>
X<operators; arity>
X<nullary>
X<unary>
X<binary>
X<trinary>
X<listary>

I<Арность> оператора E<mdash> это количество операндов, которыми он оперирует.
I<Нольарный> оператор имеет ноль операндов. I<Унарный> оператор имеет один
оператор. I<Бинарный> оператор имеет два операнда. I<Тернарный> оператор имеет
три операнда. Оператор I<списочной арности> оперирует списком операндов.
Документация и примеры использования оператора должны сделать его арность ясной.

Например, арифметические операторы E<mdash> бинарные, и обычно
левоассоциативные. C<2 + 3 - 4> сначала вычисляет C<2 + 3>; сложение и вычитание
имеют одинаковый приоритет, но они левоассоциативные и бинарные, поэтому
правильный порядок вычисления применяет самый левый оператор (C<+>) к двум самым
левым операндам (C<2> и C<3>), а затем применяет правый оператор (C<->) к
результату первой операции и правому операнду (C<4>).

Новичков в Perl часто сбивает с толку взаимодействие между операторами списочной
арности E<mdash> особенно вызовами функций E<mdash> и вложенными выражениями.
Хотя скобки обычно помогают, опасайтесь запутанности парсинга выражения:

=begin programlisting

    # вероятно ошибочный код
    say ( 1 + 2 + 3 ) * 4;

=end programlisting

E<hellip>которое выводит значение C<6> и (вероятно) в целом возвращает C<4>
(возвращаемое значение C<say>, умноженное на C<4>). Парсер Perl успешно
интерпретирует скобки как постциркумфиксные (L<fixity>) операторы, обозначающие
аргументы C<say>, а не циркумфиксные скобки, группирующие выражение для
изменения приоритета.

=head2 Фиксность

Z<fixity>
X<fixity>
X<operators; fixity>
X<infix>
X<fixity; infix>
X<prefix>
X<fixity; prefix>
X<postfix>
X<fixity; postfix>
X<circumfix>
X<fixity; circumfix>
X<postcircumfix>
X<fixity; postcircumfix>

I<Фиксность> оператора E<mdash> это его расположение по отношению к своим
операндам:

X<C<.>; infix operator>
X<C<.=>; infix operator>
X<C<..>; infix operator>
X<C<...>; infix operator>
X<C<=~>; infix operator>
X<C<!~>; infix operator>
X<C<|>; infix operator>
X<C<||>; infix operator>
X<C<//>; infix operator>
X<C<|=>; infix operator>
X<C<||=>; infix operator>
X<C<//=>; infix operator>

=over 4

=item * I<Инфиксные> операторы располагаются между своими операндами.
Большинство математических операторов E<mdash> инфиксные операторы, такие как
оператор умножения в C<$length * $width>.

X<C<\>; prefix operator>
X<C<~>; prefix operator>
X<C<++>; prefix operator>
X<C<-->; prefix operator>
X<C<+>; prefix operator>
X<C<->; prefix operator>
X<C<!>; prefix operator>
X<C<!!>; prefix operator>

=item * I<Префиксные> операторы предшествуют своим операндам. I<Постфиксные>
операторы следуют за операндами. Эти операторы склонны быть унарными, как
математическое отрицание (C<-$x>), булево отрицание (C<!$y>) и постфиксный
инкремент (C<$z++>).

X<C<()>; circumfix operator>
X<C<{}>; circumfix operator>
X<C<[]>; circumfix operator>
X<C<//>; circumfix operator>
X<C<``>; circumfix operator>
X<C<''>; circumfix operator>
X<C<"">; circumfix operator>

=item * I<Циркумфиксные> операторы окружают свои операнды, как конструктор
анонимного хеша (C<{ ... }>) и операторы заключения в кавычки (C<qq[ ... ]>).

X<C<()>; postcircumfix operator>
X<C<{}>; postcircumfix operator>
X<C<[]>; postcircumfix operator>

=item * I<Постциркумфиксные> операторы следуют за одними операндами и окружают
другие, как в доступе к элементам хеша или массива (C<$hash{$x}> и
C<$array[$y]>).

=back
