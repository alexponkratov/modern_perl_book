=encoding utf-8

=head1 Идиомы

Z<idioms>

Каждый язык E<mdash> язык программирования или естественный E<mdash> имеет
распространённые шаблоны выражений, или I<идиомы>. Земля вращается, но мы
говорим о восходящем и заходящем солнце. Мы хвастаемся умными хаками и
и морщимся от страшных хаков в процессе работы с кодом.

Идиомы Perl E<mdash> не совсем возможности языка или техники дизайна. Это
манеры и механизмы, которые, сложенные вместе, дают вашему коду перловый акцент.
Вы не обязаны их использовать, но они придают Perl силу.

=head2 Объект как C<$self>

X<C<$self>>
X<variables; C<$self>>
X<objects; invocant>
X<methods; invocant>
X<CPAN; C<MooseX::Method::Signatures>>

Объектная система Perl 5 (L<moose>) работает с инвокантом метода как с обычным
параметром. Независимо от того, вызываете ли вы метод класса или экземпляра,
первый элемент C<@_> E<mdash> всегда инвокант метода. По соглашению, большая
часть кода на Perl 5 использует C<$class> как имя инвоканта метода класса и
C<$self> как имя инвоканта объекта. Это соглашение достаточно сильно, чтобы
полезные расширения, такие как C<MooseX::Method::Signatures>, исходили из
предположения, что бы используете C<$self> как имя объектных инвокантов.

=head2 Именованные параметры

X<parameters; named>
X<arguments; named>
X<CPAN; C<signatures>>
X<CPAN; C<MooseX::MultiMethods>>

Обработка списков E<mdash> фундаментальная составляющая обработки выражений в
Perl 5. Способность Perl-программистов объединять в цепочки выражения,
возвращающие списки переменной длины, предоставляет бесчисленные возможности
для эффективного манипулирования данными.

Хотя простота передачи аргументов в Perl 5 (всё разглаживается в C<@_>) иногда
слишком проста, присваивание из C<@_> в списочном контексте позволяет вам
распаковывать именованные параметры как пары. Оператор толстой запятой
(L<declaring_hashes>) превращает простой список в то, что очевидно является
списком пар аргументов:

=begin programlisting

    make_ice_cream_sundae(
        whipped_cream => 1,
        sprinkles     => 1,
        banana        => 0,
        ice_cream     => 'mint chocolate chip',
    );

=end programlisting

Вызываемая сторона может распаковать эти параметры в хеш и работать с хешем,
как если бы он был одним аргументом:

=begin programlisting

    sub make_ice_cream_sundae
    {
        B<my %args    = @_;>
        my $dessert = get_ice_cream( $args{ice_cream} );

        ...
    }

=end programlisting

=begin tip Хеши или ссылки на хеши?

I<Perl Best Practices> предлагает вместо хешей передавать ссылки на хеши. Это
позволяет Perl выполнять валидацию ссылки на хеш на вызываемой стороне.

=end tip

Эта техника хорошо работает с C<import()> (L<importing>) или другими методами;
обработайте столько параметров, сколько хотите, прежде чем поглотить оставшуюся
часть в хеш:

=begin programlisting

    sub import
    {
        B<my ($class, %args)  = @_;>
        my $calling_package = caller();

        ...
    }

=end programlisting

=head2 Преобразование Шварца

Z<schwartzian_transform>

X<Schwartzian transform>
X<C<map>; Schwartzian transform>
X<C<sort>; Schwartzian transform>
X<builtins; C<map>>
X<builtins; C<sort>>

I<Преобразование Шварца> E<mdash> элегантная демонстрация всепроникающей обработки
списков в Perl в виде идиомы, удачно позаимствованной из семейства языков Lisp.

Предположим, у вас есть Perl-хеш, ассоциирующий имена ваших коллег с их
телефонными номерами:

=begin programlisting

    my %extensions =
    (
        '001' => 'Armon',
        '002' => 'Wesley',
        '003' => 'Gerald',
        '005' => 'Rudy',
        '007' => 'Brandon',
        '008' => 'Patrick',
        '011' => 'Luke',
        '012' => 'LaMarcus',
        '017' => 'Chris',
        '020' => 'Maurice',
        '023' => 'Marcus',
        '024' => 'Andre',
        '052' => 'Greg',
        '088' => 'Nic',
    );

=end programlisting

=begin tip Правила заключения в кавычки ключа хеша

Заключение в кавычки ключа хеша с помощью толстой запятой работает только с тем,
что выглядит как голые слова; эти ключи выглядят как числа E<mdash> восьмеричные
числа, если быть конкретным, с ведущим нулём. Да, почти все делают эту ошибку.

=end tip

Чтобы отсортировать список по имени в алфавитном порядке, вы должны
отсортировать хеш по его значениям, не ключам. Получить корректно
отсортированные значения легко:

=begin programlisting

    my @sorted_names = sort values %extensions;

=end programlisting

E<hellip>но вам нужен дополнительный шаг для сохранения связи имён и телефонов,
тут и вступает в дело преобразование Шварца. Во-первых, сконвертируйте хеш в
список структур данных, которые легко сортировать E<mdash> в данном случае,
двухэлементных анонимных массивов:

=begin programlisting

    my @pairs = map  { [ $_, $extensions{$_} ] }
                keys %extensions;

=end programlisting

C<sort> принимает список анонимных массивов и сравнивает их вторые элементы
(имена) как строки:

=begin programlisting

    my @sorted_pairs = sort { $a->[1] cmp $b->[1] }
                            @pairs;

=end programlisting

X<C<$a>>
X<C<$b>>
X<builtins; C<sort>>

Блок, переданный в C<sort>, принимает её аргументы в виде двух переменных C<$a>
и C<$b>, принадлежащих области видимости пакетаN<См. в C<perldoc -f sort>
пространное обсуждение применений такой организации области видимости.>.
Блок C<sort> принимает свои аргументы по два за раз; первый становится
содержимым C<$a>, а второй E<mdash> содержимым C<$b>. Если значение C<$a> должно
идти в результатах перед C<$b>, блок должен вернуть -1. Если оба значения
достаточно эквиваленты с точки зрения сортировки, блок должен вернуть 0. Наконец,
если C<$a> должно идти в результатах после C<$b>, блок должен вернуть 1. Любые
другие возвращаемые значения являются ошибками.

=begin tip Знайте свои данные

Переворачивание хеша I<на месте> будет работать, если имена ни у кого не
повторяются. Этот конкретный набор данных не имеет такой проблемы, но пишите
код с защитой.

=end tip

X<operators; C<cmp>>
X<< operators; C<< <=> >> >>

Оператор C<cmp> выполняет строковое сравнение, а C<< <=> >> выполняет числовое
сравнение.

Имея C<@sorted_pairs>, вторая операция C<map> преобразует структуру данных в
более удобную форму:

=begin programlisting

    my @formatted_exts = map { "$_->[1], ext. $_->[0]" }
                             @sorted_pairs;

=end programlisting

E<hellip>и теперь вы можете всё это вывести:

=begin programlisting

    say for @formatted_exts;

=end programlisting

Преобразование Шварца само по себе использует всепроникающую обработку списков
в Perl чтобы избавиться от временных переменных. Комбинация такая:

=begin programlisting

    say for
        map  { " $_->[1], ext. $_->[0]"          }
        sort {   $a->[1] cmp   $b->[1]           }
        map  { [ $_      =>    $extensions{$_} ] }
            keys %extensions;

=end programlisting

Читайте выражение справа налево, в порядке вычисления. Для каждого ключа в
хеше телефонов создать двухэлементный анонимный массив, содержащий ключ и
значение из хеша. Отсортировать этот список анонимных массивов по их
вторым элементам, значениям из хеша. Сформировать строку вывода из этих
отсортированных массивов.

Канал C<map>E<mdash>C<sort>E<mdash>C<map> в преобразовании Шварца трансформирует
структуру данных в другую, более подходящую для сортировки, а затем
трансформирует её снова в другую форму.

Хотя этот пример сортировки прост, рассмотрите случай вычисления
криптографического хеша для большого файла. Преобразование Шварца особенно
полезно, потому что оно эффективно кеширует любые дорогие вычисления, выполняя
их один раз в правом C<map>.

=head2 Лёгкое поглощение файлов

Z<easy_file_slurping>

X<builtins; C<local>>
X<C<$/>>
X<files; slurping>
X<global variables; C<$/>>

C<local> имеет большое значения для управления магическими глобальными
переменными Perl 5. Вы должны понимать области видимости (L<scope>), чтобы
эффективно использовать C<local> E<mdash> но если вам это удастся, вы можете
использовать тесные и легковесные области видимости интересными способами.
Например, для поглощения файлов в скаляр в одном выражении:

=begin programlisting

    my $file = do { local $/ = <$fh> };

    # или
    my $file = do { local $/; <$fh> };

    # или
    my $file; { local $/; $file = <$fh> };

=end programlisting

C<$/> E<mdash> это разделитель входных записей. Его локализация с помощью
C<local> устанавливает его значение в C<undef>, ожидая присваивания. Эта
локализация происходит I<перед> присваиванием. Так как значение разделителя
неопределённо, Perl охотно считает всё содержимое дескриптора файла сразу и
присвоит это значение C<$/>. Так как блок C<do> возвращает значение последнего
вычисленного внутри блока выражения, это возвращает значение присваивания:
содержимое файла. Даже несмотря на то, что в конце блока C<$/> немедленно
возвращается к своему предыдущему состоянию, C<$file> теперь вмещает содержимое
файла.

Второй пример не содержит присваивания и всего лишь возвращает единственную
строку, прочитанную из дескриптора файла.

Третий пример избегает повторного копирования строки, вмещающей содержимое
файла; он не так красив, но использует меньше памяти.

=begin tip C<File::Slurp>

X<CPAN; C<File::Slurp>>

Общеизвестно, что этот полезный пример сводит с ума людей, не понимающих, как
работает и C<local>, и области видимости. Модуль C<File::Slurp> из CPAN E<mdash>
стоящая (и зачастую более быстрая) альтернатива.

=end tip

=head2 Обращение с главным

Perl не требует специального синтаксиса для создания замыканий (L<closures>);
вы можете непреднамеренно замкнуть лексическую переменную. Многие программы
обычно выставляют несколько лексичеких переменных области видимости файла, прежде
чем передать обработку другим функциям. Возникает соблазн использовать эти
переменные напрямую, вместо передачи и возврата значений из функций, особенно с
ростом программы. К сожалению, эти программы могут начать полагаться на тонкости
того, что происходит во время процесса компиляции Perl 5; переменная, которая,
как вы I<думали>, должна быть инициализирована определённым значением, может
быть инициализирована лишь намного позже.

Чтобы этого избежать, оберните основной код вашей программы в простую функцию,
C<main()>. Инкапсулируйте ваши переменные в соответствующих областях видимости.
Затем добавьте единственную строку в начало вашей программы, после подключения
всех нужных модулей и прагм:

=begin programlisting

    #!/usr/bin/perl

    use Modern::Perl;

    ...

    B<exit main( @ARGS );>

=end programlisting

Вызов C<main()> I<перед> чем либо ещё в программе заставляет вас быть ясными
относительно инициализации и порядка компиляции. Вызов C<exit> с возвращаемым
C<main()> значением предотвращает любой другой голый код от выполнения, хотя
вы должны удостовериться, что возвращаете C<0> из C<main()> в случае успешного
выполнения.

=head2 Контроллируемое выполнение

Z<controlled_execution>

Фактическое различие между программой и модулем E<mdash> в их намеренном
использовании. Пользователи вызывают программы напрямую, тогда как программы загружают
модули после того, как выполнение уже началось. Тем не менее, модуль E<mdash>
это Perl-код, точно так же, как и программа. Модуль легко сделать исполняемым.
Так же как и заставить программу вести себя как модуль (полезно для тестирования
частей существующей программы без формального преобразования её в модуль). Всё
что вам нужно сделать E<mdash> открыть для себя, I<как> Perl начинает выполнение
куска кода.

X<builtins; C<caller>>

Единственный необязательный аргумент C<caller> E<mdash> это число фреймов
вызова (L<recursion>), которое нужно выдать. C<caller(0)> выводит информацию о 
текущем фрейме вызова. Чтобы позволить модулю работать корректно как программа
I<или> модуль, поместите весь выполняемый код в функции, добавьте функцию 
C<main()> и допишите одну строку в начало модуля:

=begin programlisting

    main() unless caller(0);

=end programlisting

Если у модуля I<нет> вызывающего кода, значит, кто-то вызвал его напрямую как
программу (с помощью C<perl path/to/Module.pm>) вместо C<use Module;>).

=begin tip Улучшенная инспекция вызывающего кода

Восьмой элемент списка, возвращаемого из C<caller> в списочном контексте, будет
истинным значением, если фрейм вызова представляет собой C<use> или C<require>, и
C<undef> в противном случае. Хотя это более точно, немногие этим пользуются.

=end tip

=head2 Постфиксная валидация параметров

Z<postfix_parameter_validation>

X<CPAN; C<Params::Validate>>
X<CPAN; C<MooseX::Params::Validate>>

В CPAN есть несколько модулей, помогающих проверить параметры ваших функций; два
хороших варианта E<mdash> C<Params::Validate> и C<MooseX::Params::Validate>.
Выполнить простую валидацию легко даже без этих модулей.

Предположим, ваша функция принимает два аргумента, не больше и не меньше. Вы
I<могли бы> написать:

=begin programlisting

    use Carp 'croak';

    sub groom_monkeys
    {
        if (@_ != 2)
        {
            croak 'Grooming requires two monkeys!';
        }
        ...
    }

=end programlisting

E<hellip>но с лингвистической точки зрения последствия более важны, чем
проверка, и заслуживают быть в I<начале> выражения:

=begin programlisting

    croak 'Grooming requires two monkeys!' if @_ != 2;

=end programlisting

E<hellip>что может читаться проще в следующем виде:

=begin programlisting

    croak 'Grooming requires two monkeys!'
        unless @_ == 2;

=end programlisting

Эта техника раннего возврата E<mdash> особенно с постфиксными условиями E<mdash>
может упростить оставшуюся часть кода. Каждая такая проверка E<mdash> это
фактически одна строка в таблице истинности.

=head2 Регулярные выражения мимоходом

Z<regex_en_passant>

X<regex; modification>
X<regex; substitution>

Многие идиомы Perl 5 полагаются на тот факт, что выражения возвращают значения:

=begin programlisting

    say my $ext_num = my $extension = 42;

=end programlisting

Хотя этот код очевидно неуклюж, он демонстрирует, как использовать значение
одного выражения в другом выражении. Эта идея не нова; вы с большой вероятностью
и раньше использовали возвращаемое значение функции в списке или как аргумент
другой функции. Вы, возможно, не осознавали последствий этого.

X<regex; capture>

Предположим, вы хотите извлечь имя из сочетания имени и фамилии с помощью
прекомпилированного регулярного выражения в C<$first_name_rx>:

=begin programlisting

    my ($first_name) = $name =~ /($first_name_rx)/;

=end programlisting

В списочном контексте успешное сопоставление регулярному выражению возвращает
список всех захватов (L<regex_captures>), и Perl присваивает первый из них
C<$first_name>.

Чтобы изменить имя, возможно, удалив все несловарные символы для создания пригодного
имени пользователя для системного аккаунта, вы можете написать:

=begin programlisting

    (my $normalized_name = $name) =~ tr/A-Za-z//dc;

=end programlisting

=begin tip /r в Perl 5.14

В Perl 5.14 был добавлен недеструктивный модификатор замены C</r>, так что вы
можете написать C<my $normalized_name = $name =~ tr/A-Za-z//dcB<r>;>.

=end tip

Сперва присвойте значение C<$name> C<$normalized_name>, так как скобки влияют на
приоритет, это присваивание произойдёт первым. Выражение присваивания возвращает
I<переменную> C<$normalized_name>, так что эта переменная становится первым
операндом оператора транслитерации.

Эта техника работает и с другими операциями модификации на месте:

=begin programlisting

    my $age = 14;
    (my $next_age = $age)++;

    say "Next year I will be $next_age";

=end programlisting

=head2 Унарное приведение типа

Z<unary_coercions>

X<coercion>
X<types>

Система типов Perl 5 почти всегда делает то, что нужно, если вы выбираете
правильные операторы. Используйте оператор строковой конкатенации, и Perl будет
обращаться с обоими операндами как со строками. Используйте оператор сложения,
и Perl будет обращаться с обоими операндами как с числовыми.

Иногда вам придётся дать Perl подсказку о том, что вы имеете ввиду, с помощью
I<унарного приведения типа>, чтобы заставить вычисление значения выполняться
конкретным образом.

X<unary conversions; numeric>

Чтобы убедиться, что Perl обрабатывает значение как числовое, прибавьте ноль:

=begin programlisting

    my $numeric_value = 0 + $value;

=end programlisting

X<unary conversions; boolean>

Чтобы убедиться, что Perl обрабатывает значение как булево, используйте двойное
отрицание:

=begin programlisting

    my $boolean_value = !! $value;

=end programlisting

X<unary conversions; string>

Чтобы убедиться, что Perl обрабатывает значение как строку, конкатенируйте его с
пустой строкой:

=begin programlisting

    my $string_value = '' . $value;

=end programlisting

Хотя потребность в этих приведениях типа исчезающе мала, вы должны понимать эти
идиомы, если они вам встретятся.
Хотя удаление E<laquo>бесполезногоE<raquo> C<+ 0> из выражения может выглядеть
безопасным, это может сломать код.
