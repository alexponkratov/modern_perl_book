=encoding utf-8

=head1 Благословлённые ссылки

Z<blessed_references>

Базовая система объектов Perl 5 сознательно минималистична. Она включает
всего три правила:

=over 4

=item * Класс E<mdash> это пакет.

=item * Метод E<mdash> это функция.

=item * (Благословлённая) ссылка E<mdash> это объект.

=back

Основываясь на этих трёх правилах, вы можете построить что угодно, но это всё,
что вы получаете по умолчанию. Этот минимализм для больших проектов может быть
непрактичен E<mdash> особенно неловки и ограниченны возможности увеличения
абстракции посредством метапрограммирования (L<code_generation>). Moose
(L<moose>) E<mdash> более подходящий выбор для современных программ, размер
которых больше чем несколько сотен строк кода, хотя большое количество
унаследованного кода всё ещё использует стандартное ООП Perl 5.

X<OO; C<bless>>
X<builtins; C<bless>>

Последняя часть стандартного ООП Perl 5 E<mdash> благословлённая ссылка.
Встроенная функция bless ассоциирует имя класса со ссылкой. Эта ссылка
становится корректным инвокантом, и Perl будет выполнять на ней диспетчеризацию
методов, используя ассоциированный класс.

X<OO; constructors>
X<OO; class methods>
X<methods; class>

Конструктор E<mdash> это метод, создающий и благословляющий ссылку. По
соглашению конструкторы имеют имя C<new()>, но это не обязательно. Кроме того,
конструкторы почти всегда являются I<методами класса>.

C<bless> принимает два аргумента, ссылку и имя класса. Она возвращает ссылку.
Ссылка может быть пустой. Класс ещё не обязательно должен существовать. Вы даже
можете использовать C<bless> за пределами конструктора или класса (хотя все
программы, кроме самых простых, должны использовать настоящие конструкторы).
Канонический конструктор выглядит так:

=begin programlisting

    sub new
    {
        my $class = shift;
        bless {}, $class;
    }

=end programlisting

По замыслу, этот конструктор получает имя класса как инвокант метода.
Но вы можете и захардкодить имя класса, потеряв при этом в гибкости.
Параметрический конструктор даёт возможность повторного использования
посредством наследования, делегирования или экспорта.

X<OO; instance data>

Используемый тип ссылки имеет значение только для того, как объект хранит свои
I<данные экземпляра>. Он не оказывает никакого другого влияния на результирующий
объект. Ссылки на хеши наиболее распространены, но благословить можно любой тип
ссылки:

=begin programlisting

    my $array_obj  = bless [], $class;
    my $scalar_obj = bless \$scalar, $class;
    my $sub_obj    = bless \&some_sub, $class;

=end programlisting

Классы Moose определяют атрибуты объекта декларативно, но стандартное ООП Perl 5
недостаточно формально. Класс, представляющий игроков в баскетбол, и хранящий
номер футболки и позицию, может использовать такой конструктор:

=begin programlisting

    package Player
    {
        sub new
        {
            my ($class, %attrs) = @_;
            bless \%attrs, $class;
        }
    }

=end programlisting

E<hellip>и создавать игроков так:

=begin programlisting

    my $joel  = Player->new( number  => 10,
                            position => 'center' );

    my $dante = Player->new( number   => 33,
                             position => 'forward' );

=end programlisting

Методы класса могут обращаться к атрибутам объекта напрямую как к элементам
хеша:

=begin programlisting

    sub format
    {
        my $self = shift;
        return '#'       . $self->{number}
             . ' plays ' . $self->{position};
    }

=end programlisting

E<hellip>но так же это может делать и любой другой код, так что любое изменение
внутреннего представления объекта может сломать другой код. Методы-аксессоры
безопаснее:

=begin programlisting

    sub number   { return shift->{number}   }
    sub position { return shift->{position} }

=end programlisting

E<hellip>и вот вы уже начинаете вручную писать то, что Moose даёт вам бесплатно.
Мало того, Moose поощряет использовать аксессоры вместо прямого доступа, скрывая
код генерации аксессоров. Прощайте, соблазны.

=head2 Поиск методов и наследование

X<method dispatch>
X<OO; methods>

При наличии благословлённой ссылки, вызов метода осуществляется следующим образом:

=begin programlisting

    my $number = $joel->number();

=end programlisting

E<hellip>ищет имя класса, ассоциированного с благословлённой ссылкой C<$joel>
E<mdash> в данном случае C<Player>. Затем Perl ищет функциюN<Вспомните, что
Perl 5 не делает различия между функциями в пространстве имён и методами.> с
именем C<number()> в классе C<Player>. Если такой функции не существует и если
C<Player> расширяет другой класс, Perl ищет в родительском классе (и так далее
и так далее), до тех пор, пока не найдёт C<number()>. Если Perl находит
C<number()>, он вызывает этот метод с C<$joel> в качестве инвоканта.

=begin tip Сохранение пространств имён чистыми

X<CPAN; C<namespace::autoclean>>

CPAN-модуль C<namespace::autoclean> может помочь избежать непреднамеренных
коллизий между импортируемыми функциями и методами.

=end tip

X<C<@ISA>>
X<OO; C<@ISA>>

Moose предоставляет C<extends> для отслеживания связей наследования, Perl 5 же
использует глобальную переменную пакета с именем C<@ISA>. Диспетчер методов
ищет в C<@ISA> каждого класса имена его родительских классов. Если
C<InjuredPlayer> расширяет C<Player>, вы можете написать так:

=begin programlisting

    package InjuredPlayer
    {
        @InjuredPlayer::ISA = 'Player';
    }

=end programlisting

X<C<parent> pragma>
X<pragmas; C<parent>>

Прагма C<parent> (L<pragmas>) чищеN<Старый код может использовать прагму
C<base>, но C<parent> заменила C<base> в Perl 5.10.>:

=begin programlisting

    package InjuredPlayer
    {
        use parent 'Player';
    }

=end programlisting

Moose имеет собственную метамодель, сохраняющую расширенную информацию о
наследовании; это обеспечивает дополнительные возможности.

X<multiple inheritance>
X<OO; inheritance>

Вы можете наследовать от нескольких родительских классов:

=begin programlisting

    package InjuredPlayer;
    {
        use parent qw( Player Hospital::Patient );
    }

=end programlisting

E<hellip>хотя есть предостережения против множественного наследования и сложности
диспетчеризации методов. Рассмотрите использование в качестве замены ролей
(L<roles>) или модификаторов методов Moose.

=head2 AUTOLOAD

X<C<AUTOLOAD>>
X<OO; C<AUTOLOAD>>
X<methods; C<AUTOLOAD>>

Если в классе инвоканта или в любом из его суперклассов нет
подходящего метода, дальше Perl 5 будет искать функцию C<AUTOLOAD()>
(L<autoload>) в каждом классе в соответствии с выбранным порядком разрешения
методов. Perl вызовет любую найденную функцию C<AUTOLOAD()>, чтобы она
предоставила или отклонила желаемый метод.

C<AUTOLOAD()> делает множественное наследование гораздо более сложным для
понимания.

=head2 Перегрузка методов и SUPER

Как и в Moose, в стандартном ООП Perl 5 вы можете перегружать методы. В отличие
от Moose, стандартный Perl 5 не предоставляет механизмов для указания вашего
I<намерения> переопределить родительский метод. Хуже того, любая функция,
которую вы предварительно определили, определили или импортировали в дочерний
класс, может перегрузить метод родительского класса, если имеет то же самое имя.
Даже если вы забыли использовать предоставляемую Moose систему перегрузки с
C<override>, она по крайней мере существует. Стандартное ООП Perl 5 не предлагает
такой защиты.

X<builtins; C<SUPER::>>

Чтобы перегрузить метод в дочернем классе, объявите метод с тем же именем, что и
метод в родительском классе. Внутри перегруженного метода можно вызвать
родительский метод с помощь подсказки диспетчера C<SUPER::>:

=begin programlisting

    sub overridden
    {
        my $self = shift;
        warn 'Called overridden() in child!';
        return $self->SUPER::overridden( @_ );
    }

=end programlisting

Префикс C<SUPER::> у имени метода указывает диспетчеру методов перейти к
перегруженному методу с соответствующим именем. Вы можете указать собственные
аргументы для перегруженного метода, но большая часть кода использует C<@_>.
Не забудьте удалить вызывающую сущность с помощью C<shift>, если вы так делаете.

=begin tip Сломанность C<SUPER::>

X<CPAN; C<SUPER>>

C<SUPER::> имеет сбивающий с толку недостаток: он диспетчеризует к родителю
пакета, в который был I<скомпилирован> перегруженный метод. Если вы
импортировали этот метод из другого пакета, Perl с удовольствием направит к
I<неверному> родителю. Потребность в обратной совместимости привела к сохранению
этой неудачной функции. Модуль C<SUPER> из CPAN предлагает обходной путь. В
Moose C<super()> не страдает от такого недостатка.

=end tip

=head2 Стратегии обращения с благословлёнными ссылками

Если благословлённые ссылки выглядят минималистичными, коварными и сбивающими с
толку, такие они и есть. Moose E<mdash> огромное улучшение. Используйте его
везде, где возможно. Если же вам придётся поддерживать код, использующий
благословлённые ссылки, или вы ещё не смогли убедить свою команду полностью
перейти на Moose, вы можете обойти некоторые проблемы благословлённых ссылок с
помощью дисциплины.

X<C<Class::Accessor>>

=over 4

=item * Повсеместно используйте методы-аксессоры, даже в методах вашего класса.
Рассмотрите использование модуля наподобие C<Class::Accessor>, чтобы избежать
повторяющегося кода.

=item * По возможности избегайте использования C<AUTOLOAD()>. Если вам
I<необходимо> его использовать, используйте предварительные объявления ваших
функций (L<functions>), чтобы помочь Perl понять, какая функция C<AUTOLOAD>
предоставляет реализацию метода.

=item * Исходите из предположения, что кому-нибудь, где-нибудь рано или поздно
потребуется унаследовать от ваших классов (или делегировать, или переопределить
интерфейс). Упростите эту задачу, не предполагая понимания внутренних
деталей вашего кода, используя двухаргументную форму C<bless>, и разбивая ваши
классы на наименьшие возможные самостоятельные единицы кода.

=item * Не смешивайте функции и методы в одном классе.

=item * Используйте один файл F<.pm> для каждого класса, если только класс не
является маленьким, самодостаточным вспомогательным инструментом, используемым
в одном месте.

=back
