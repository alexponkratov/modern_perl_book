=encoding utf-8

=head1 Переменные

Z<variables>
X<variable>

I<Переменная> в Perl E<mdash> это место хранения значения (L<values>). Хотя
простая программа может манипулировать значениями напрямую, большинство программ
работают с переменными для упрощения логики кода. Переменные представляют
значения; проще объяснить теорему Пифагора в терминах переменных C<a>, C<b> и
C<c>, чем демонстрируя её принцип длинным списком корректных значений. Эта
концепция может выглядеть очевидной, но эффективное программирование требует от
вас справляться с искусством балансирования между общим и повторно используемым
с одной стороны и конкретным E<mdash> с другой.

=head2 Области видимости переменных

Z<variable_scopes>

X<variables; scope>
X<scope>
X<builtins; C<package>>

Переменные видны частям вашей программы в зависимости от их области видимости
(L<scope>). Большая часть переменных, с которыми вы встретитесь, имеет
лексическую область видимости (L<lexical_scope>). Сами I<файлы> задают свои
собственные лексические области видимости, так что объявление C<package> само по
себе новую область видимости не создаёт:

=begin programlisting

    package Store::Toy;

    my $discount = 0.10;

    package Store::Music;

    # переменная $discount всё ещё видима
    say "Our current discount is $discount!";

=end programlisting

X<builtins; C<package>; BLOCK>

Начиная с Perl 5.14, вы можете задать блок для объявления C<package>. Такой
синтаксис I<создаёт> лексическую область видимости:

=begin programlisting

    package Store::Toy
    {
        my $discount = 0.10;
    }

    package Store::Music
    {
        # переменная $discount не доступна
    }

    package Store::BoardGame;

    # переменная $discount всё ещё не доступна

=end programlisting

=head2 Сигилы переменных

Z<sigils>

X<variables; sigils>
X<sigils>

Сигил переменной в объявлении определяет тип переменной: скаляр, массив или хеш.
Сигил, используемый при доступе к переменной, варьируется в зависимости от того,
что вы делаете с переменной. Например, вы объявляете массив как C<@values>.
C<$values[0]> E<mdash> доступ к первому элементу массива E<mdash> единичному
значению. C<@values[ @indices ]> E<mdash> доступ к списку значений из массива.

=head2 Анонимные переменные

X<anonymous variables>
X<variables; anonymous>

Переменные в Perl не I<требуют> имён. Имена существуют чтобы помочь вам,
программисту, следить за C<$apple>, C<@barrels> или C<%cheap_meals>. Переменные,
созданные в вашем программном коде I<без> литеральных имён, называются
I<анонимными> переменными. Единственный способ обратиться к анонимной переменной
E<mdash> по ссылке (L<references>).

=head2 Переменные, типы и приведение типов

X<variables; types>
X<variables; container type>
X<variables; value type>

Переменная в Perl 5 представляет как значение (курс доллара, доступные начинки
для пиццы, гитарные магазины с телефонными номерами), так и контейнер, в котором
хранится это значение. Система типов Perl имеет дело с I<типами значений> и
I<типами контейнеров>. Тогда как I<тип контейнера> переменной E<mdash> скаляр,
массив или хеш E<mdash> не может измениться, относительно типа значения
переменной Perl проявляет гибкость. Вы можете сохранить строку в переменной в
одной строке кода, добавить к этой переменной число в следующей и переназначить
ей ссылку на функцию (L<function_references>) в третьей.

Выполнение над переменной операции, требующей конкретного типа значения, может
вызвать приведение (L<coercion>) из текущего типа значения переменной.

Например, документированный способ определить количество элементов в массиве
E<mdash> обратиться к нему в скалярном контексте (L<context_philosophy>). Так
как скалярная переменная может содержать только скаляр, присвоение массива
скаляру налагает на операцию скалярный контекст, и массив, вычисленный в
скалярном контексте, возвращает количество элементов в этом массиве:

=begin programlisting

    my $count = @items;

=end programlisting

Отношения между типами переменных, сигилами и контекстом имеют первостепенную
важность.
