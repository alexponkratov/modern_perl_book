=encoding utf-8

=head1 Рефлексия

Z<reflection>

X<reflection>
X<introspection>

I<Рефлексия> (или I<интроспекция>) E<mdash> это процесс получения от программы
информации о ней самой во время её выполнения. Работая с кодом как с данными, вы
можете управлять кодом так же, как вы управляете данными. На этом принципе
основана кодогенерация (L<code_generation>).

X<CPAN; C<Class::MOP>>

C<Class::MOP> из Moose (L<class_mop>) упрощает многие задачи рефлексии для
объектных систем. Если вы используете Moose, его система метапрограммирования
поможет вам. Если нет, несколько других идиом стандартного Perl 5 помогут вам
инспектировать и манипулировать запущенными программами.

=head2 Проверка того, что модуль загружен

X<C<%INC>>

Если вы знаете имя модуля, вы можете проверить, считает ли Perl, что этот модуль
загружен, заглянув в хеш C<%INC>. Когда Perl 5 загружает код с помощью C<use>
или C<require>, он сохраняет запись в C<%INC>, где ключ E<mdash> файловый путь
загружаемого модуля, а значение E<mdash> полный путь к модулю на диске. Другими
словами, загрузка C<Modern::Perl> фактически делает следующее:

=begin programlisting

    $INC{'Modern/Perl.pm'} =
        '.../lib/site_perl/5.12.1/Modern/Perl.pm';

=end programlisting

Точный путь будет различаться в зависимости от вашей инсталляции. Чтобы
проверить, что Perl успешно загрузил модуль, преобразуйте имя модуля в
каноническую файловую форму и проверьте существование этого ключа в C<%INC>:

=begin programlisting

    sub module_loaded
    {
        (my $modname = shift) =~ s!::!/!g;
        return exists $INC{ $modname . '.pm' };
    }

=end programlisting

X<C<@INC>>
X<CPAN; C<Test::MockObject>>
X<CPAN; C<Test::MockModule>>

Как и с C<@INC>, любой код в любом месте может манипулировать C<%INC>. Некоторые
модули (такие как C<Test::MockObject> или C<Test::MockModule>) манипулируют
C<%INC> с благими намерениями. В зависимости от уровня вашей паранойи, вы можете
сами проверять путь и ожидаемое содержимое пакета.

X<CPAN; C<Class::Load>>

Функция C<is_class_loaded()> CPAN-модуля C<Class::Load> инкапсулирует эту
проверку C<%INC>.

=head2 Проверка существования пакета

Чтобы проверить существование пакета в вашей программе E<mdash> того, что
какой-то код где-то выполнил директиву C<package> с заданным именем E<mdash>
проверьте, что пакет наследует от C<UNIVERSAL>. Всё, что расширяет C<UNIVERSAL>,
должно так или иначе предоставлять метод C<can()>. Если такого пакета не
существует, Perl выбросит исключение о некорректной вызывающей сущности, так что
оберните этот вызов в блок C<eval>:

=begin programlisting

    say "$pkg exists" if eval { $pkg->can( 'can' ) };

=end programlisting

Альтернативный подход E<mdash> копание в таблице символов Perl.

=head2 Проверка существования класса

Так как Perl 5 не делает строгих различий между пакетами и классами, лучшее, что
вы можете сделать без Moose E<mdash> проверить существование пакета ожидаемого
имени класса. Вы I<можете> проверить с помощью C<can()>, что этот пакет
предоставляет C<new()>, но нет никаких гарантий, что найденный C<new()> будет
методом или конструктором.

=head2 Проверка номера версии модуля

Модули не обязаны предоставлять номера версий, но каждый пакет наследует метод
C<VERSION()> от универсального родительского класса C<UNIVERSAL> (L<universal>):

=begin programlisting

    my $mod_ver = $module->VERSION();

=end programlisting

C<VERSION()> возвращает номер версии заданного модуля, если он определён. В
противном случае он возвращает C<undef>. Если модуль не существует, метод
тоже вернёт C<undef>.

=head2 Проверка существования функции

Чтобы проверить, существует ли функция в пакете, вызовите C<can()> как метод
класса на имени пакета:

=begin programlisting

    say "$func() exists" if $pkg->can( $func );

=end programlisting

Perl выбросит исключение, если C<$pkg> не является допустимым инвокантом;
оберните вызов метода в блок C<eval> если у вас есть какие-либо
сомнения в его валидности. Имейте ввиду, что функция, реализованная в терминах
C<AUTOLOAD()> (L<autoload>), может давать неправильный ответ, если в пакете
функции нет корректного предварительного объявления функции или корректной
перегрузки C<can()>. Это ошибка в другом пакете.

Используйте эту технику для определения того, импортировал ли C<import()> модуля
функцию в текущее пространство имён:

=begin programlisting

    say "$func() imported!" if __PACKAGE__->can( $func );

=end programlisting

Как и в случае проверки существования пакета, вы I<можете> сами покопаться в
таблице символов, если у вас есть для этого достаточно терпения.

=head2 Проверка существования метода

Нет надёжного способа для рефлексии определить разницу между функцией и методом.

=head2 Копание в таблице символов

X<symbol tables>
X<typeglobs>

Таблица символов Perl 5 E<mdash> это специальный тип хеша, где ключи E<mdash>
это имена глобальных символов пакета, а значения E<mdash> тайпглобы (typeglob).
I<Тайпглоб> E<mdash> это внутренняя структура данных, которая может содержать
любой из или все типы E<mdash> скаляр, массив, хеш, дескриптор файла и функцию.

Обратиться к символьной таблице как к хешу можно добавив двойное двоеточие к
имени пакета. Например, символьная таблица пакета C<MonkeyGrinder> доступна как
C<%MonkeyGrinder::>.

Вы I<можете> проверить существование конкретных имён символов в таблице символов
с помощью оператора C<exists> (или манипулировать таблицей символов для
I<добавления> или I<удаления> символов, если хотите). Однако имейте ввиду, что
определённые изменения в ядре Perl 5 модифицировали детали того, что хранят
тайпглобы, когда и как.

X<CPAN; C<Package::Stash>>

Загляните в секцию E<laquo>Symbol TablesE<raquo> в C<perldoc perlmod> для
получения подробностей, а затем отдайте предпочтение другим техникам рефлексии,
описанным в этом разделе. Если вам действительно нужно манипулировать таблицами
символов и тайпглобами, рассмотрите использование вместо этого CPAN-модуля
C<Package::Stash>.
