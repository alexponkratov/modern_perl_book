=encoding utf-8

=head1 Хеши

Z<hashes>

X<hashes>

I<Хеш> E<mdash> структура данных первого класса в Perl, которая ассоциирует
строковые ключи со скалярными значениями. Так же как имя переменной
соотносится с местом хранения, так и ключ в хеше ссылается на значение.
Воспринимайте хеш как телефонную книгу: используйте имена ваших друзей для
поиска их номеров. В других языках хеши называются I<таблицами>,
I<ассоциативными массивами>, I<словарями> или I<картами>.

Хеши имеют два важных свойства: они хранят один скаляр на уникальный ключ, и
они не имеют определённой сортировки ключей.

=head2 Объявление хешей

Z<declaring_hashes>

X<hashes; declaring>
X<C<%>; sigil>
X<sigils; C<%>>

Хеши используют сигил C<%>. Объявляются хеши так:

=begin programlisting

    my %favorite_flavors;

=end programlisting

Хеши создаются пустыми. Вы можете написать C<my %favorite_flavors = ()>, но это
излишне.

X<C<$>; sigil>
X<sigils; C<$>>

Хеши используют скалярный сигил C<$> для доступа к отдельным элементам и
фигурные скобки C<{ }> для доступа по ключам:

=begin programlisting

    my %favorite_flavors;
    $favorite_flavors{Gabi}    = 'Raspberry chocolate';
    $favorite_flavors{Annette} = 'French vanilla';

=end programlisting

Присваивание хешу списка ключей и значений в одном выражении:

=begin programlisting

    my %favorite_flavors = (
        'Gabi',    'Raspberry chocolate',
        'Annette', 'French vanilla',
    );

=end programlisting

X<<< C<< => >>; fat comma operator >>>
X<<< operators; C<< => >> >>>

Если вы присвоите нечётное количество элементов хешу, то получите
предупреждение. Идиоматический Perl часто использует оператор I<толстая запятая>
(C<< => >>) для установки соответствия значений ключам, так как это делает
разбиение на пары более заметным визуально:

=begin programlisting

    my %favorite_flavors = (
        Gabi    B<< => >> 'Mint chocolate chip',
        Annette B<< => >> 'French vanilla',
    );

=end programlisting

Оператор толстая запятая ведёт себя как обычная запятая, но кроме того он
автоматически заключает в кавычки предшествующее голое слово (L<barewords>).
Прагма C<strict> не будет предупреждать о таком голом слове E<mdash> и если у
вас есть функция с таким же именем, как ключ хеша, толстая запятая I<не> будет
вызывать функцию:

=begin programlisting

    sub name { 'Leonardo' }

    my %address =
    (
        name => '1123 Fib Place',
    );

=end programlisting

Ключом хеша будет C<name>, а не C<Leonardo>. Чтобы вызвать функцию, сделайте её
вызов явным:

=begin programlisting

    my %address =
    (
        B<name()> => '1123 Fib Place',
    );

=end programlisting

=begin notetip

Присваивание хешу происходит в списочном контексте. Любая функция, вызванная в
присваивании хешу, по умолчанию будет вызвана в списочном контексте, если нет
явного преобразования с помощью C<scalar>.

=end notetip

Для очистки хеша присвойте ему пустой списокN<Иногда вам может встретиться
C<undef %hash>.>:

=begin programlisting

    %favorite_flavors = ();

=end programlisting

=head2 Индексация хеша

X<hashes; values>

Доступ к отдельному значению хеша осуществляется с помощью операции индексации.
Используйте ключ (I<доступ по ключу>) для получения значения из хеша:

=begin programlisting

    my $address = $addresses{$name};

=end programlisting

В этом примере C<$name> содержит строку, которая также является ключом хеша. Как
и при доступе к отдельному элементу массива, сигил хеша изменился с C<%> на
C<$> для обозначения доступа по ключу к скалярному значению.

Вы можете использовать строковые литералы как ключи хеша. Perl автоматически
заключит голые слова в кавычки в соответствии с теми же правилами, что и толстые
запятые:

=begin programlisting

    # автоматическое заключение в кавычки
    my $address = $addresses{Victor};

    # требует заключения в кавычки; не допустимое голое слово
    my $address = $addresses{B<'>Sue-LinnB<'>};

    # вызов функции требует устранения неоднозначности
    my $address = $addresses{get_nameB<()>};

=end programlisting

=begin tip Не заключайте меня в кавычки

Новички зачастую всегда заключают в кавычки строковые литералы, являющиеся
ключами хеша, но опытные разработчики опускают кавычки везде, где возможно. В
этом смысле, наличие кавычек в ключах хеша указывает на намерение сделать что-то
другое.

=end tip

Даже на встроенные функции Perl 5 распространяется автоматическое заключение в
кавычки:

=begin programlisting

    my %addresses =
    (
        Leonardo => '1123 Fib Place',
        Utako    => 'Cantor Hotel, Room 1',
    );

    sub get_address_from_name
    {
        return $addresses{B<+>shift};
    }

=end programlisting

Унарный плюс (L<unary_coercions>) превращает то, на что как на голое слово
(C<shift>) должны распространяться правила автоматического заключения в кавычки,
в выражение. Как из этого следует, вы можете использовать произвольное выражение
E<mdash> не только вызов функции E<mdash> как ключ хеша:

=begin programlisting

    # хотя не стоит этого I<делать> на самом деле
    my $address = $addresses{reverse 'odranoeL'};

    # интерполяция допустима
    my $address = $addresses{"$first_name $last_name"};

    # как и вызовы методов
    my $address = $addresses{ $user->name() };

=end programlisting

Ключи хешей могут быть только строками. Всё, что вычисляется в строку, является
допустимым ключом хеша. Perl пойдёт так далеко, что приведёт (L<coercion>)
любую не-строку в строку, так что если вы используете объект как ключ хеша, вы
получите строковую версию этого объекта вместо самого объекта:

=begin programlisting

    for my $isbn (@isbns)
    {
        my $book = Book->fetch_by_isbn( $isbn );

        # вряд ли сделает именно то, чего вы хотите
        $books{$book} = $book->price;
    }

=end programlisting

=head2 Существование ключа хеша

X<builtins; C<exists>>
X<hashes; C<exists>>

Оператор C<exists> возвращает булево значение, указывающее, содержит ли хеш
указанный ключ:

=begin programlisting

    my %addresses =
    (
        Leonardo => '1123 Fib Place',
        Utako    => 'Cantor Hotel, Room 1',
    );

    say "Have Leonardo's address"
        if exists $addresses{Leonardo};
    say "Have Warnie's address"
        if exists $addresses{Warnie};

=end programlisting

Использование C<exists> вместо прямого доступа к ключу хеша позволяет избежать
двух проблем. Во-первых, оно не проверяет булеву природу I<значения> хеша; ключ
хеша может существовать и иметь значение, даже если это значение является ложью
(включая C<undef>):

=begin programlisting

    my  %false_key_value = ( 0 => '' );
    ok( %false_key_value,
         'hash containing false key & value
          should evaluate to a true value' );

=end programlisting

Во-вторых, C<exists> избегает автовивификации (L<autovivification>) во вложенных
структурах данных (L<nested_data_structures>).

X<builtins; C<defined>>

Если ключ хеша существует, его значением может быть C<undef>. Проверьте это с
помощью C<defined>:

=begin programlisting

    $addresses{Leibniz} = undef;

    say "Gottfried lives at $addresses{Leibniz}"
        if exists  $addresses{Leibniz}
        && defined $addresses{Leibniz};

=end programlisting

=head2 Доступ к ключам и значениям хеша

X<hashes; C<keys>>
X<builtins; C<keys>>

Хеши E<mdash> агрегатные переменные, но их парная природа даёт намного больше
возможностей для итераций: по ключам хеша, по значениям хеша, или по парам
ключей и значений. Оператор C<keys> возвращает список ключей хеша:

=begin programlisting

    for my $addressee (keys %addresses)
    {
        say "Found an address for $addressee!";
    }

=end programlisting

X<hashes; C<values>>
X<builtins; C<values>>

Оператор C<values> возвращает список значений хеша:

=begin programlisting

    for my $address (values %addresses)
    {
        say "Someone lives at $address";
    }

=end programlisting

X<hashes; C<each>>
X<builtins; C<each>>

Оператор C<each> возвращает список двухэлементных списков из ключа и значения:

=begin programlisting

    while (my ($addressee, $address) = each %addresses)
    {
        say "$addressee lives at $address";
    }

=end programlisting

В отличие от массивов, в этих списках нет очевидной сортировки. Сортировка
зависит от внутренней реализации хеша, конкретной используемой вами версии Perl,
размера хеша и элемента случайности. Несмотря на это, порядок элементов хеша
согласован для C<keys>, C<values> и C<each>. Модификация хеша может изменять
этот порядок, но вы можете на него полагаться, если хеш остаётся тем же самым.

Каждый хеш имеет тольк I<один> итератор для оператора C<each>. Вы не можете
надёжно итерировать по хешу с помощью C<each> более одного раза; если вы начнёте
новую итерацию, когда другая ещё не завершена, предыдущая преждевременно
закончится, а последующая начнётся с середины хеша. Во время таких итераций
остерегайтесь вызывать какие-либо функции, которые сами могут итерировать по
хешу посредством C<each>.

На практике такое случается редко, но если вам это нужно, сбросить итератор хеша
можно с помощью C<keys> или C<values> в пустом контексте:

=begin programlisting

    # сброс итератора хеша
    keys %addresses;

    while (my ($addressee, $address) = each %addresses)
    {
        ...
    }

=end programlisting

=head2 Срезы хешей

X<hashes; slicing>
X<slices; hash>

I<Срез хеша> E<mdash> это список ключей и значений хеша, индексированных в одной
операции. Так можно инициализировать несколько элементов хеша сразу:

=begin programlisting

    # %cats уже содержит элементы
    @cats{qw( Jack Brad Mars Grumpy )} = (1) x 4;

=end programlisting

Это эквивалентно следующей инициализации:

=begin programlisting

    my %cats = map { $_ => 1 }
               qw( Jack Brad Mars Grumpy );

=end programlisting

E<hellip>за исключением того, что инициализация среза хеша не I<заменяет>
существующее содержимое хеша.

X<C<@>; sigil>
X<sigils; C<@>>

Срезы хеша также позволяют вам получить несколько значений из хеша в одной
операции. Как и в случае срезов массива, сигил хеша изменяется для обозначения
списочного контекста. Использование фигурных скобок указывает на доступ по ключу
и делает хеш однозначным:

=begin programlisting

    my @buyer_addresses = @addresses{ @buyers };

=end programlisting

Срезы хешей облегчают слияние двух хешей:

=begin programlisting

    my %addresses        = ( ... );
    my %canada_addresses = ( ... );

    @addresses{ keys   %canada_addresses }
              = values %canada_addresses;

=end programlisting

Это эквивалентно ручному циклу по содержимому C<%canada_addresses>, но намного
короче.

Что если один и тот же ключ имеет место в обоих хешах? Подход со срезом хеша
всегда I<перезаписывает> существующие пары ключ/значение в C<%addresses>. Если
вам нужно другое поведение, больше подойдут циклы.

=head2 Пустой хеш

Пустой хеш не содержит ни ключей, ни значений. Он даёт ложное значение в булевом
контексте. Хеш, содержащий хотя бы одну пару ключ/значение, в булевом контексте
даёт истинное значение, даже если все ключи, или все значения, или и то и
другое, сами по себе в булевом контексте являются ложными значениями.

=begin programlisting

    use Test::More;

    my %empty;
    ok( ! %empty, 'empty hash should evaluate false' );

    my %false_key = ( 0 => 'true value' );
    ok( %false_key, 'hash containing false key
                     should evaluate to true' );

    my %false_value = ( 'true key' => 0 );
    ok( %false_value, 'hash containing false value
                       should evaluate to true' );

    done_testing();

=end programlisting

В скалярном контексте хеш возвращает строку, представляющую соотношение полных корзин
в хеше E<mdash> внутренние детали реализации хешей, которые вы смело можете
игнорировать.

В списочном контексте хеш возвращает список пар ключ/значение, подобный тому, что вы
получаете от оператора C<each>. Однако вы I<не можете> итерировать по этому
списку так же, как итерируете по списку, выдаваемому C<each>, иначе цикл никогда
не прервётся:

=begin programlisting

    # бесконечный цикл для непустых хешей
    while (my ($key, $value) = %hash)
    {
        ...
    }

=end programlisting

Вы I<можете> осуществлять цикл по ключам и значениям с помощью цикла C<for>, но
переменная-итератор будет получать ключ на одной итерации и его значение на
следующей, потому что Perl разгладит хеш в один список перемежающихся ключей и
значений.

=head2 Идиомы с хешами

X<hashes; finding uniques>

Поскольку каждый ключ в хеше встречается только один раз, присваивание того же
самого ключа хешу несколько раз сохраняет только самый последний ключ.
Используйте это для нахождения уникальных элементов списка:

=begin programlisting

    my %uniq;
    undef @uniq{ @items };
    my @uniques = keys %uniq;

=end programlisting

Использование C<undef> со срезом хеша устанавливает значения хеша в C<undef>.
Эта идиома E<mdash> самый дешёвый способ выполнить операции установки значения
с хешем.

X<hashes; counting items>

Хеши также полезны для подсчёта элементов, таких как IP-адреса в лог-файле:

=begin programlisting

    my %ip_addresses;

    while (my $line = <$logfile>)
    {
        my ($ip, $resource) = analyze_line( $line );
        $ip_addresses{$ip}++;
        ...
    }

=end programlisting

Начальное значение значений хеша E<mdash> C<undef>. Оператор постфиксного
инкремента (C<++>) воспринимает его как ноль. Модификация значения
инкрементирует существующее значения для этого ключа. Если значения для этого
ключа не существует, Perl создаёт значение (C<undef>) и немедленно
инкрементирует его до единицы, так как преобразование C<undef> в число даёт
значение 0.

X<hashes; caching>
X<orcish maneuver>

Эта стратегия обеспечивает полезный механизм кеширования для сохранения
результата дорогих операций с небольшим оверхедом:

=begin programlisting

    {
        my %user_cache;

        sub fetch_user
        {
            my $id = shift;
            $user_cache{$id} //= create_user($id);
            return $user_cache{$id};
        }
    }

=end programlisting

X<defined-or>
X<C<//>; infix operator>
X<operators; C<//>>
X<operators; defined-or>

Этот I<орочий манёвр>N<Or-cache, orcish, если вы любите игру слов.> возвращает
значение из хеша, если оно существует. В противном случае, он вычисляет,
кеширует и возвращает значение. Оператор определено-или-присвоить (C<//=>)
вычисляет свой левый операнд. Если этот операнд не определён, оператор
присваивает левому значению значение своего правого операнда. Другими словами,
если в хеше нет значения для заданного ключа, эта функция вызовет
C<create_user()> с этим ключом и обновит хеш.

Операторы определено-или и определено-или-присвоить были представлены в
Per 5.10. До 5.10 большая часть кода использовала оператор или-присвоить
(C<||=>) для этой цели. К сожалению, некоторые валидные значения дают ложное
значение в булевом контексте, так что вычисление I<определённости> значений
почти всегда более правильно. Этот ленивый орочий манёвр проверяет
определённость кешированного значения, не истинность.

X<hashes; named parameters>

Если ваша функция принимает несколько аргументов, используйте захватывающий хеш
(L<parameter_slurping>) для сбора пар ключ/значение в один хеш как именованных
аргументов функции:

=begin programlisting

    sub make_sundae
    {
        my %parameters = @_;
        ...
    }

    make_sundae( flavor  => 'Lemon Burst',
                 topping => 'cookie bits' );

=end programlisting

Этот подход позволяет вам устанавливать значения по умолчанию:

=begin programlisting

    sub make_sundae
    {
        my %parameters           = @_;
        B<$parameters{flavor}    //= 'Vanilla';>
        B<$parameters{topping}   //= 'fudge';>
        B<$parameters{sprinkles} //= 100;>
        ...
    }

=end programlisting

E<hellip>или включать их в инициализацию хеша, так как последующее присваивание
перезаписывает предыдущие:

=begin programlisting

    sub make_sundae
    {
        my %parameters =
        (
            B<< flavor    => 'Vanilla', >>
            B<< topping   => 'fudge', >>
            B<< sprinkles => 100, >>
            @_,
        );
        ...
    }

=end programlisting

=head2 Блокировка хешей

Z<locked_hashes>

X<hashes; locked>

Так как ключи хешей E<mdash> голые слова, они мало защищены от опечаток по
сравнению с защитой имён функций и переменных, предлагаемой прагмой C<strict>.
Редко используемый базовый модуль C<Hash::Util> предоставляет механизмы для
улучшения этой ситуации.

Чтобы не дать кому-либо случайно добавить ключ хеша, который вы не намеревались
(в случае опечатки или из ненадёжного пользовательского ввода), используйте
функцию C<lock_keys()> чтобы ограничить хеш его текущим набором ключей. Любая
попытка добавить новый ключ в хеш выбросит исключение. Эта слабая мера
безопасности годится только для предотвращения случайностей; кто угодно
может использовать функцию C<unlock_keys()> чтобы удалить эту защиту.

Аналогично вы можете заблокировать или разблокировать существующее значение для
заданного ключа хеша (C<lock_value()> и C<unlock_value()>) и сделать весь хеш
доступным только для чтения или лишить его этого свойства с помощью
C<lock_hash()> и C<unlock_hash()>.
