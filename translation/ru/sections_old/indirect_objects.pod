=encoding utf-8

=head1 Непрямые объекты

Z<indirect_objects>

В Perl 5 нет оператора C<new>; конструктором в Perl 5 является всё, что
возвращает объект. По соглашению, конструкторы E<mdash> методы классов,
называемые C<new()>, но вы можете выбрать всё, что захотите. Некоторые старые
руководства по объектам Perl 5 поощряют использование вызовов конструкторов в
стиле C++ и Java:

=begin programlisting

    my $q = B<new> CGI; # НЕ ИСПОЛЬЗОВАТЬ

=end programlisting

E<hellip>вместо очевидного вызова метода:

=begin programlisting

    my $q = CGI->new();

=end programlisting

Эти варианты синтаксиса дают одинаковое поведение, за исключением случаев, когда
это не так.

=head2 Непрямые вызовы с голыми словами

X<indirect object notation>
X<dative notation>

В непрямой объектной форме (более точно, в I<дательном> случае) первого примера
глагол (метод) предшествует существительному, к которому относится (объект).
Это нормально в разговорных языках, но в Perl 5 создаёт неоднозначности
парсинга.

Так как имя метода E<mdash> голое слово (L<barewords>), парсер должен
предсказать правильную интерпретацию кода с помощью использования нескольких
эвристик. Хотя эти эвристики хорошо протестированы и I<почти> всегда корректны,
их режимы сбоя сбивают с толку. Хуже того, они зависят от порядка компиляции
кода и модулей.

Трудность парсинга увеличивается, если конструктор принимает аргументы. Непрямой
стиль может выглядеть так:

=begin programlisting

    # НЕ ИСПОЛЬЗОВАТЬ
    my $obj = new Class( arg => $value );

=end programlisting

E<hellip>таким образом заставляя имя класса выглядеть как вызов функции. Perl 5
I<может> устранить неоднозначность во многих подобных случаях, но его эвристики
зависят от того, какие имена пакетов видит парсер, какие голые слова он уже
разрешил (и как он разрешил их) и от I<имён> функций, уже объявленных в текущем
пакете.

Представьте противоречие в случае прототипированной функции (L<prototypes>)
с именем, которому случилось каким-то образом вступить в конфликт с именем
класса или метода, вызываемого непрямо. Это случается редко, но так неприятно
для отладки, что стоит того, чтобы избегать непрямых вызовов.

=head2 Скалярные ограничения непрямой нотации

Другая опасность такого синтаксиса в том, что парсер ожидает объект как одно
скалярное выражение. Вывод в дескриптор файла, сохранённый в агрегатной
переменной, I<выглядит> очевидным, но таковым не является:

=begin programlisting

    # НЕ РАБОТАЕТ КАК НАПИСАНО
    say $config->{output} 'Fun diagnostic message!';

=end programlisting

Perl попытается вызвать C<say> на объекте C<$config>.

X<builtins; C<print>>
X<builtins; C<close>>
X<builtins; C<say>>

C<print>, C<close> и C<say> E<mdash> все встроенные функции, оперирующие с
дескрипторами файлов E<mdash> оперируют в непрямой манере. Это было нормально,
когда дескрипторы файлов были глобальными переменными пакета, но лексические
дескрипторы файлов (L<lexical_filehandles>) делают очевидными проблемы непрямого
объектного синтаксиса. Чтобы устранить это, избавьтесь от неоднозначности
подвыражения, выдающего подразумеваемый инвокант:

=begin programlisting

    say B<{>$config->{output}B<}> 'Fun diagnostic message!';

=end programlisting

=head2 Альтернативы непрямой нотации

Нотация прямого вызова не страдает этой проблемой неоднозначности. Чтобы
сконструировать объект, вызовите метод-конструктор напрямую на имени класса:

=begin programlisting

    my $q   = CGI->new();
    my $obj = Class->new( arg => $value );

=end programlisting

Этот синтаксис I<всё ещё> имеет проблему голого слова, в том смысле, что если
у вас есть функция с именем C<CGI>, Perl будет интерпретировать голое имя класса
как вызов функции:

=begin programlisting

    sub CGI;

    # вы написали CGI->new(), но Perl увидел
    my $q = CGI()->new();

=end programlisting

Хотя это случается редко, вы можете устранить неоднозначность имён классов,
добавив разделитель пакетов (C<::>) или явно пометив имена классов как строковые
литералы:

=begin programlisting

    # разделитель пакетов
    my $q = CGI::->new();

    # не имеющий неоднозначности строковый литерал
    my $q = 'CGI'->new();

=end programlisting

Однако почти никто этого не делает.

X<C<IO::File>>

Для ограниченного случая операций с дескрипторами файлов дательное использование
настолько общепринято, что вы можете использовать подход непрямого вызова, если
окружите свой подразумеваемый инвокант фигурными скобками. Если вы используете
Perl 5.14 (или если вы загрузили C<IO::File> или C<IO::Handle>), вы можете
использовать методы на лексических дескрипторах файловN<Хотя почти никто не
делает этого для C<print> и C<say>.>.

X<CPAN; C<Perl::Critic>>
X<CPAN; C<Perl::Critic::Policy::Dynamic::NoIndirect>>
X<CPAN; C<indirect>>

CPAN-модуль C<Perl::Critic::Policy::Dynamic::NoIndirect> (плагин для
C<Perl::Critic>) может обнаружить непрямые вызовы во время проверки кода.
CPAN-модуль C<indirect> может обнаружить и запретить их использование в
запущенных программах:

=begin programlisting

    # выдать предупреждение при использовании непрямых вызовов
    no indirect;

    # выбросить исключение при их использовании
    no indirect ':fatal';

=end programlisting
