=encoding utf-8

=head1 Ссылки

Z<references>

Perl обычно делает то, чего вы ожидаете, даже если это требует проницательности.
Посмотрите, что происходит, когда вы передаёте значения в функции:

=begin programlisting

    sub reverse_greeting
    {
        my $name = reverse shift;
        return "Hello, $name!";
    }

    my $name = 'Chuck';
    say reverse_greeting( $name );
    say $name;

=end programlisting

Снаружи функции C<$name> содержит значение C<Chuck>, несмотря на то, что
значение, переданное в функцию, переворачивается в C<kcuhC>. Вероятно, этого вы
и ожидаете. Значение C<$name> снаружи функции отдельно от значения C<$name> внутри
функции. Изменение одного не оказывает эффекта на другое.

Рассмотрим альтернативу. Если бы вам было необходимо делать копии каждого
значения прежде чем что-либо могло бы изменить их независимо от вас, вам пришлось
бы писать большое количество дополнительного защитного кода.

Однако иногда удобно модифицировать значения прямо на месте. Если вы хотите
передать хеш, полный данных, в функцию, для изменения его, создание и возврат
нового хеша для каждого изменения может быть хлопотным (уж не говоря о том, что
неэффективным).

X<references>

Perl 5 предоставляет механизм, позволяющий ссылаться на значение, не делая его
копии. Любые изменения, сделанные с этой I<ссылкой>, сразу же обновят значение, так
что I<все> ссылки на это значение смогут получить новое значение. Ссылка в
Perl 5 E<mdash> скалярный тип данных первого класса, который ссылается на другой
тип данных первого класса.

=head2 Ссылки на скаляры

Z<scalar_references>

X<operators; C<\>>
X<references; C<\> operator>

X<references; scalar>
X<scalars; references>

Оператор взятия ссылки E<mdash> обратный слеш (C<\>). В скалярном контексте он
создаёт одиночную ссылку, ссылающуюся на другое значение. В списочном
контексте он создаёт список ссылок. Чтобы взять ссылку от C<$name>:

=begin programlisting

    my $name     = 'Larry';
    my $name_ref = B<\>$name;

=end programlisting

X<dereferencing>
X<references; dereferencing>

Вы должны I<разыменовать> ссылку, чтобы получить значение, на которое она
ссылается. Разыменовывание требует добавления дополнительного сигила для каждого
уровня разыменовывания:

=begin programlisting

    sub reverse_in_place
    {
        my $name_ref = shift;
        B<$$name_ref>   = reverse B<$$name_ref>;
    }

    my $name = 'Blabby';
    reverse_in_place( B<\>$name );
    say $name;

=end programlisting

Двойной скалярный сигил (C<$$>) разыменовывает ссылку на скаляр.

X<references; aliases>
X<aliases>

Находящиеся в C<@_> параметры ведут себя как I<псевдонимы> переменных
вызывающего кодаN<Вспомните, что цикл C<for> имеет аналогичное поведение в
плане создания псевдонимов.>, так что вы можете изменять их на месте:

=begin programlisting

    sub reverse_value_in_place
    {
        $_[0] = reverse $_[0];
    }

    my $name = 'allizocohC';
    reverse_value_in_place( $name );
    say $name;

=end programlisting

В большинстве случаев вы не захотите модифицировать значения таким способом
E<mdash> вызывающий код, например, редко этого ожидает. Присваивание параметров
лексическим переменным внутри ваших функций избавляет от такого поведения.

=begin tip Экономия памяти с помощью ссылок

Модификация значения на месте или возврат ссылки на скаляр может сэкономить
память. Так как Perl копирует значения при присваивании, у вас может оказаться
несколько копий большой строки. В случае передачи ссылок Perl будет копировать
только ссылки E<mdash> гораздо более дешёвая операция.

=end tip

Сложные ссылки могут потребовать использования блока в фигурных скобках для
разрешения неоднозначности частей выражения. Вы можете всегда использовать такой
синтаксис, хотя иногда он проясняет, а иногда затеняет:

=begin programlisting

    sub reverse_in_place
    {
        my $name_ref   = shift;
        B<${ $name_ref }> = reverse B<${ $name_ref }>;
    }

=end programlisting

Если вы забудете разыменовать ссылку на скаляр, Perl, вероятно, выполнит
приведение типа ссылки. Строковое значение будет иметь вид C<SCALAR(0x93339e8)>,
а числовое будет содержать часть C<0x93339e8>. В этом значении зашифрован тип
ссылки (в данном случае C<SCALAR>) и положение ссылки в памяти.

=begin tip Ссылки E<mdash> не указатели

Perl не предоставляет доступа к ячейкам памяти. Адрес ссылки E<mdash> это
значение, используемое как идентификатор. В отличие от указателей в таких языках
как C, вы не можете модифицировать адрес или обращаться с ним как с адресом в
памяти. Эти адреса лишь I<в большинстве случаев> уникальны, так как Perl может
повторно использовать ячейки после освобождения неиспользуемой памяти.

=end tip

=head2 Ссылки на массивы

Z<array_references>

X<arrays; references>
X<references; arrays>

I<Ссылки на массивы> полезны в нескольких ситуациях:

=over 4

=item * Для передачи и возвращения массивов из функций без разглаживания

=item * Для создания многомерных структур данных

=item * Чтобы избежать ненужного копирования массива

=item * Для сохранения анонимных структур данных

=back

Используйте оператор взятия ссылки для создания ссылки на объявленный массив:

=begin programlisting

    my @cards     = qw( K Q J 10 9 8 7 6 5 4 3 2 A );
    my $cards_ref = B<\>@cards;

=end programlisting

Любые изменения, сделанные через C<$cards_ref>, будут изменять и C<@cards>, и
наоборот. Вы можете получить доступ ко всему массиву целиком с помощью сигила
C<@>, например, чтобы разгладить массив или сосчитать его элементы:

=begin programlisting

    my $card_count = B<@$cards_ref>;
    my @card_copy  = B<@$cards_ref>;

=end programlisting

X<<< C<< -E<gt> >>; dereferencing arrow >>>
X<<< operators; C<< -E<gt> >> >>>

Доступ к отдельным элементам осуществляется с помощью разыменовывающей стрелки
(C<< -> >>):

=begin programlisting

    my $first_card = B<< $cards_ref->[0]  >>;
    my $last_card  = B<< $cards_ref->[-1] >>;

=end programlisting

Стрелка необходима, чтобы различать скаляр C<$cards_ref> и массив C<@cards_ref>.
Обратите внимание на использование скалярного сигила (L<sigils>) для доступа к
единственному элементу.

=begin tip Дублирующиеся сигилы

Альтернативный синтаксис добавляет ещё один скалярный сигил к ссылке на массив.
Короче, хотя и уродливее, написать C<< my $first_card = B<$$cards_ref[0]>; >>.

=end tip

Используйте разыменовывающий синтаксис с фигурными скобками для получения среза
(L<array_slices>) по ссылке на массив:

=begin programlisting

    my @high_cards = B<@{ $cards_ref }>[0 .. 2, -1];

=end programlisting

Вы I<можете> опустить фигурные скобки, но их группировка часто улучшает
читабельность.

X<references; anonymous arrays>
X<arrays; anonymous>

Для создания анонимного массива E<mdash> без использования объявленного массива
E<mdash> окружите список значений квадратными скобками:

=begin programlisting

    my $suits_ref = [qw( Monkeys Robots Dinos Cheese )];

=end programlisting

Эта ссылка на массив ведёт себя так же, как ссылки на именованные массивы, за
исключением того, что скобки анонимного массива I<всегда> создают новую ссылку.
Ссылка, взятая на именованный массив, всегда ссылается на I<тот же самый> массив
с учётом области видимости. Например:

=begin programlisting

    my @meals      = qw( soup sandwiches pizza );
    my $sunday_ref = \@meals;
    my $monday_ref = \@meals;

    push @meals, 'ice cream sundae';

=end programlisting

E<hellip>и C<$sunday_ref>, и C<$monday_ref> теперь содержат десерт, тогда как
в следующем случае:

=begin programlisting

    my @meals      = qw( soup sandwiches pizza );
    my $sunday_ref = [ @meals ];
    my $monday_ref = [ @meals ];

    push @meals, 'berry pie';

=end programlisting

E<hellip>ни C<$sunday_ref>, ни C<$monday_ref> не содержат десерт. В квадратных
скобках, использованных для создания анонимного массива, списочный контекст
разглаживает массив C<@meals> в список, не связанный с C<@meals>.

=head2 Ссылки на хеши

Z<hash_references>

X<hashes; references>
X<references; hashes>

Используйте оператор взятия ссылки на именованном хеше для создания I<ссылки на
хеш>:

=begin programlisting

    my %colors = (
        black  => 'negro',
        blue   => 'azul',
        gold   => 'dorado',
        red    => 'rojo',
        yellow => 'amarillo',
        purple => 'morado',
    );

    my $colors_ref = B<\%>colors;

=end programlisting

Доступ к ключам или значениям хеша можно получить, предварив ссылку сигилом хеша
(C<%>):

=begin programlisting

    my @english_colors = keys   B<%$colors_ref>;
    my @spanish_colors = values B<%$colors_ref>;

=end programlisting

Доступ к отдельным значениям хеша (для сохранения, удаления, проверки
существования или получения) осуществляется с использованием разыменовывающей
стрелки или двойных сигилов:

=begin programlisting

    sub translate_to_spanish
    {
        my $color = shift;
        return B<< $colors_ref->{$color} >>;
        # или return B<< $$colors_ref{$color} >>;
    }

=end programlisting

Используйте сигил массива (C<@>) и устраняющие неоднозначность скобки для
получения среза по ссылке на хеш:

=begin programlisting

    my @colors  = qw( red blue green );
    my @colores = B<@{ $colors_ref }{@colors}>;

=end programlisting

Создание анонимного хеша с помощью фигурных скобок:

=begin programlisting

    my $food_ref = B<{>
        'birthday cake' => 'la torta de cumpleaE<ntilde>os',
        candy           => 'dulces',
        cupcake         => 'bizcochito',
        'ice cream'     => 'helado',
    B<}>;

=end programlisting

Как и анонимные массивы, анонимные хеши создают новый анонимный хеш при каждом
выполнении.

=begin tip Следите за скобками!

Распространённая ошибка новичков E<mdash> присваивание анонимного хеша
стандартному хешу E<mdash> выдаёт предупреждение о нечётном количестве элементов
в хеше. Используйте круглые скобки для именованного хеша и фигурные скобки для
анонимного хеша.

=end tip

=head2 Автоматическое разыменование

Z<automatic_dereferencing>

X<builtins; C<push>>

Начиная с Perl 5.14, Perl может автоматически разыменовать некоторые ссылки от
вашего имени. Имея ссылку на массив в C<$arrayref>, вы можете написать:

=begin programlisting

    push $arrayref, qw( list of values );

=end programlisting

Имея выражение, возвращающее ссылку на массив, вы можете сделать то же самое:

=begin programlisting

    push $houses{$location}[$closets], \@new_shoes;

=end programlisting

X<builtins; C<push>>
X<builtins; C<pop>>
X<builtins; C<shift>>
X<builtins; C<unshift>>
X<builtins; C<splice>>
X<builtins; C<keys>>
X<builtins; C<values>>
X<builtins; C<each>>

То же относится и к операторам работы с массивами C<pop>, C<shift>, C<unshift>,
C<splice>, C<keys>, C<values>, и C<each>, а также к операторам работы с хешами
C<keys>, C<values> и C<each>.

Если предоставленная ссылка имеет несоответствующий тип E<mdash> если она не
разыменовывается должным образом E<mdash> Perl выбросит исключение. Хотя это
выглядит более опасным, чем явное разыменовывание ссылок напрямую, фактически,
это то же самое поведение:

=begin programlisting

    my $ref = sub { ... };

    # выбросит исключение
    push  $ref, qw( list of values );

    # тоже выбросит исключение
    push @$ref, qw( list of values );

=end programlisting

=head2 Ссылки на функции

Z<function_references>

X<functions; references>
X<references; functions>
X<functions; first-class>

Perl 5 поддерживает I<функции первого класса>, поскольку функция E<mdash> такой
же тип данных, как массив или хеш. Это наиболее очевидно в случае I<ссылок на
функции> и даёт много продвинутых возможностей (L<closures>). Ссылка на функцию
создаётся посредством использования оператора взятия ссылки на имени функции:

=begin programlisting

    sub bake_cake { say 'Baking a wonderful cake!' };

    my $cake_ref = B<\&>bake_cake;

=end programlisting

X<functions; sigil>
X<sigils; C<&>>
X<C<&>; sigil>

Без I<сигила функции> (C<&>), вы получите ссылку на возвращаемое значение или
значения функции.

Анонимная функция создаётся с помощью голого ключевого слова C<sub>:

=begin programlisting

    my $pie_ref = B<sub { say 'Making a delicious pie!' }>;

=end programlisting

X<builtins; C<sub>>

Использование встроенной директивы С<sub> I<без> имени компилирует функцию, как
обычно, но не помещает её в текущее пространство имён. Единственный способ
получить доступ к этой функции E<mdash> по ссылке, возвращённой C<sub>. Вызыв
функции по ссылке осуществляется с помощью разыменовывающей стрелки:

=begin programlisting

    $cake_ref->();
    $pie_ref->();

=end programlisting

=begin tip Вызовы функций в Perl 4

Альтернативный синтаксис вызова для ссылок на функции использует сигил функции
(C<&>) вместо разыменовывающей стрелки. Избегайте этого синтаксиса; он имеет
специфические последствия для парсинга и передачи аргументов.

=end tip

Воспринимайте пустые круглые скобки как обозначение операции разыменовывающего
вызова, так же как квадратные скобки указывают на поиск по индексу, а фигурные
скобки служат для поиска в хеше. Передавайте аргументы в функцию с помощью
круглых скобок:

=begin programlisting

    $bake_something_ref->( 'cupcakes' );

=end programlisting

Также вы можете использовать ссылки на функции как методы объектов (L<moose>).
Это удобно, когда вы уже нашли метод (L<reflection>):

=begin programlisting

    my $clean = $robot_maid->can( 'cleanup' );
    $robot_maid->$clean( $kitchen );

=end programlisting

=head2 Ссылки на дескрипторы файлов

Z<lexical_filehandles>

X<filehandles; references>
X<references; filehandles>
X<C<IO::File>>
X<C<IO::Handle>>

Когда вы используете C<open> (и C<opendir>) в форме с лексическими дескрипторами
файлов, вы имеете дело со ссылками на дескрипторы файлов. Внутренне эти
дескрипторы файлов E<mdash> объекты C<IO::File>. Вы можете напрямую вызывать их
методы. Начиная с Perl 5.14 это можно делать так:

=begin programlisting

    open my $out_fh, '>', 'output_file.txt';
    $out_fh->say( 'Have some text!' );

=end programlisting

В 5.12 вы должны написать C<use IO::File;> чтобы включить эту возможность, а в
Perl 5.10 и раньше E<mdash> C<use IO::Handle;>. Даже более старый код может
получать ссылки на тайпглобы:

=begin programlisting

    local *FH;
    open FH, "> $file" or die "Can't write '$file': $!";
    my $fh = B<\*FH>;

=end programlisting

Эта идиома предшествует лексическим дескрипторам файлов (представленным в
Perl 5.6.0 в марте 2000 года). Вы всё ещё можете использовать оператор взятия
ссылки на тайпглобах для получения ссылок на дескрипторы файлов, глобальные для
пакета, такие как C<STDIN>, C<STDOUT>, C<STDERR> или C<DATA> E<mdash> но это всё
в любом случае глобальные имена.

Использование лексических дескрипторов файлов по возможности предпочтительно.
С преимуществами явного задания области видимости, лексические дескрипторы
файлов позволяют вам управлять их сроком жизни благодаря возможностям Perl 5 по
управлению памятью.

=head2 Счётчики ссылок

Z<reference_counts>
X<references; reference counting>

Perl 5 использует технику управления памятью, известную как I<подсчёт ссылок>.
Каждое значение в Perl имеет присоединённый к нему счётчик. Perl увеличивает
этот счётчик при каждом взятии ссылки на это значение, явном или неявном. Perl
уменьшает этот счётчик каждый раз, когда ссылка исчезает. Когда счётчик
достигает ноля, Perl может безопасно отправить это значение на переработку.

X<lexicals; lifecycle>

Как Perl узнаёт, когда можно безопасно освободить память, занимаемую переменной?
Как Perl узнаёт, когда безопасно закрыть дескриптор файла, открытый во
внутренней области видимости?

=begin programlisting

    say 'file not open';

    {
        open my $fh, '>', 'inner_scope.txt';
        $fh->say( 'file open here' );
    }

    say 'file closed here';

=end programlisting

Во внутреннем блоке в этом примере только один дескриптор C<$fh>. (Несколько
строк в исходном коде упоминают его, но ссылается на него только одна
переменная: C<$fh>.) C<$fh> существует только в области видимости этого блока.
Её значение никогда не покидает блок. Когда выполнение достигает конца блока,
Perl перерабатывает переменную C<$fh> и уменьшает счётчик ссылок содержащегося
в ней дескриптора файла. Счётчик дескриптора достигает ноля, так что Perl
перерабатывает его для освобождения памяти и неявно вызывает C<close()>.

Вам не обязательно понимать детали того, как всё это работает. Вам нужно
понимать только то, что ваши действия по взятию ссылок и их передаче влияют на
то, как Perl управляет памятью (см. L<circular_references>).

=head2 Ссылки и функции

При использовании ссылок как аргументов функции внимательно документируйте ваши
намерения. Изменение значений ссылки изнутри функции может стать неожиданностью
для вызывающего кода, который не ожидает, что кто-то ещё будет модифицировать
его данные. Для изменения содержимого ссылки, не воздействуюя на саму ссылку,
скопируйте её значение в новую переменную:

=begin programlisting

    my @new_array = @{ $array_ref };
    my %new_hash  = %{ $hash_ref  };

=end programlisting

X<C<Storable>>
X<C<dclone()>>

Это необходимо лишь в немногих случаях, но явное клонирование помогает избежать
неприятных сюрпризов для вызывающего кода. Если вы используете вложенные
структуры данных или другие сложные ссылки, рассмотрите использование
базового модуля C<Storable> и его функции C<dclone> (I<deel cloning>,
I<глубокое клонирование>).
