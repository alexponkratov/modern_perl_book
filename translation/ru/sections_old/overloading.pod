=encoding utf-8

=head1 Перегрузка

Z<overloading>
X<overloading>

Perl 5 не является глубоко объектно-ориентированным языком. Его внутренние типы
данных (скаляры, массивы и хеши) не являются объектами с перегружаемыми
методами, но вы I<можете> контролировать поведение своих собственных классов и
объектов, особенно когда они подвергаются приведению типов или контекстному
вычислению. Это I<перегрузка>.

Перегрузка может быть неочевидной, но мощной. Интересный пример E<mdash>
перегрузка того, как объект ведёт себя в булевом контексте, особенно если вы
используете что-нибудь вроде шаблона ноль-объекта
(U<http://www.c2.com/cgi/wiki?NullObject>). В булевом контексте объект будет
восприниматься как истинное значение, если вы не перегрузите преобразование в
булево значение.

Вы можете перегрузить поведение объекта почти для любой операции или приведения
типа: преобразование в строку, преобразование в число, преобразование в булево
значение, итерации, вызов, обращение как к массиву, обращение как к хешу,
арифметические операции, операции сравнения, умное сопоставление, побитовые
операции и даже присваивание. Преобразование в строку, в число и в булево
значение наиболее важны и наиболее распространены.

=head2 Перегрузка распространённых операций

X<overloading; boolean>
X<overloading; numeric>
X<overloading; string>
X<C<overload> pragma>
X<pragmas; C<overload>>

Прагма C<overload> позволяет вам ассоциировать функцию с операцией, которую вы
можете перегрузить, передав пары аргументов, где ключ обозначает тип перегрузки,
а значение E<mdash> ссылка на функцию, которая должна вызываться для этой
операции. Класс C<Null>, перегружающий булево вычисление так, что он всегда будет
восприниматься как ложное значение, может выглядеть так:

=begin programlisting

    package Null
    {
        use overload 'bool' => sub { 0 };

        ...
    }

=end programlisting

Можно легко добавить преобразование в строку:

=begin programlisting

    package Null
    {
        use overload
            'bool' => sub { 0 },
            B<< '""'   => sub { '(null)' }; >>
    }

=end programlisting

Переопределение преобразования в число более сложно, потому что арифметические
операторы имеют тенденцию быть бинарными (L<arity>). Если есть два оператора,
оба с перегруженными методами для сложения, какой будет приоритетнее? Ответ
должен быть последовательным, простым для объяснения и понятным людям, которые
не читали исходный код реализации.

C<perldoc overload> пытается объяснить это в разделах I<Calling Conventions for
Binary Operations> и I<MAGIC AUTOGENERATION>, но наиболее простое решение
E<mdash> перегрузить преобразование в число (имеющее ключ C<'0+'>) и указать
C<overload> использовать предоставленные перегрузки как запасной вариант
(fallback) где возможно:

=begin programlisting

    package Null
    {
        use overload
            'bool'   => sub { 0 },
            '""'     => sub { '(null)' },
            B<< '0+'     => sub { 0 }, >>
            B<< fallback => 1; >>
    }

=end programlisting

Установка C<fallback> в истинное значение позволяет Perl использовать любые
другие определённые перегрузки для выполнения запрошенной операции, если
возможно. Если это невозможно, Perl будет действовать так, как если бы не было
никаких перегрузок. Это часто именно то, чего вы хотите.

Без C<fallback> Perl будет использовать только конкретные перегрузки, которые
вы предоставили. Если кто-нибудь попытается выполнить операцию, которую вы не
перегрузили, Perl выбросит исключение.

=head2 Перегрузка и наследование

X<overloading; inheritance>

Подклассы наследуют перегрузки от своих предков. Они могут переопределить это
поведение одним из двух способов. Если родительский класс использует перегрузку
как показано, с напрямую предоставленными ссылками на функции, класс-потомок
I<должен> переопределить перегруженное поведение родителя с помощью прямого
использования C<overload>.

Родительские классы могут позволить своим потомкам большую гибкость, указывая
I<имя> метода для вызова в качестве реализации перегрузки, вместо хардкода
ссылки на функцию:

=begin programlisting

    package Null
    {
        use overload
            'bool'   => 'get_bool',
            '""'     => 'get_string',
            '0+'     => 'get_num',
            fallback => 1;
    }

=end programlisting

В этом случае любые дочерние классы могут выполнять эти перегруженные операции
иначе, переопределив методы с соответствующими именами.

=head2 Использование перегрузки

X<CPAN; C<IO::All>>

Перегрузка может выглядеть заманчивым инструментом для использования для
генерации символьных сокращений для новых операций, но это редко происходит в
Perl 5 по весомым причинам. CPAN-дистрибутив C<IO::All> доводит эту идею до
предела в производстве умных идей для краткого и компонуемого кода. Однако на
каждый блестящий API, доведённый до совершенства путём соответствующего
использования перегрузки, дюжина других устраивают бардак. Иногда лучший код
избегает умности в пользу простоты.

Переопределение сложения, умножения и даже конкатенации в классе C<Matrix> имеет
смысл только из-за того, что распространена существующая нотация для этих
операций. Новая предметная область, не имеющая такой установившейся нотации
E<mdash> плохой кандидат для перегрузки, как и предметная область, в которой вам
приходится изощряться, чтобы поставить существующие операторы Perl в соответствие
с другой нотацией.

I<Perl Best Practices> Демьена Конвея (Damian Conway) предлагают другое
использование перегрузки: для предотвращения случайного неправильного
использования объектов. Например, перегрузка преобразования в число таким
образом, чтобы она делала C<croak()>, для объектов, не имеющих разумного
представления в виде одного числа, может помочь вам найти и исправить реальные
ошибки.
