=encoding utf-8

=head1 Контекст

Z<context_philosophy>

X<context>

В разговорных языка значение слова или фразы может зависеть от того, как вы их
используете; локальный I<контекст> помогает прояснить намерение. Например,
несоответствующее употребление множественного числа во фразе E<laquo>Please give
me one hamburgers!E<raquo>N<множественное число существительного не
соответствует количеству.> звучит неправильно, так же как неправильный пол в
E<laquo>la gatoE<raquo>N<Артикль женского рода, тогда как существительное
E<mdash> мужского.> заставляет носителей языка посмеиваться. Примите также во
внимание местоимение E<laquo>youE<raquo> или существительное
E<laquo>sheepE<raquo>, которое может единственным или множественным числом в
зависимости от контекста.

Контекст в Perl сходен. Он определяет как количесто, так и вид используемых
данных. Perl охотно попытается предоставить именно то, чего вы просите E<mdash>
при условии, если вы это делаете, выбирая соответствующий контекст.

Некоторые операции в Perl ведут себя по-разному в случаях, когда вы хотите получить ноль,
один или несколько результатов. Конкретная конструкция в Perl в случае, если
вы напишете E<laquo>Сделай это, но результаты меня не волнуютE<raquo>, может
делать нечто совершенно другое по сравнению с E<laquo>Сделай это, и я ожидаю
получить несколько результатовE<raquo>. Другие операции позволяют вам
определённо указать, предполагаете ли вы работать с числовыми данными,
текстовыми данными, или данными, содержащими E<laquo>истинуE<raquo> или
E<laquo>ложьE<raquo>.

Контекст может быть коварным если вы пытаетесь писать или читать код на Perl
как серию единичных выражений в отрыве от их окружения. Вы можете обнаружить
себя хлопающим по лбу после долгой сессии отладки, когда выясните, что ваши
предположения относительно контекста были неверны. Если же напротив вы осознаёте
контекст, ваш код будет более правильным E<mdash> а также более чистым, гибким и
лаконичным.

=head2 Пустой, скалярный и списочный контекст

Z<amount_context>

X<context; amount>
X<amount context>

I<Контекст количества> определяет, I<сколько> элементов вы ожидаете получить
от операции. Близкая параллель E<mdash> согласование числа между субъектом и
глаголом в английском языке. Даже не зная формального определения этого
лингвистического принципа, вы, вероятно, поймёте ошибку в предложении
E<laquo>Perl are a fun languageE<raquo>. В Perl количество элементов, которое вы
запросите, определяет, сколько вы получите.

X<void context>
X<context; void>

Предположим, у вас есть функция (L<functions>) под названием C<find_chores()>,
которая сортирует ваш список домашних дел по приоритету задач. Способ, которым
вы вызовете эту функцию, определяет, что она будет делать. У вас можете не быть
времени что либо делать, в этом случае вызов функции E<mdash> это просто попытка
выглядеть работящим. У вас может быть достаточно времени для выполнения одной
задачи, или, может быть, у вас взрыв энергии в свободный выходной, и вы хотите
выполнить как можно больше.

Если вы просто вызовете функция и никак не используете возвращаемое ей значение,
вы вызвали функцию в I<пустом контексте>:

=begin programlisting

    find_chores();

=end programlisting

X<context; scalar>
X<scalar context>

Присвоение возвращаемого функцией значения единственному элементу (L<scalars>)
вычисляет функцию в I<скалярном контексте>:

=begin programlisting

    my $single_result = find_chores();

=end programlisting

X<list context>
X<context; list>

Присвоение результатов вызова функции массиву (L<arrays>) или списку, или
использование её в списке, вычисляет функцию в I<списочном контексте>:

=begin programlisting

    my @all_results             = find_chores();
    my ($single_element, @rest) = find_chores();
    process_list_of_results( find_chores() );

=end programlisting

Скобки во второй строке предыдущего примера группируют объявление двух
переменных (L<lexical_scope>), чтобы присвоение вело себя так, как вы
ожидаете. Если переменная C<@rest> не используется, вы можете написать и так:

=begin programlisting

    my B<(>$single_elementB<)>   = find_chores();

=end programlisting

E<hellip>в этом случае скобки поясняют парсеру Perl 5, что вы подразумеваете
списочный контекст для присваивания, несмотря на то, что присваиваете только
одному элементу списка. Это неочевидно, но теперь, когда вы знаете об этом,
различие контекста количества между этими двумя выражениями должно быть ясно:

=begin programlisting

    my $scalar_context = find_chores();
    my B<(>$list_contextB<)> = find_chores();

=end programlisting

Вычисление функции или выражения E<mdash> исключая присваивание E<mdash> в
списочном контексте может вызвать путаницу. Списки распространяют списочный
контекст на выражения, которые они содержат. Оба этих вызова C<find_chores()>
происходят в списочном контексте:

=begin programlisting

    process_list_of_results( find_chores() );

    my %results =
    (
        cheap_operation     => $cheap_results,
        expensive_operation => find_chores(), # УПС!
    );

=end programlisting

X<builtins; C<scalar>>

Последний пример часто удивляет начинающих программистов, так как инициализация
хеша (L<hashes>) списком значений налагает списочный контекст на C<find_chores>.
Используйте оператор C<scalar> для наложения скалярного контекста:

=begin programlisting

    my %results =
    (
        cheap_operation     => $cheap_results,
        expensive_operation => B<scalar> find_chores(),
    );

=end programlisting

Почему контекст важен? Зависящая от контекста функция может проверить контекст,
в котором она вызывается, и определить, как много работы она должна сделать. В
пустом контексте функция C<find_chores()> может законно ничего не делать. В
скалярном контексте она может найти только самую важную задачу. В списочном
контексте она должна отсортировать и вернуть весь список.

=head2 Числовой, строковый и булев контекст

Z<value_contexts>

X<value context>
X<context; value>

Другой вид контекста в Perl E<mdash> I<контекст значения> E<mdash> определяет, как Perl
интерпретирует кусок данных. Вы, вероятно, уже заметили, что Perl проявляет гибкость
в определении того, имеете вы число или строку, и преобразовании их в тот вид,
в который вы хотите. В обмен на отсутствие обязательств объявлять (или хотя бы
следить) какой именно I<тип> данных содержит переменная или выдаёт функция,
контекст типа в Perl предоставляет подсказки, которые говорят компилятору, как
обращаться с данными.

X<builtins; C<eq>>

Perl приводит значения в конкретный надлежащий тип (L<coercion>), в
зависимости от используемого вами оператора. Например, оператор C<eq>
проверяет, что строки содержат одну и ту же информацию I<как строки>:

=begin programlisting

    say "Catastrophic crypto fail!" if $alice eq $bob;

=end programlisting

Возможно, у вас был ставящий в тупик опыт, когда вы I<знаете>, что строки
различаются, но сравнение всё равно показывает, что они одинаковые:

=begin programlisting

    my $alice = 'alice';
    say "Catastrophic crypto fail!" if $alice == 'Bob';

=end programlisting

X<string context>
X<numeric context>
X<context; string>
X<context; numeric>

X<builtins; C<==>>

Оператор C<eq> обращается со своими операндами как со строками, принудительно
налагая на них I<строковый контекст>. Оператор C<==> налагает I<числовой
контекст>. В числовом контексте обе строки возвращают C<0>
(L<numeric_coercion>). Убедитесь, что используете соответствующий оператор для
того типа контекста, который вам требуется.

X<boolean context>
X<context; boolean>

I<Булев контекст> имеет место, когды вы используете значение в условном
выражении. В предыдущем примере C<if> вычисляет результат операторов C<eq> и
C<==> в булевом контексте.

X<context; explicit>

В редких случаях вам, возможно, понадобится принудительно задать определённый контекст в случае, когда
не существует оператора подходящего типа. Чтобы принудительно задать числовой
контекст, прибавьте к переменной ноль. Чтобы принудительно задать строковый
контекст, конкатенируйте переменную с пустой строкой. Чтобы принудительно задать
булев контекст, используйте удвоенный оператор отрицания:

=begin programlisting

    my $numeric_x =  0 + $x;  # принудительно задаёт числовой  контекст
    my $stringy_x = '' . $x;  # принудительно задаёт строковый контекст
    my $boolean_x =    !!$x;  # принудительно задаёт булев     контекст

=end programlisting

Контекст типа проще распознать, чем контекст количества. Как только вы узнаете,
какой оператор предоставляет какой контекст (L<operator_types>), вы редко будете
ошибаться.
