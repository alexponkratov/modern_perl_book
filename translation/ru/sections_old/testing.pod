=encoding utf-8

=head1 Тестирование

Z<testing>

X<testing>

I<Тестирование> E<mdash> это процесс написания и запуска маленьких кусочков кода,
помогающих удостовериться, что ваше программное обеспечение ведёт себя так, как
задумано. Эффективное тестирование автоматизирует процесс, который вы уже
выполняли бесчисленное количество раз: написать какое-то количество кода,
запустить его, и убедиться, что он работает. Эта I<автоматизация> чрезвычайно
важна. Вместо того, чтобы доверять людям в том, что они буду идеально выполнять
повторяющиеся ручные проверки, позвольте делать это компьютеру.

Perl 5 предоставляет отличные инструменты, помогающие вам писать правильные
тесты.

=head2 Test::More

X<C<Test::More>>
X<C<ok()>>
X<testing; C<ok()>>

Тестирование в Perl начинается с базового модуля C<Test::More> и его функции
C<ok()>. C<ok()> принимает два параметра, булево значение и строку, описывающую
назначение теста:

=begin programlisting

    ok(   1, 'the number one should be true'         );
    ok(   0, '... and zero should not'               );
    ok(  '', 'the empty string should be false'      );
    ok( '!', '... and a non-empty string should not' );

    done_testing();

=end programlisting

X<testing; assertion>

Любое условие в вашей программе, которое вы можете протестировать, так или иначе
может стать двоичным значением. Каждая тестовая I<проверка> E<mdash> это простой
вопрос, на который можно ответить E<laquo>даE<raquo> или E<laquo>нетE<raquo>:
работает ли этот маленький кусочек кода так, как я ожидаю? Сложные программы
могут иметь тысячи отдельных условий, и, в общем, чем мельче разбиение, тем
лучше. Изолирование конкретных поведений в отдельные проверки позволяет вам
свести к минимуму баги и недопонимания, особенно когда вы будете модифицировать
код в будущем.

Функция C<done_testing()> сообщает C<Test::More>, что программа успешно
выполнила все ожидаемые тестовые проверки. Если программа столкнулась с
исключением времени выполнения, или по другим причинам неожиданно завершилась
прежде, чем произошёл вызов C<done_testing()>, тестовый фреймворк уведомит вас,
что что-то пошло не так. Без механизма, подобного C<done_testing()>, как бы вы
I<узнали>? Правда, этот пример кода слишком прост, чтобы сломаться, но код,
который слишком прост, чтобы сломаться, ломается гораздо чаще, чем кто-либо мог
ожидать.

=begin sidebar

X<testing; plan>
X<C<plan()>>

C<Test::More> также позволяет использовать I<план тестов> для указания
числа отдельных проверок, которые вы планируете выполнить:

=begin programlisting

    use Test::More tests => 4;

    ok(   1, 'the number one should be true'         );
    ok(   0, '... and zero should not'               );
    ok(  '', 'the empty string should be false'      );
    ok( '!', '... and a non-empty string should not' );

=end programlisting

Аргумент C<test>, указываемый для C<Test::More>, устанавливает план тестов для
программы. Это предохранительная сетка. Если выполнено меньше, чем четыре теста,
что-то пошло не так. Если выполнено больше, чем четыре теста, что-то пошло не
так.

=end sidebar

=head2 Запуск тестов

Z<running_tests>

Результирующая программа теперь E<mdash> полноценная программа на Perl 5,
которая генерирует следующий вывод:

=begin screen

    ok 1 - the number one should be true
    not ok 2 - ... and zero should not
    #   Failed test '... and zero should not'
    #   at truth_values.t line 4.
    not ok 3 - the empty string should be false
    #   Failed test 'the empty string should be false'
    #   at truth_values.t line 5.
    ok 4 - ... and a non-empty string should not
    1..4
    # Looks like you failed 2 tests of 4.

=end screen

X<TAP (Test Anything Protocol)>
X<testing; TAP>

Этот формат соответствует стандартному выводу тестов, называемому I<TAP>,
I<Test Anything Protocol>, I<Протокол тестирования чего угодно>
(U<http://testanything.org/>). Проваленные TAP-тесты выдают диагностические
сообщения для помощи отладке.

X<C<Test::Harness>>
X<C<prove>>
X<testing; C<prove>>
X<testing; running tests>

Вывод тестового файла, содержащего множество проверок (особенно множество
I<проваленных> проверок) может быть многословным. В большинстве случаев
вам достаточно знать либо что всё прошло, либо конкретику имеющихся провалов.
Базовый модуль C<Test::Harness> интерпретирует TAP, и связанная с ним
программа C<prove> запускает тесты и отображает только наиболее релевантную
информацию:

=begin screen

    $ B<prove truth_values.t>
    truth_values.t .. 1/?
    #   Failed test '... and zero should not'
    #   at truth_values.t line 4.

    #   Failed test 'the empty string should be false'
    #   at truth_values.t line 5.
    # Looks like you failed 2 tests of 4.
    truth_values.t .. Dubious, test returned 2
        (wstat 512, 0x200)
    Failed 2/4 subtests

    Test Summary Report
    -------------------
    truth_values.t (Wstat: 512 Tests: 4 Failed: 2)
      Failed tests:  2-3

=end screen

Тут много вывода, отображающего то, что и так очевидно: второй и третий тесты
проваливаются, потому что ноль и пустая строка являются ложными значениями. Эти
провалы легко исправить, инвертировав смысл условий с помощью булева приведения
типов (L<boolean_coercion>):

=begin programlisting

    ok(   B<!> 0, '... and zero should not'          );
    ok(  B<!> '', 'the empty string should be false' );

=end programlisting

После этих двух изменений C<prove> выводит следующее:

=begin screen

    $ B<prove truth_values.t>
    truth_values.t .. ok
    All tests successful.

=end screen

=begin sidebar

Смотрите в C<perldoc prove> полезные опции тестов, такие как параллельный запуск
тестов (C<-j>), автоматическое добавление F<lib/> во включаемые пути Perl
(C<-l>), рекурсивный запуск всех файлов тестов, найденных в F<t/> (C<-r t>) и
запуск медленных тестов сначала (C<--state=slow,save>).

X<C<proveall>>
X<testing; C<proveall> alias>

Псевдоним оболочки bash C<proveall> может оказаться полезным:

    alias proveall='prove -j9 --state=slow,save -lr t'

=end sidebar

=head2 Лучшее сравнение

Хотя сердце всех автоматизированных тестов E<mdash> булево условие
E<laquo>истинно или ложно?E<raquo>, сведение всего к этому булеву условию
утомительно и даёт небольшие диагностические возможности. C<Test::More>
предоставляет несколько других удобных функций проверок.

X<C<is()>>
X<testing; C<is()>>
X<operators; C<eq>>

Функция C<is()> сравнивает два значения, используя оператор C<eq>. Если значения
равны, тест проходит. В противном случае, тест проваливается с диагностическим
сообщением:

=begin programlisting

    is(         4, 2 + 2, 'addition should work' );
    is( 'pancake',   100, 'pancakes are numeric' );

=end programlisting

Как вы можете предположить, первый тест проходит, а второй E<mdash>
проваливается.

=begin screen

    t/is_tests.t .. 1/2
    #   Failed test 'pancakes are numeric'
    #   at t/is_tests.t line 8.
    #          got: 'pancake'
    #     expected: '100'
    # Looks like you failed 1 test of 2.

=end screen

Тогда как C<ok()> предоставляет только номер строки провалившегося теста,
C<is()> отображает ожидаемое и полученное значение.

C<is()> налагает неявный скалярный контекст на свои значения (L<prototypes>).
Это означает, например, что вы можете проверить количество элементов в массиве
без необходимости явного вычисления массива в скалярном контексте:

=begin programlisting

    my @cousins = qw( Rick Kristen Alex
                      Kaycee Eric Corey );
    is( @cousins, 6, 'I should have only six cousins' );

=end programlisting

E<hellip>хотя некоторые для ясности предпочитают писать C<scalar @cousins>.

X<C<isnt()>>
X<testing; C<isnt()>>
X<operators; C<ne>>

Соответствующая функция C<Test::More> C<isnt()> сравнивает два значения,
используя оператор C<ne>, и проходит, если они не равны. Она также налагает
скалярный контекст на свои операнды.

X<C<cmp_ok()>>
X<testing; C<cmp_ok()>>

И C<is()>, и C<isnt()> используют I<строковое сравнение> с помощью операторов
Perl 5 C<eq> и C<ne>. Это почти всегда то, что нужно, но для сложных значений,
таких как объекты с перегрузкой (L<overloading>) или двойные переменные
(L<dualvars>), вы можете предпочесть явное тестирование сравнения. Функция
C<cmp_ok()> позволяет вам указать свой собственный оператор сравнения:

=begin programlisting

    cmp_ok( 100, $cur_balance, '<=',
           'I should have at least $100' );

    cmp_ok( $monkey, $ape, '==',
           'Simian numifications should agree' );

=end programlisting

X<C<isa_ok()>>
X<testing; C<isa_ok()>>

Классы и объекты предоставляют свои собственные интересные способы
взаимодействия с тестами. Протестировать, что класс или объект расширяет другой
класс (L<inheritance>), можно с помощью C<isa_ok()>:

=begin programlisting

    my $chimpzilla = RobotMonkey->new();
    isa_ok( $chimpzilla, 'Robot' );
    isa_ok( $chimpzilla, 'Monkey' );

=end programlisting

C<isa_ok()> предоставляет свои собственные диагностические сообщенния при
провалах.

C<can_ok()> проверяет, что класс или объект может выполнить запрошенный метод
(или методы):

=begin programlisting

    can_ok( $chimpzilla, 'eat_banana' );
    can_ok( $chimpzilla, 'transform', 'destroy_tokyo' );

=end programlisting

Функция C<is_deeply()> сравнивает две ссылки, чтобы убедиться, что их содержимое
идентично:

=begin programlisting

    use Clone;

    my $numbers   = [ 4, 8, 15, 16, 23, 42 ];
    my $clonenums = Clone::clone( $numbers );

    is_deeply( $numbers, $clonenums,
         'clone() should produce identical items' );

=end programlisting

X<CPAN; C<Test::Differences>>
X<CPAN; C<Test::Deep>>

Если сравнение проваливается, C<Test::More> сделает всё, что в его силах, чтобы
предоставить разумную диагностику, указывающую позицию первого несоответствия
между структурами. Для более настраиваемых тестов смотрите CPAN-модули
C<Test::Differences> и C<Test::Deep>.

В C<Test::More> есть ещё несколько тестовых функций, но эти наиболее полезны.

=head2 Организация тестов

X<testing; F<.t> files>
X<testing; F<t/> directory>
X<C<Module::Build>>
X<C<ExtUtils::MakeMaker>>

CPAN-дистрибутивы должны включать директорию F<t/>, содержающую один или более
файлов тестов, имеющих расширение F<.t>. По умолчанию, когда вы собираете
дистрибутив с помощью C<Module::Build> или C<ExtUtils::MakeMaker>, этап
тестирования запускает все файлы F<t/*.t>, суммирует их вывод, и проходит
успешно или проваливается в зависимости от результатов набора тестов как целого.
Нет конкретных руководств, как управлять содержимым отдельных файлов F<.t>, хотя
наиболее популярны две стратегии:

=over 4

=item * Каждый файл F<.t> должен соответствовать файлу F<.pm>.

=item * Каждый файл F<.t> должен соответствовать некоторому функционалу.

=back

Смешанный подход наиболее гибок; один тест может проверять, что все ваши модули
компилируются, тогда как другие тесты будут проверять, что каждый модуль ведёт
себя так, как ожидается. Когда дистрибутив разрастается, полезность управления
тестами в привязке к функционалу становится более привлекательной; большие
тестовые файлы сложнее поддерживать.

Кроме того, раздельные файлы тестов могут ускорить разработку. Если вы добавляете
способность дышать огнём к вашему классу C<RobotMonkey>, вы, вероятно, захотите
запускать только тестовый файл F<t/breathe_fire.t>. Когда же вы добъётесь
удовлетворительной работы функционала, запустите весь набор тестов для проверки
того, что локальные изменения не имеют непреднамеренных глобальных эффектов.

=head2 Другие модули для тестирования

X<C<Test::Builder>>
X<testing; C<Test::Builder>>

C<Test::More> полагается на тестовый бэкенд, известный как C<Test::Builder>.
Этот модуль управляет планом тестов и приводит вывод тестов в TAP. Такой
дизайн позволяет множеству тестовых модулей использовать один и тот же бэкенд
C<Test::Builder>. Вследствие этого, на CPAN доступны сотни тестовых модулей
E<mdash> и все они могут работать вместе в одной и той же программе.

X<CPAN; C<Test::Exception>>
X<CPAN; C<Test::Fatal>>
X<CPAN; C<Test::MockObject>>
X<CPAN; C<Test::MockModule>>
X<CPAN; C<Test::WWW::Mechanize>>
X<CPAN; C<Plack::Test>>
X<CPAN; C<Test::WWW::Mechanize::PSGI>>
X<CPAN; C<Test::Database>>
X<CPAN; C<DBICx::TestDatabase>>
X<CPAN; C<DBIx::Class>>
X<CPAN; C<Test::Class>>
X<CPAN; C<Test::Routine>>
X<CPAN; C<Test::Differences>>
X<CPAN; C<Test::Deep>>
X<CPAN; C<Test::LongString>>
X<CPAN; C<Devel::Cover>>

=over 4

=item * C<Test::Fatal> помогает протестировать, что ваш код выбрасывает (и не
выбрасывает) исключения соответствующим образом. Вам также может встретиться
C<Test::Exception>.

=item * C<Test::MockObject> и C<Test::MockModule> позволяют вам тестировать
сложные интерфейсы, I<имитируя> (I<mocking>) их (эмулируя, но производя другие
результаты).

=item * C<Test::WWW::Mechanize> помогает тестировать веб-приложения, тогда как
C<Plack::Test>, C<Plack::Test::Agent> и подкласс C<Test::WWW::Mechanize::PSGI>
могут делать это, не используя внешний живой веб-сервер.

=item * C<Test::Database> предоставляет функции для тестирования правильного и
неправильного использования баз данных. C<DBICx::TestDatabase> помогает
тестировать схемы, сгенерированные с помощью C<DBIx::Class>.

=item * C<Test::Class> предлагает альтернативный механизм организации наборов
тестов. Он позволяет вам создавать классы, в которых конкретные методы
группируют тесты. Вы можете наследовать от этих тестовых классов, так же как
ваши классы кода наследуют друг от друга. Это превосходный способ уменьшить
дублирование в тестовых наборах. См. превосходную серию статей по C<Test::Class>
Кёртиса Пое (Curtis
Poe)N<U<http://www.modernperlbooks.com/mt/2009/03/organizing-test-suites-with-testclass.html>>.
Более новый дистрибутив C<Test::Routine> предлагает аналогичные возможности
посредством использования Moose (L<moose>).

=item * C<Test::Differences> тестирует строки и структуры данных на идентичность
и отображает любые найденные различия в своей диагностике. C<Test::LongString>
добавляет похожие проверки.

=item * C<Test::Deep> тестирует идентичность вложенных структур данных
(L<nested_data_structures>).

=item * C<Devel::Cover> анализирует выполнение ваших наборов тестов и даёт отчёт
о количестве кода, которое тесты действительно выполняют. В общем, чем
больше покрытие, тем лучше E<mdash> хотя стопроцентное покрытие не всегда
возможно, 95% гораздо лучше, чем 80%.

=back

См. проект Perl QA (U<http://qa.perl.org/>) для большей информации о
тестировании в Perl.
