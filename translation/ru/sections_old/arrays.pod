=encoding utf-8

=head1 Массивы

Z<arrays>

X<arrays>
X<C<@> sigil>
X<sigils; C<@>>

I<Массивы> в Perl 5 E<mdash> это структуры данных I<первого класса> E<mdash>
язык поддерживает их как встроенный тип данных E<mdash> которые хранят ноль или
больше скаляров. Вы можете получить доступ к отдельным элементам массива по
целочисленным индексам, а также можете по желанию добавлять или удалять
элементы. Сигил C<@> обозначает массив. Объявить массив можно так:

=begin programlisting

    my @items;

=end programlisting

=head2 Элементы массива

X<sigils; variant>
X<C<$>; sigil>
X<sigils; C<$>>

I<Доступ> к отдельному элементу массива в Perl 5 требует использования
скалярного сигила. C<$cats[0]> E<mdash> однозначное использование массива
C<@cats>, потому что постфиксные (L<fixity>) квадратные скобки (C<[]>) всегда
означают доступ к массиву по индексу.

Первый элемент массива имеет индекс ноль:

=begin programlisting

    # @cats содержит список объектов Cat
    my $first_cat = $cats[0];

=end programlisting

Последний индекс массива зависит от количества элементов в нём. Массив в
скалярном контексте (в скалярном присваивании, строковой конкатенации,
сложении или булевом контексте) возвращает количество элементов в массиве:

=begin programlisting

    # скалярное присваивание
    my $num_cats = @cats;

    # строковая конкатенация
    say 'I have ' . @cats . ' cats!';

    # сложение
    my $num_animals = @cats + @dogs + @fish;

    # булев контекст
    say 'Yep, a cat owner!' if @cats;

=end programlisting

X<C<$#>; sigil>
X<sigils; C<$#>>

Чтобы получить I<индекс> последнего элемента массива, вычтите единицу из
количества элементов в массиве (помните, что индексация массива начинается с 0)
или испольуйте неуклюжий синтаксис C<$#cats>:

=begin programlisting

    my $first_index = 0;
    my $last_index  = @cats - 1;
    # or
    # my $last_index = $#cats;

    say   "My first cat has an index of $first_index, "
        . "and my last cat has an index of $last_index."

=end programlisting

Когда индекс менее важен, чем позиция элемента, используйте взамен отрицательные
индексы. Последний элемент массива доступен по индексу C<-1>. Второй с конца
элемент доступен по индексу C<-2> и т. д.:

=begin programlisting

    my $last_cat           = $cats[-1];
    my $second_to_last_cat = $cats[-2];

=end programlisting

C<$#> имеет другое применение: изменение размера массива путём I<присваивания>
ему. Помните, что массивы в Perl 5 могут изменяться. Они расширяются или
сокращаются по необходимости. Если вы сжимаете массив, Perl отбросит значения,
не помещающиеся в массив с изменённым размером. Если вы расширяете массив, Perl
заполнит добавленные позиции значением C<undef>.

=head2 Присваивание массивам

Присваивайте отдельной позиции в массиве напрямую, используя индекс:

=begin programlisting

    my @cats;
    $cats[3] = 'Jack';
    $cats[2] = 'Tuxedo';
    $cats[0] = 'Daisy';
    $cats[1] = 'Petunia';
    $cats[4] = 'Brad';
    $cats[5] = 'Choco';

=end programlisting

Если вы присвоите индексу, выходящему за пределы текущего размера массива, Perl
расширит массив для соответсвия новому размеру и заполнит все промежуточные
позиции значением C<undef>. После первого присвоения массив будет содержать
C<undef> в позициях 0, 1 и 2, и C<Jack> в позиции 3.

Для сокращения присваивания, инициализируйте массив из списка:

=begin programlisting

    my @cats = ( 'Daisy', 'Petunia', 'Tuxedo', ... );

=end programlisting

E<hellip>но помните, что эти скобки I<не> создают список. Без скобок произошло бы
присваивание C<Daisy> первому и единственному элементу массива, ввиду приоритета
операторов (L<precedence>).

Любое выражение, возвращающее список в списочном контексте, может быть присвоено
массиву:

=begin programlisting

    my @cats     = get_cat_list();
    my @timeinfo = localtime();
    my @nums     = 1 .. 10;

=end programlisting

Присваивание скалярному элементу массива налагает скалярный контекст, тогда как
присваивание всему массиву целиком налагает списочный контекст.

Чтобы очистить массив, присвойте ему пустой список:

=begin programlisting

    my @dates = ( 1969, 2001, 2010, 2051, 1787 );
    ...
    @dates    = ();

=end programlisting

=begin tip Массивы создаются пустыми

C<my @items = ();> E<mdash> более длинная и зашумлённая версия C<my @items>,
потому что свежеобъявленные массивы создаются пустыми.

=end tip

=head2 Операции над массивами

Иногда массив удобнее использовать как упорядоченную, изменяемую коллекцию
элементов, чем соответствие индексов значениям. Perl 5 предоставляет несколько
операций для манипулирования элементами массива без использования индексов:

X<arrays; C<push>>
X<arrays; C<pop>>
X<builtins; C<push>>
X<builtins; C<pop>>

Операторы C<push> и C<pop> добавляют и удаляют элементы из конца массива
соответственно:

=begin programlisting

    my @meals;

    # что есть съедобного?
    push @meals, qw( hamburgers pizza lasagna turnip );

    # E<hellip>но ваш племянник терпеть не может овощи
    pop @meals;

=end programlisting

Вы можете добавить в массив список значений с помощью C<push>, но с помощью
C<pop> можете удалить только один за раз. C<push> возвращает новое количество
элементов в массиве. C<pop> возвращает удалённый элемент.

Поскольку C<push> оперирует списками, вы легко можете добавить элементы одного
или нескольких массивов в другой:

=begin programlisting

    push @meals, @breakfast, @lunch, @dinner;

=end programlisting

X<arrays; C<shift>>
X<arrays; C<unshift>>
X<builtins; C<shift>>
X<builtins; C<unshift>>

Аналогично, C<unshift> и C<shift> добавляют элементы или удаляют элемент из
начала массива соответственно:

=begin programlisting

    # расширить наши кулинарные горизонты
    unshift @meals, qw( tofu spanakopita taquitos );

    # пересмотрим всю эту идею с соей
    shift @meals;

=end programlisting

C<unshift> вставляет список элементов в начало массива и возвращает новое
количество элементов в массиве. C<shift> удаляет и возвращает первый элемент
массива.

Немногие программы используют возвращаемые значения C<push> и C<unshift>.

X<arrays; C<splice>>
X<builtins; C<splice>>

Оператор C<splice> удаляет и заменяет элементы в массиве в соответствии с
заданным смещением, длинной вырезаемого списка и списком для замены. И замена, и
удаление E<mdash> опциональны; вы можете опустить любое из этих поведений.
Описание C<splice> в C<perlfunc> демонстрирует его равноценность с
C<push>, C<pop>, C<shift> и C<unshift>. Одно из возможных применений E<mdash>
удаление двух элементов из массива:

=begin programlisting

    my ($winner, $runnerup) = splice @finalists, 0, 2;

    # или
    my $winner              = shift @finalists;
    my $runnerup            = shift @finalists;

=end programlisting

X<arrays; C<each>>
X<builtins; C<each>>

До Perl 5.12 итерация по массиву с использованием индекса требовала цикла в
стиле C. Начиная с Perl 5.12, C<each> может итерировать по массиву по индексу и
значению:

=begin programlisting

    while (my ($index, $value) = each @bookshelf)
    {
        say "#$index: $value";
        ...
    }

=end programlisting

=head2 Срезы массивов

Z<array_slices>

X<arrays; slices>
X<slices; array>
X<C<@>; sigil>
X<sigils; C<@>>

I<Срез массива> позволяет вам получить доступ к элементам массива в списочном
контексте. В отличие от скалярного доступа к элементу массива, эта операция
принимает список из ноля или более индексов и использует сигил массива (C<@>):

=begin programlisting

    my @youngest_cats = @cats[-1, -2];
    my @oldest_cats   = @cats[0 .. 2];
    my @selected_cats = @cats[ @indexes ];

=end programlisting

Срезы массивов удобны для присваивания:

=begin programlisting

    @users[ @replace_indices ] = @replace_users;

=end programlisting

Срез может содержать ноль или более элементов E<mdash> включая один:

=begin programlisting

    # одноэлементный срез массива; I<списочный> контекст
    @cats[-1] = get_more_cats();

    # доступ к одному элементу массива; I<скалярный> контекст
    $cats[-1] = get_more_cats();

=end programlisting

Единственное синтаксическое различие между срезом массива из одного элемента и
скалярным доступом к элементу массива E<mdash> предшествующий сигил.
I<Семантическая> разница намного больше: срез массива всегда налагает списочный
контекст. Срез массива, используемый в скалярном контексте, вызовет
предупреждение:

=begin screen

    Scalar value @cats[1] better written as $cats[1]...

=end screen

Срез массива налагает списочный контекст на выражение, используемое в качестве
его индекса:

=begin programlisting

    # функция вызывается в списочном контексте
    my @hungry_cats = @cats[ get_cat_indices() ];

=end programlisting

=head2 Массивы и контекст

X<list context; arrays>

В списочном контексте массивы разглаживаются в списки. Если вы передадите
несколько массивов нормальной функции в Perl 5, они разгладятся в единый список:

=begin programlisting

    my @cats = qw( Daisy Petunia Tuxedo Brad Jack );
    my @dogs = qw( Rodney Lucky );

    take_pets_to_vet( @cats, @dogs );

    sub take_pets_to_vet
    {
        # ГЛЮЧНО: не использовать!
        my (@cats, @dogs) = @_;
        ...
    }

=end programlisting

Внутри функции C<@_> будет содержать семь элементов, не два, потому что
списочное присваивание массивам обладает I<жадностью>. Массив поглотит столько
элементов из списка, сколько возможно. После присваивания C<@cats> будет
содержать I<все> аргументы, переданные в функцию. C<@dogs> будет пустым.

Это разглаживающиее поведение иногда ставит в тупик новичков, которые пытаются
создать вложенные массивы в Perl 5:

=begin programlisting

    # создаёт один массив, не массив массивов
    my @numbers = (  1 .. 10,
                  ( 11 .. 20,
                  ( 21 .. 30 ) ) );

=end programlisting

E<hellip>но этот код, в сущности, то же самое, что и:

=begin programlisting

    # создаёт один массив, не массив массивов
    my @numbers = 1 .. 30;

=end programlisting

E<hellip>потому что скобки всего лишь группируют выражения. Они не
I<создают> списки в этой ситуации. Чтобы избежать этого разглаживающего
поведения, используйте ссылки на массивы (L<array_references>).

=head2 Интерполяция массивов

X<arrays; interpolation>
X<interpolation; arrays>
X<C<$">>
X<C<$LIST_SEPARATOR>>

Массивы интерполируются в строках как списки всех приведённых в строковый вид
элементов, разделённых текущим значением магической глобальной переменной C<$">.
Значение по умолчанию этой переменной E<mdash> один пробел. Её мнемоника в
F<English.pm> E<mdash> C<$LIST_SEPARATOR>. Поэтому получаем следующее:

=begin programlisting

    my @alphabet = 'a' .. 'z';
    say "[@alphabet]";
    B<[a b c d e f g h i j k l m>
     B<n o p q r s t u v w x y z]>

=end programlisting

Локализуйте C<$"> своим разделителем чтобы облегчить отладкуN<Благодарность за
эту технику уходит Марку Джейсону Доминусу (Mark Jason Dominus).>:

=begin programlisting

    # так что там в этом массиве?
    local $" = ')(';
    say "(@sweet_treats)";
    B<(pie)(cake)(doughnuts)(cookies)(raisin bread)>

=end programlisting
