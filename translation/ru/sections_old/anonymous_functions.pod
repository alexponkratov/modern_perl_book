=encoding utf-8

=head1 Анонимные функции

Z<anonymous_functions>

X<functions; anonymous>

I<Анонимная функция> E<mdash> это функция без имени. В остальном она ведёт себя
в точности так же, как именованная функция E<mdash> вы можете вызывать её,
передавать в неё аргументы, возвращать из неё значения и копировать ссылки на
неё. Однако единственный способ работать с ней E<mdash> по ссылке
(L<function_references>).

X<functions; dispatch table>
X<idioms; dispatch table>
X<dispatch table>

Распространённая идиома Perl 5, известная как I<таблица диспетчеризации>,
использует хеши для сопоставления входных данных с соответствующим поведением:

=begin programlisting

    my %dispatch =
    (
        plus     => \&add_two_numbers,
        minus    => \&subtract_two_numbers,
        times    => \&multiply_two_numbers,
    );

    sub add_two_numbers      { $_[0] + $_[1] }
    sub subtract_two_numbers { $_[0] - $_[1] }
    sub multiply_two_numbers { $_[0] * $_[1] }

    sub dispatch
    {
        my ($left, $op, $right) = @_;

        return unless exists $dispatch{ $op };

        return $dispatch{ $op }->( $left, $right );
    }

=end programlisting

Функция C<dispatch()> принимает аргументы в форме C<(2, 'times', 2)> и
возвращает результат вычисления операции.

=head2 Объявление анонимных функций

X<builtins; C<sub>>

Встроенная директива C<sub>, использованная без имени, создаёт и возвращает
анонимную функцию. Используйте эту ссылку на функцию в любом месте, где вы могли
бы использовать ссылку на именованную функцию, как, например, объявление функций
таблицы диспетчеризации прямо на месте:

=begin programlisting

    my %dispatch =
    (
        plus      => sub { $_[0]  + $_[1] },
        minus     => sub { $_[0]  - $_[1] },
        times     => sub { $_[0]  * $_[1] },
        dividedby => sub { $_[0]  / $_[1] },
        raisedto  => sub { $_[0] ** $_[1] },
    );

=end programlisting

=begin tip Защитная диспетчеризация

Эта таблица диспетчеризации создаёт некоторую степень защиты; только функции,
входящие в таблицу, доступны для вызова пользователями. Если ваша функция
диспетчеризации слепо предполагает, что строка, заданная как имя оператора, напрямую
соответствует имени вызываемой функции, злонамеренный пользователь потенциально
сможет вызвать любую функцию в любом пространстве имён, передав
C<'Internal::Functions::malicious_function'>.

=end tip

Вам также может встретиться передача анонимных функций как аргументов функции:

=begin programlisting

    sub invoke_anon_function
    {
        my $func = shift;
        return $func->( @_ );
    }

    sub named_func
    {
        say 'I am a named function!';
    }

    invoke_anon_function( \&named_func );
    invoke_anon_function( B<sub { say 'Who am I?' }> );

=end programlisting

=head2 Имена анонимных функций

X<anonymous functions; names>

X<CPAN; C<Sub::Identify>>

Имея ссылку на функцию, вы можете определить, именованная она или анонимная, с
помощью интроспекцииN<E<hellip>или с помощью C<sub_name> из CPAN-модуля
C<Sub::Identitiy>.>:

=begin programlisting

    package ShowCaller;

    sub show_caller
    {
        my ($package, $file, $line, $sub) = caller(1);
        say "Called from $sub in $package:$file:$line";
    }

    sub main
    {
        my $anon_sub = sub { show_caller() };
        show_caller();
        $anon_sub->();
    }

    main();

=end programlisting

Результат может быть неожиданным:

    Called from ShowCaller::B<main>
             in ShowCaller:anoncaller.pl:20
    Called from ShowCaller::B<__ANON__>
             in ShowCaller:anoncaller.pl:17

X<CPAN; C<Sub::Name>>

C<__ANON__> во второй строке вывода показывает, что анонимная функция не имеет
имени, которое Perl мог бы распознать. Это может усложнить отладку. Функция
C<subname()> из CPAN-модуля C<Sub::Name> позволяет вам закреплять имена за
анонимными функциями:

=begin programlisting

    use Sub::Name;
    use Sub::Identify 'sub_name';

    my $anon  = sub {};
    say sub_name( $anon );

    my $named = subname( 'pseudo-anonymous', $anon );
    say sub_name( $named );
    say sub_name( $anon );

    say sub_name( sub {} );

=end programlisting

Эта программа выведет:

    __ANON__
    pseudo-anonymous
    pseudo-anonymous
    __ANON__

Имейте ввиду, что обе ссылки ссылаются на одну и ту же лежащую в основе функцию.
Использование C<subname()> на одной ссылке на функцию будет изменять имя этой
анонимной функции так, что все остальные ссылки на неё будут видеть это новое
имя.

=head2 Неявные анонимные функции

X<anonymous functions; implicit>

X<CPAN; C<Test::Fatal>>

Perl 5 позволяет объявлять анонимные фукнции неявно, используя прототипы
(L<prototypes>). Хотя официально эта возможность существует для того, чтобы дать
программистам возможность писать свой собственный синтаксис, подобный
C<map> и C<eval>, интересным примером является использование I<отложенных>
функций, которые не выглядят как функции.

Рассмотрите CPAN-модуль C<Test::Fatal>, который принимает анонимную функцию как
первый аргумент своей функции C<exception()>:

=begin programlisting

    use Test::More;
    use Test::Fatal;

    my $croaker = exception { die 'I croak!' };
    my $liver   = exception { 1 + 1 };

    like( $croaker, qr/I croak/, 'die() should croak'   );
    is(   $liver,   undef,       'addition should live' );

    done_testing();

=end programlisting

Вы можете переписать это более многословно следующим образом:

=begin programlisting

    my $croaker = exception( sub { die 'I croak!' } );
    my $liver   = exception( sub { 1 + 1 } );

=end programlisting

E<hellip> или передать именованную функцию по ссылке:

=begin programlisting

    B<sub croaker { die 'I croak!' }>
    B<sub liver   { 1 + 1 }>

    my $croaker = exception \&croaker;
    my $liver   = exception \&liver;

    like( $croaker, qr/I croak/, 'die() should die'     );
    is(   $liver,   undef,       'addition should live' );

=end programlisting

E<hellip>но вы I<не> можете передавать их как скалярные ссылки:

=begin programlisting

    B<my $croak_ref = \&croaker;>
    B<my $live_ref  = \&liver;>

    # ОШИБОЧНО: не работает
    my $croaker   = exception $croak_ref;
    my $liver     = exception $live_ref;

=end programlisting

E<hellip>потому что прототип изменяет то, как парсер Perl 5 интерпретирует этот
код. Он не может со стопроцентной точностью определить, I<что> будут содержать
C<$croaker> и C<$liver>, и поэтому выбросит исключение.

=begin screen

    Type of arg 1 to Test::Fatal::exception
       must be block or sub {} (not private variable)

=end screen

Кроме того, имейте ввиду, что функция, принимающая анонимную функцию как первый
из нескольких аргументов, не может иметь замыкающую запятую после блока функции:

=begin programlisting

    use Test::More;
    use Test::Fatal 'dies_ok';

    dies_ok { die 'This is my boomstick!' }
            'No movie references here';

=end programlisting

Это временами сбивающий с толку изъян в остальном полезного синтаксиса,
учтивость в отношении причуд парсера Perl 5. Синтаксическая ясность,
обеспечиваемая повышением голых блоков до анонимных функций, может быть
полезной, но используйте её экономно и тщательно документируйте API.
