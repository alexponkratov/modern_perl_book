=encoding utf-8

=head1 Неявные идеи

Z<implicit_ideas>

Контекст E<mdash> лишь одна из лингвистических уловок в Perl. Программисты,
понимающие эти уловки, могут, бросив взгляд на код, сразу же понять его наиболее
важные характеристики. Другая важная лингвистическая особенность E<mdash>
эквивалент местоимений в Perl.

=head2 Подразумеваемая переменная-скаляр

Z<default_scalar_variable>

X<default variables; scalar>
X<default variables; C<$_>>
X<< variables; C<$_> >>
X<< C<$_>; default scalar variable >>

I<Подразумеваемая переменная-скаляр> (ещё называемая I<переменная-топик>),
C<$_>, наиболее примечательна своим I<отсутствием>: многие встроенные операции
в Perl работают с содержимым C<$_> в отсутствие явно указанной переменной. Вы
можете использовать C<$_> и как переменную, но это зачастую излишне.

X<builtins; C<chomp>>
X<builtins; C<chr>>
X<builtins; C<ord>>
X<builtins; C<lc>>
X<builtins; C<length>>
X<builtins; C<reverse>>
X<builtins; C<uc>>

Многие скалярные операторы Perl (включая C<chr>, C<ord>, C<lc>, C<length>,
C<reverse> и C<uc>) работают с подразумеваемой переменной-скаляром, если вы не
предоставили  альтернативы. Например, встроенная функция C<chomp> удаляет все
завершающие последовательности новых строк из своего операндаN<См. C<perldoc
-f chomp> и C<$/> для более точных деталей её поведения.>:

=begin programlisting

    my $uncle = "Bob\n";
    chomp $uncle;
    say "'$uncle'";

=end programlisting

C<$_> в Perl имеет ту же самую функцию, что и местоимение I<it> (I<это>) в
английском. Без явно указанной переменной, C<chomp> удаляет все завершающие
последовательности новых строк из C<$_>. Perl понимает, что вы имеете ввиду
говоря E<laquo>C<chomp>E<raquo> (E<laquo>обгрызтьE<raquo>); Perl всегда обгрызёт
I<это>, так что следующие две строки кода эквивалентны:

=begin programlisting

    chomp $_;
    chomp;

=end programlisting

X<builtins; C<say>>
X<builtins; C<print>>

Аналогично, C<say> и C<print> оперируют с C<$_> в отстутствие других аргументов:

=begin programlisting

    print;  # выводит $_ в текущий дескриптор файла
    say;    # выводит "$_\n" в текущий дескриптор файла

=end programlisting

X<C<s///>; substitution operator>
X<C<m//>; match operator>
X<C<tr//>; transliteration operator>

Средства работы с регулярными выражениями в Perl (L<regex>) по умолчанию
используют C<$_> для сопоставления, замены и транслитерации:

=begin programlisting

    $_ = 'My name is Paquito';
    say if /My name is/;

    s/Paquito/Paquita/;

    tr/A-Z/a-z/;
    say;

=end programlisting

X<builtins; C<for>>

Директивы циклов в Perl (L<looping_directives>) по умолчанию используют C<$_>
как итерационную переменную. Рассмотрим директиву C<for>, итерирующую по списку:

=begin programlisting

    say "#B<$_>" for 1 .. 10;

    for (1 .. 10)
    {
        say "#B<$_>";
    }

=end programlisting

X<builtins; C<while>>

E<hellip>или C<while>:

=begin programlisting

    while (<STDIN>)
    {
        chomp;
        say scalar reverse;
    }

=end programlisting

X<builtins; C<map>>

E<hellip>или C<map>, преобразовывающую список:

=begin programlisting

    my @squares = map { B<$_> * B<$_> } 1 .. 10;
    say for @squares;

=end programlisting

X<builtins; C<grep>>

E<hellip>или C<grep>, фильтрующую список:

=begin programlisting

    say 'Brunch time!'
        if grep { /pancake mix/ } @pantry;

=end programlisting

Как английский становится запутанным, если вы используете слишком много
местоимений и антецедентов, так и со смешанным использованием C<$_>, явным или
неявным, нужно быть осторожным. Неосмотрительное параллельное использование
C<$_> может привести к тому, что один кусок кода молча перезапишет значение,
записанное другим. Если вы пишете функцию, которая использует C<$_>, вы можете
сломать работу с C<$_> в вызывающей функции.

Начиная с Perl 5.10 появилась возможность объявлять C<$_> как лексическую
переменную (L<lexical_scope>), чтобы предотвратить такое разрушительное
поведение:

=begin programlisting

    while (<STDIN>)
    {
        chomp;

        # ПЛОХОЙ ПРИМЕР
        my $munged = calculate_value( $_ );
        say "Original: $_";
        say "Munged  : $munged";
    }

=end programlisting

Если I<calculate_value()> или любая другая функция изменит C<$_>, это изменение
сохранится на протяжении текущей итерации цикла. Добавление объявления C<my>
предотвращает потерю существующего экземпляра C<$_>:

=begin programlisting

    while (my $_ = <STDIN>)
    {
        ...
    }

=end programlisting

Конечно, использование именованной лексической переменной может быть таким же
ясным:

=begin programlisting

    while (my $line = <STDIN>)
    {
        ...
    }

=end programlisting

Используйте C<$_>, так же, как вы использовали бы слово E<laquo>этоE<raquo>
в формальном письме: экономно, в разумных и хорошо определённых границах.

=begin tip Оператор C<...>

X<builtins; C<...>>

В Perl 5.12 появился оператор троеточие (C<...>) как заполнитель для кода,
который вы намереваетесь поместить позже. Perl будет парсить его как законченную
инструкцию, но выбросит исключение, что вы пытаетесь выполнить
неимплементированный код, если вы попытаетесь его запустить. См. подробности в
C<perldoc perlop>.

=end tip

=head2 Подразумеваемая переменная-массив

Z<default_array_variables>

X<default variables; array>
X<default variables; C<@_>>
X<variables; C<@_>>
X<C<@_>>

Perl также предоставляет две неявные переменные-массива. Perl передаёт аргументы
в функции (L<functions>) в массиве C<@_>. Операции работы с массивами
(L<arrays>) внутри функций по умолчанию воздействуют на эту переменную, поэтому
два этих фрагмента кода эквивалентны:

=begin programlisting

    sub foo
    {
        my $arg = shift;
        ...
    }

    sub foo_explicit_args
    {
        my $arg = shift @_;
        ...
    }

=end programlisting

X<builtins; C<shift>>
X<builtins; C<pop>>

Так же как C<$_> соответствует местоимению I<it> (I<это>), C<@_> соответствует
местоимениям I<they> (I<они>) и I<them> (I<их>). I<В отличие> от C<$_>, Perl
автоматически локализует для вас C<@_> когда вы вызываете другие функции.
Встроенные функции C<shift> и C<pop> работают с C<@_>, если отсутствуют другие
операнды.

X<default variables; C<@ARGV>>
X<variables; C<@ARGV>>
X<C<@ARGV>>

Снаружи всех функций подразумеваемая переменная-массив C<@ARGV> содержит аргументы
командной строки, переданные в программу. Операции работы с массивами в Perl
(включая C<shift> и C<pop>) неявно работают с C<@ARGV> за пределами функций. Вы
не сможете использовать C<@_> когда подразумеваете C<@ARGV>.

=begin tip C<readline>

X<builtins; C<readline>>
X<builtins; C<glob>>

Оператор C<< <$fh> >> в Perl E<mdash> то же самое, что встроенная функция
C<readline>. C<readline $fh> делает то же самое, что и C<< <$fh> >>. Начиная с
Perl 5.10 голая C<readline> ведёт себя точно так же, как C<< <> >>, так что
теперь вы можете везде использовать C<readline>. По историческим причинам
C<< <> >> E<mdash> всё ещё более распространённый вариант, однако рассмотрите
использование C<readline> как более читаемой альтернативы. Вы возможно
предпочтёте C<glob '*.html'> варианту C<< <*.html> >>, правда? Здесь та же
самая идея.

=end tip

X<null filehandle>

C<@ARGV> имеет один специальный случай. Если вы читаете из пустого дескриптора
файла C<< <> >>, Perl будет воспринимать каждый элемент в C<@ARGV> как I<имя>
файла, который нужно открыть для чтения. (Если массив C<@ARGV> пуст, Perl будет
читать со стандартного ввода.) Это неявное поведение C<@ARGV> полезно при
написании коротких программ, таких как этот фильтр для командной строки,
изменяющий порядок своих входных данных на противоположный:

=begin programlisting

    while (<>)
    {
        chomp;
        say scalar reverse;
    }

=end programlisting

Почему C<scalar>? C<say> налагает списочный контекст на свои операнды.
C<reverse> передаёт свой контекст своим операндам, обрабатывая их как список в
списочном контексте и как конкатенированную строку в скалярном контексте. Если
поведение C<reverse> выглядит сбивающим с толку, ваши инстинкты верны. Perl 5
вероятно должен быть разделить E<laquo>перевернуть строкуE<raquo> и
E<laquo>перевернуть списокE<raquo>.

Если вы запустите этот код со списком файлов:

=begin screen

    $ B<perl reverse_lines.pl encrypted/*.txt>

=end screen

E<hellip>результат будет одним длинным потоком вывода. Не передавая никаких
аргументов, вы можете задать свой собственный стандартный ввод, передав его
по конвейеру из другой программы или введя напрямую. Однако, Perl хорош для
гораздо большего, чем маленькие программы для командной строкиE<hellip>
