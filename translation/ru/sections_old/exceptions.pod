=encoding utf-8

=head1 Исключения

Z<exceptions>
X<exceptions>

Программировать хорошо означает предвидеть неожиданное. Файлы, которые должны
существовать, не существуют. Этот огромный диск, который никогда не заполнится,
оказывается полным. Всегда доступная сеть не доступна. Неломающиеся базы данных
ломаются. Исключения случаются, и надёжное программное обеспечение должно их
обрабатывать. Если вы можете восстановиться, отлично! Если не можете, запишите
нужную информацию в лог и повторите попытку.

Pelr 5 обрабатывает исключительные ситуации с помощью I<исключений>: механизм
потока управления динамической области видимости, разработанный для генерации
и обработки ошибок.

=head2 Выбрасывание исключений

Z<throwing_exceptions>

Предположим, вы хотите записать в лог файл. Если вы не смогли открыть файл,
что-то пошло не так. Используйте C<die> чтобы выбросить исключение:

=begin programlisting

    sub open_log_file
    {
        my $name = shift;
        open my $fh, '>>', $name
            B<or die "Can't open logging file '$name': $!";>
        return $fh;
    }

=end programlisting

X<builtins; C<die>>
X<exceptions; throwing>
X<exceptions; throwing strings>
X<exceptions; C<die>>
X<C<$@>>
X<exceptions; C<$@>>

C<die()> устанавливает значение своего операнда в глобальную переменную C<$@> и
немедленно выходит из текущей функции, I<ничего не возвращая>. Это выброшенное
исключение будет подниматься по стеку вызовов (L<controlled_execution>) до тех
пор, пока не будет где-нибудь поймано. Если исключение не будет поймано нигде,
программа завершится с ошибкой.

Обработка исключений использует ту же самую динамическую область видимости
(L<dynamic_scope>), что и символы, объявленные с помощью C<local>.

=head2 Отлавливание исключений

Z<catching_exceptions>

X<exceptions; catching>

Иногда исключение, приводящее к выходу из программы, удобно. Программа,
выполняемая как синхронизированный процесс, может выбросить исключение, если
логи ошибок заполнены, что приведёт к отправке SMS администраторам. Однако, не
все исключения должны быть фатальными. От некоторых из них хорошие программы
должны уметь восстанавливаться, или по крайней мере сохранять текущее состояние
и завершаться чисто.

X<builtins; C<eval>>
X<C<eval>; block>

Используйте блочную форму оператора C<eval> чтобы поймать исключение:

=begin programlisting

    # лог-файл может не открыться
    my $fh = eval { open_log_file( 'monkeytown.log' ) };

=end programlisting

Если файл успешно открыт, C<$fh> будет содержать дескриптор файла. Если нет,
C<$fh> останется неопределённой и выполнение программы продолжится.

Блочный аргумента C<eval> вводит новую область видимости, и лексическую, и
динамическую. Если C<open_log_file()> вызывает другие функции, и какая-нибудь из
них в конечном счёте выбросила исключение, этот C<eval> его поймает.

X<magic variables; C<$@>>

Обработка исключений E<mdash> грубый инструмент. Он будет ловить все исключения
в своей динамической области видимости. Чтобы проверить, какое исключение вы
поймали (и поймали ли вообще), проверьте значение C<$@>. Убедитесь, что
локализовали C<$@> с помощью C<local>, прежде чем попытаться поймать исключение;
помните, что C<$@> E<mdash> глобальная переменная:

=begin programlisting

    B<local $@;>

    # лог-файл может не открыться
    my $fh = eval { open_log_file( 'monkeytown.log' ) };

    # поймано исключение
    B<if (my $exception = $@) { ... }>

=end programlisting

X<exceptions; rethrowing>

Сразу же скопируйте C<$@> в лексическую переменную, чтобы избежать возможности
того, что последующий код перезапишет глобальную переменную C<$@>. Вы никогда не
знаете, что ещё могло использовать блок C<eval> в каком-нибудь другом месте и
сбросить C<$@>.

C<$@> обычно содержит строку, описывающую исключение. Проверьте её содержимое,
чтобы увидеть, можете ли вы обработать исключение:

=begin programlisting

    if (my $exception = $@)
    {
        die $exception
            unless $exception =~ /^Can't open logging/;
        $fh = log_to_syslog();
    }

=end programlisting

Пробросьте исключение, снова вызвав C<die()>. Передайте существующее исключение
или новое, в зависимости от необходимости.

X<exceptions; throwing objects>

Применение к строковым исключениям регулярных выражений может быть ненадёжным,
потому что сообщения об ошибках могут со временем меняться. Это относится и к
внутренним исключениям, которые выбрасывает сам Perl. К счастью, вы можете
также передавать в C<die> ссылку E<mdash> даже благословлённую ссылку. Это
позволяет вам предоставлять в вашем исключении гораздо больше информации: номера
строк, файлы и другую отладочную информацию. Получение этой информации из
чего-то структурированного намного легче, чем разбор строки. Ловите эти
исключения так же, как любые другие.

X<exceptions; custom classes with C<Exception::Class>>
X<C<Exception::Class>>

CPAN-дистрибутив C<Exception::Class> упрощает создание и использование
объектов-исключений:

=begin programlisting

    package Zoo::Exceptions
    {
        use Exception::Class
            'Zoo::AnimalEscaped',
            'Zoo::HandlerEscaped';
    }

    sub cage_open
    {
        my $self = shift;
        Zoo::AnimalEscaped->throw
            unless $self->contains_animal;
        ...
    }

    sub breakroom_open
    {
        my $self = shift;
        Zoo::HandlerEscaped->throw
            unless $self->contains_handler;
        ...
    }

=end programlisting

=head2 Предостережения об исключениях

Z<exception_caveats>

X<exceptions; caveats>

Хотя выбрасывание исключений относительно просто, ловить их сложнее. Корректное
использование C<$@> требует от вас обходить некоторые неочевидные риски:

=over 4

=item * Нелокализованное с помощью C<local> использование дальше в динамической
области видимости может модифицировать C<$@>

=item * Она может содержать объкт, перегружающий своё булево значение для
возврата ложного значения

=item * Обработчик сигнала (особенно обработчик сигнала C<DIE>) может изменять
C<$@>

=item * Уничтожение объекта при выходе из области видимости может вызывать
C<eval> и изменять C<$@>

=back

X<exceptions; handling safely with C<Try::Tiny>>
X<C<Try::Tiny>>

Perl 5.14 исправил некоторые из этих проблем. Признаем, они встречаются очень
редко, но зачастую сложны для диагностики и исправления. CPAN-дистрибутив
C<Try::Tiny> улучшает безопасность обработки исключений I<и> синтаксисN<На самом
деле, C<Try::Tiny> помог вдохновить на улучшения в обработке исключений в
Perl 5.14.>.

C<Try::Tiny> прост в использовании:

=begin programlisting

    use Try::Tiny;

    my $fh = try   { open_log_file( 'monkeytown.log' ) }
             catch { log_exception( $_ ) };

=end programlisting

C<try> заменяет C<eval>. Необязательный блок C<catch> выполняется, только если
C<try> поймал исключение. C<catch> получает пойманное исключение как
переменную-топик C<$_>.

=head2 Встроенные исключения

Z<builtin_exceptions>

X<exceptions; core>

Сам Perl 5 выбрасывает несколько исключительных условий. C<perldoc perldiag>
перечисляет несколько E<laquo>отлавливаемых фатальных ошибокE<raquo>. Тогда как
часть из них E<mdash> синтаксические ошибки, выбрасываемые в процессе
компиляции, другие вы можете поймать во время выполнения. Наиболее интересны
следующие:

=over 4

=item * Using a disallowed key in a locked hash (использование недопустимого
ключа в заблокированном хеше) (L<locked_hashes>)

=item * Blessing a non-reference (Благословление не-ссылки)
(L<blessed_references>)

=item * Calling a method on an invalid invocant (вызов метода на некорректном
инвоканте) (L<moose>)

=item * Failing to find a method of the given name on the invocant (не удалось
обнаружить метод с заданным именем в инвоканте)

=item * Using a tainted value in an unsafe fashion (небезопасное использование
испорченного значения) (L<taint>)

=item * Modifying a read-only value (модификация значения, доступного только для
чтения)

=item * Performing an invalid operation on a reference (выполнение недопустимой
операции над ссылкой) (L<references>)

=back

X<C<autodie>>

Конечно, вы также можете ловить исключения, производимые C<autodie> (L<autodie>),
и любые лексические предупреждения, повышенные до исключений
(L<registering_warnings>).
