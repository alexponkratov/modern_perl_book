=encoding utf-8

=head1 Значения

Z<values>

X<variables>
X<values>

Структура программы в большой степени зависит от способов, используя которые
вы моделируете ваши данные с помощью соответствующих переменных.

Тогда как переменные позволяют производить абстрактные манипуляции с данными,
значения, которые они содержат, делают программы конкретными и полезными. Чем
более точны значения, тем лучше ваши программы. Эти значения E<mdash> это
данные: имя и адрес вашей тётушки, расстояние между вашим офисом и полем для
игры в гольф на луне или вес всех печенек, которые вы съели за прошлый год.
Внутри вашей программы правила, касающиеся формата этих данных, зачастую строги.
Действенные программы требуют действенных (простых, быстрых, более компактных,
более эффективных) способов представления их данных.

=head2 Строки

X<strings>

I<Строка> E<mdash> это кусок текстовых или двоичных данных без какого-либо
особого форматирования или содержимого. Это может быть ваше имя, содержимое
файла изображения или сама ваша программа. Строка имеет значение в программе
только когда вы придаёте ей это значение.

X<strings; delimiters>

Для представляения литеральной строки в вашей программе, окружите её парой
символов заключения в кавычки. Наиболее распространённые I<ограничители строк>
E<mdash> одиночные и двойные кавычки:

=begin programlisting

    my $name    = B<'Donner Odinson, Bringer of Despair'>;
    my $address = B<"Room 539, Bilskirnir, Valhalla">;

=end programlisting

X<strings; single-quoted>

Символы в I<строке, заключённой в одиночные кавычки>, представляют в точности
себя, за двумя исключениями. Одиночная кавычка, помещаемая в заключённую в
одиночные кавычки строку, должна быть экранирована предшествующим обратным
слешем:

=begin programlisting

    my $reminder = 'DonB<\'>t forget to escape '
                 . 'the single quote!';

=end programlisting

Также вы должны экранировать обратный слеш, находящийся в конце строки, чтобы
избежать экранирования закрывающего ограничителя и получения синтаксической
ошибки:

=begin programlisting

    my $exception = 'This string ends with a '
                  . 'backslash, not a quote: B<\\>';

=end programlisting

Любой другой обратный слеш станет частью строки как есть, если только два
обратных слеша не расположены друг за другом, в этом случае первый будет
экранировать второй:

=begin programlisting

    is('Modern B<\> Perl', 'Modern B<\\> Perl',
        'single quotes backslash escaping');

=end programlisting

X<strings; double-quoted>

Для I<строки, заключённой в двойные кавычки>, доступно ещё некоторое количество
специальных символов. Например, вы можете закодировать в строке иначе невидимые
пробельные символы:

=begin programlisting

    my $tab       = "B<\t>";
    my $newline   = "B<\n>";
    my $carriage  = "B<\r>";
    my $formfeed  = "B<\f>";
    my $backspace = "B<\b>";

=end programlisting

Это демонстрирует полезный принцип: синтаксис, используемый для объявления
строки, может варьироваться. Вы можете представить символ табуляции в строке
как C<\t> или введя его напрямую. С точки зрения Perl, обе строки ведут себя
одинаково, несмотря на то, что конкретное представление строки в исходном коде
может отличаться.

Объявление строки может пересекать логические переводы строк; эти два объявления
эквивалентны:

=begin programlisting

    my $escaped = "two\nlines";
    my $literal = "two
    lines";
    is $escaped, $literal, 'equivalent \n and newline';

=end programlisting

Эти последовательности зачастую проще читать, чем их пробельные эквивалентны.

X<concatenation>
X<strings; concatenation>
X<operators; C<.>>

Строки в Perl имеют переменную длину. По мере того, как вы манипулируете
строками и модифицируете их, Perl будет соответствующим образом изменять их
размер. Например, вы можете объединить несколько строк в одну большую строку с
помощью оператора I<конкатенации> C<.>:

=begin programlisting

    my $kitten = 'Choco' . ' ' . 'Spidermonkey';

=end programlisting

Это фактически то же самое, что и инициализация строки сразу целиком.

X<interpolation>
X<strings; interpolation>

Также вы можете I<интерполировать> значение скалярной переменной или значений
массива в строке, заключённой в двойные кавычки, так что I<текущее> содержимое
переменной станет частью строки, как если бы вы их конкатенировали:

=begin programlisting

    my $factoid = "B<$name> lives at B<$address>!";

    # эквивалентно
    my $factoid = $name . ' lives at ' . $address . '!';

=end programlisting

X<escaping>

Включение двойной кавычки в заключённую в двойные кавычки строку требует её
I<экранирования> (то есть предварения её обратным слешем):

=begin programlisting

    my $quote = "\"Ouch,\", he cried.  \"That I<hurt>!\"";

=end programlisting

X<operators; quoting>
X<C<q>; single quoting operator>
X<operators; C<q>>
X<C<qq>; double quoting operator>
X<operators; C<qq>>

Когда повторение обратных слешей становится громоздким, используйте
альтернативный I<оператор заключения в кавычки>, для которого вы можете выбрать
альтернативный ограничитель строк. Оператор C<q> аналогичен одиночным кавычкам,
тогда как оператор C<qq> обеспечивает поведение двойных кавычек. Символ,
следующий сразу за оператором, определяет, какой символ используется для
ограничения строк. Если этот символ является открывающим символом симметричной
пары E<mdash> такой как открывающая и закрывающая скобки E<mdash> закрывающий
символ будет конечным ограничителем. В ином случае, сам указанный символ будет
как начальным, так и конечным ограничителем.

=begin programlisting

    my $quote     = B<qq{>"Ouch", he said.  "That I<hurt>!"B<}>;
    my $reminder  =  B<q^>Don't escape the single quote!B<^>;
    my $complaint =  B<q{>It's too early to be awake.B<}>;

=end programlisting

X<heredocs>
X<strings; heredocs>

Если объявление сложной строки, содержащей последовательность экранированных
символов, слишком утомительно, используйте синтаксис I<heredoc> (встроенных
документов) для присвоения строке одной или нескольких строчек текста:

=begin programlisting

    my $blurb =<<'END_BLURB';

    He looked up. "Time is never on our side, my child.
    Do you see the irony? All they know is change.
    Change is the constant on which they all can agree.
    We instead, born out of time, remain perfect and
    perfectly self-aware. We only suffer change as we
    pursue it. It is against our nature. We rebel
    against that change. Shall we consider them
    greater for it?"
    END_BLURB

=end programlisting

Синтаксис C<< <<'END_BLURB' >> имеет три части. Двойные угловые скобки
открывают встроенный документ. Кавычки определяют, будет ли он проявлять
поведение одиночных или двойных кавычек. Поведение по умолчанию E<mdash>
интерполяция двойных кавычек. C<END_BLURB> E<mdash> произвольный идентификатор,
который парсер Perl 5 использует как конечный ограничитель.

Будьте внимательны E<mdash> независимо от отступа самого объявления встроенного
документа, конечный ограничитель I<должен> быть расположен в начале строки:

=begin programlisting

    sub some_function {
        my $ingredients =<<'END_INGREDIENTS';
        Two eggs
        One cup flour
        Two ounces butter
        One-quarter teaspoon salt
        One cup milk
        One drop vanilla
        Season to taste
    END_INGREDIENTS
    }

=end programlisting

=begin sidebar

Если идентификатор начинается с пробельных символов, те же самые пробельные
символы должны присутствовать перед конечным ограничителем. Тем не менее, если
вы сделаете отступ у идентификатора, Perl 5 I<не будет> удалять соответствующие
пробелы из начала каждой строки встроенного документа.

=end sidebar

Использование строки в нестроковом контексте приведёт к приведению типа
(L<coercion>).

=head2 Юникод и строки

Z<unicode>
X<Unicode>

I<Юникод> E<mdash> это система представления символов письменных языков мира. В
то время как большая часть английского текста использует набор символов,
состоящий всего из 127 символов (что требует для хранения семи битов и
замечательно вписывается в восьмибитовый байт), наивно предполагать, что вам
рано или поздно не понадобится умляут.

Строки в Perl 5 могут представлять один из двух отдельных, но связанных
типов данных:

X<codepoint>

=over 4

=item Последовательности символов Юникод

Каждый символ имеет I<код>, уникальное число, которое идентифицирует его в
таблице символов Юникод.

=item Последовательность октетов

X<octet>

Двоичные данные E<mdash> это последовательность I<октетов>, восьмибитовых чисел,
каждое из которых может представлять число от 0 до 255.

=back

=begin tip Слова имеют значение

Почему I<octet> а не I<байт>? Предположение, что один символ помещается в один
байт, принесёт вам бесконечную юникодовую скорбь. Разделяйте идеи хранения в
памяти и представления символов.

=end tip

Юникодовые строки и двоичные строки выглядят похоже. Каждая имеет длину
(C<length()>). Каждая поддерживает стандартные строковые операции, такие как
конкатенация, работа с подстроками и обработка регулярными выражениями. Любая
строка, не являющаяся чистыми двоичными данными, есть текстовые данные, и должна
быть представлена последовательностью символов Юникод.

Однако, из-за того, как ваша операционная система представляет данные на диске,
или полученные от пользователей, или передаваемые по сети E<mdash> как
последовательность октетов E<mdash> Perl не может знать, являются ли читаемые
вами данные файлом изображения, или текстовым документом, или чем-нибудь ещё. По
умолчанию Perl воспринимает все входящие данные как последовательность октетов.
Вы должны наделить эти данные конкретным значением.

=head3 Кодировки символов

X<encoding>
X<Unicode; encoding>
X<UTF-8>
X<ASCII>
X<Latin-1>

Строка Юникод E<mdash> это последовательность октетов, которая представляет
последовательность символов. I<Кодировка Юникод> устанавливает соответствие
последовательностей октетов символам. Некоторые кодировки, такие как UTF-8,
могут кодировать все символы из набора символов Юникод. Другие кодировки
представляют его подмножество. Например, ASCII кодирует простой английский текст
без диакритических символов, тогда как Latin-1 может представлять текст на
большинстве языков, использующих латинский алфавит.

Чтобы избежать большинства проблем с Юникодом, всегда используйте соответствующие
кодировки для декодирования входных и выходных данных вашей программы.

=begin tip Развивающийся стандарт

Perl 5.12 поддерживает стандарт Юникод 5.2, тогда как Perl 5.14 поддерживает
Юникод 6.0. Если вам нужно заботиться о различиях между версиями Юникод, вы,
вероятно, уже знаете, что нужно смотреть на U<http://unicode.org/versions/>.

=end tip

=head3 Юникод в ваших дескрипторах файлов

X<C<open>>
X<builtins; C<open>>
X<IO layers>

Если вы скажете Perl, что определённый дескриптор файла (L<files>) работает с
кодированным текстом, Perl будет конвертировать входящие октеты в строки Юникод
автоматически. Чтобы это сделать, добавьте слой ввода-вывода к режиму встроенной
функции C<open>. I<Слой ввода-вывода> оборачивается вокруг входа и выхода и
конвертирует данные. В данном случае, слой C<:utf8> декодирует данные в UTF-8:

=begin programlisting

    use autodie;

    open my $fh, '<:utf8', $textfile;

    my $unicode_string = <$fh>;

=end programlisting

X<C<binmode>>
X<builtins; C<binmode>>

Также вы можете модифицировать существующий дескриптор файла с помощью
C<binmode>, как для ввода, так и для вывода:

=begin programlisting

    binmode $fh, ':utf8';
    my $unicode_string = <$fh>;

    binmode STDOUT, ':utf8';
    say $unicode_string;

=end programlisting

Без режима C<utf8> печать строк Юникод в дескриптор файла приведёт к
предупреждению (C<Wide character in %s>), потому что файлы содержат октеты, а не
символы Юникод.

=head3 Юникод в ваших данных

X<C<Encode>>
X<C<decode()>>
X<C<encode()>>

Базовый модуль C<Encode> предоставляет функцию, называемую C<decode()>, для
конвертации скаляра, содержащего данные, в строку Юникод. Соответствующая
функция C<encode()> конвертирует из внутренней кодировки Perl в желаемую
выходную кодировку:

=begin programlisting

    my $from_utf8 = decode('utf8', $data);
    my $to_latin1 = encode('iso-8859-1', $string);

=end programlisting

=head3 Юникод в ваших программах

X<pragmas; C<utf8>>
X<C<utf8> pragma>
X<encoding>

Вы можете включать символы Юникод в ваши программы тремя способами. Самый
простой E<mdash> использовать прагму C<utf8> (L<pragmas>), которая указывает
парсеру Perl интерпретировать остальную часть файла исходного кода как имеющую
кодировку UTF-8. Это позволяет вам использовать символы Юникод в строках и
идентификаторах:

=begin programlisting

    use utf8;

    sub E<pound>_to_E<yen> { ... }

    my $yen = E<pound>_to_E<yen>('1000E<pound>');

=end programlisting

Чтобы I<писать> такой код, ваш текстовый редактор должен понимать UTF-8, а вы
должны сохранить файл в соответствующей кодировке.

X<strings; C<\x{}>>
X<C<\x{}>; escape sequence for character encodings>

Внутри строк в двойных кавычках вы можете использовать экранированные
последовательности Юникод для представления кодировок символов. Синтаксис C<\x{}>
представляет один символ; поместите в фигурных скобках шестнадцатиричную форму
номера символа в Юникод:

=begin programlisting

    my $escaped_thorn = "\x{00FE}";

=end programlisting

X<C<charnames> pragma>
X<pragmas; C<charnames>>
X<strings; C<\N{}>>
X<C<\N{}>; escape sequence for named character encodings>

Некоторые символы Юникод имеют имена, и эти имена зачастую проще читать, чем
номера Юникод. Используйте прагму C<charnames> для того, чтобы их включить, и
C<\N{}>, чтобы на них ссылаться:

=begin programlisting

    use charnames ':full';
    use Test::More tests => 1;

    my $escaped_thorn = "\x{00FE}";
    my $named_thorn   = "\N{LATIN SMALL LETTER THORN}";

    is $escaped_thorn, $named_thorn,
        'Thorn equivalence check';

=end programlisting

Вы можете использовать формы C<\x{}> и C<\N{}> в регулярных выражениях, так же
как и в любых местах, где допустимо использовать строку или символ.

=head3 Неявная конвертация

Большинство проблем Юникод в Perl проистекают из того факта, что строка может
быть или последовательностью октетов, или последовательностью символов. Perl
позволяет вам комбинировать эти типы посредством неявных конвертаций. Когда эти
конвертации неверны, они редко I<очевидно> неверны.

Когда Perl конкатенирует последовательность октетов с последовательностью
символов Юникод, он неявно декодирует последовательность октетов, используя
кодировку Latin-1. Результирующая строка будет содержать символы Юникод. Когда
вы печатаете символы Юникод, Perl кодирует строку, используя UTF-8, потому что
Latin-1 не может отображать весть набор символов Юникод: Latin-1
E<mdash> подмножество UTF-8.

Эта асимметрия может привести к строкам Юникод, закодированным как UTF-8 для
вывода и декодированным как Latin-1 на вводе.

Хуже того, если текст содержит только английские символы без знаков диакритики,
то ошибка скрывается E<mdash> потому что обе кодировки одинаково отображают
каждый символ.

=begin programlisting

    my $hello    = "Hello, ";
    my $greeting = $hello . $name;

=end programlisting

Если C<$name> содержит английское имя, такое как I<Alice>, вы никогда не
заметите никаких проблем, потому что представление Latin-1 точно такое же, как
представление UTF-8. Если C<$name> содержит такое имя, как I<JosE<eacute>>,
C<$name> может содержать несколько возможных значений:

=over 4

=item *

C<$name> содержит четыре символа Юникод.

=item *

C<$name> содержит четыре октета Latin-1, представляющих четыре символа Юникод.

=item *

C<$name> содержит пять октетов UTF-8, представляющих четыре символа Юникод.

=back

Строковый литерал имеет несколько возможных сценариев:

=over 4

=item * Это строковый литерал ASCII, содержащий октеты.

=begin programlisting

    my $hello = "Hello, ";

=end programlisting

=item * Это строковый литерал Latin-1 без определённой кодировки, содержащий
октеты.

=begin programlisting

    my $hello = "E<iexcl>Hola, ";

=end programlisting

Строковый литерал содержит октеты.

=item * Это строковый литерал не-ASCII с действующей прагмой C<utf8> или
C<encoding>, содержащий символы Юникод.

=begin programlisting

    use utf8;
    my $hello = "KuirabE<aacute>, ";

=end programlisting

=back

Если и C<$hello>, и C<$name> E<mdash> строки Юникод, конкатенация порождает
другую строку Юникод.

Если обе строки E<mdash> потоки октетов, Perl конкатенирует их в новую строку,
содержащую октеты. Если оба значения E<mdash> октеты с одной и той же
кодировкой, например, оба E<mdash> Latin-1, конкатенация сработает корректно.
Если же октеты имеют разную кодировку, например, конкатенация добавляет данные
в UTF-8 к данным в Latin-1, то результирующая последовательность октетов не
будет иметь смысла I<ни в какой> из кодировок. Это может случиться, если
пользователь ввёл имя как данные UTF-8, а приветствие было строковым литералом
Latin-1, но программа не декодировала ни то, ни другое.

Если только одно из значений E<mdash> строка Юникод, Perl будет декодировать
другое как данные Latin-1. Если это не корректная кодировка, результирующие
символы Юникод будут неверными. Например, если пользовательский ввод был данными
в UTF-8, а строковый литерал был строкой Юникод, имя было бы некорректно
декодировано в пять символов Юникод в виде I<JosE<Atilde>E<copy>> (I<именно!>)
вместо I<JosE<eacute>>, потому что данные UTF-8 означают что-то совсем другое,
когда декодируются как данные Latin-1.

Смотрите C<perldoc perluniintro> для получения намного более детального
объяснения Юникод, кодировок, и того, как управлять входящими и исходящими данными
в мире ЮникодN<Для I<ещё> больших подробностей на тему эффективного управления
Юникодом в ваших программах, смотрите ответ Тома Кристиансена (Tom Christiansen)
на вопрос E<laquo>Почему Современный Perl избегает UTF-8 по умолчанию?E<raquo>
U<http://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default/6163129#6163129>>.

=begin sidebar

X<C<unicode_strings>>
X<pragmas; C<feature>>

В Perl 5.12 была добавлена возможность, C<unicode_strings>, которая активирует
семантику Юникод для всех строковых операций в своей области видимости. Perl
5.14 улучшил эту возможность; если вы работаете с Юникодом в Perl, стоит
обновиться хотя бы до Perl 5.14.

=end sidebar

=head2 Числа

X<numbers>
X<integers>
X<floating-point values>

Perl поддерживает числа в виде как целых значений, так и значений с плавающей точкой.
Вы можете выражать их в научной нотации, так же как в двоичной, восьмеричной и
шестнадцатиричной формах:

=begin programlisting

    my $integer   = 42;
    my $float     = 0.007;
    my $sci_float = 1.02e14;
    my $binary    = B<0b>101010;
    my $octal     = B<0>52;
    my $hex       = B<0x>20;

=end programlisting

X<numbers; representation prefixes>
X<C<0b>>
X<C<0>>
X<C<0x>>

Выделенные жирным символы E<mdash> числовые префиксы для двоичной, восьмеричной
и шестнадцатиричной нотации соответственно. Имейте ввиду, что ведущий ноль в
целом числе I<всегда> означает восьмеричный режим.

X<numbers; underscore separator>
X<underscore>

=begin tip Когда 1.99 + 1.99 = 4

Хотя в Perl 5 вы и можете явно записывать значения с плавающей точкой с
совершенной точностью, Perl 5 внутренне хранит их в двоичном формате. Это
представление иногда неточно специфическим образом; проконсультируйтесь с
C<perldoc perlnumber> для больших деталей.

=end tip

Вы не можете использовать запятые для отделения тысяч в числовых литералах,
потому что парсер сочтёт запятую оператором запятой. Вместо этого
используйте в числах подчёркивания. Парсер будет будет воспринимать их как
невидимые символы; ваши читатели, возможно, нет. Эти записи равнозначны:

=begin programlisting

    my $billion = 1000000000;
    my $billion = 1_000_000_000;
    my $billion = 10_0_00_00_0_0_0;

=end programlisting

Подумайте, какой вариант наиболее читабелен.

X<C<Scalar::Util>>
X<C<looks_like_number()>>

Из-за приведения типа (L<coercion>), Perl-программистам редко приходится
беспокоиться о конвертации текста, прочитанного из-за пределов программы, в
числа. Perl будет обращаться со всем, что выглядит как число, I<как> с числом
в числовом контексте. В редких ситуациях, когда вам нужно знать, выглядит ли
нечто как число для Perl, используйте функцию C<looks_like_number> из
базового модуля C<Scalar::Util>. Эта функция возвращает истину, если Perl
будет считать переданный аргумент числовым.

X<C<Regexp::Common>>

Модуль C<Regexp::Common> из CPAN предоставляет несколько хорошо протестированных
регулярных выражений для определения более конкретных допустимых I<типов>
числовых значений (целое число, целое значение, значение с плавающей точкой).

=head2 Undef

X<C<undef>>

Значение C<undef> в Perl 5 представляет собой неприсвоенное, неопределённое и
неизвестное значение. Объявленные, но не определённые скалярные переменные
всегда содержат C<undef>:

=begin programlisting

    my $name = undef;   # необязательное присваивание
    my $rank;           # тоже содержит undef

=end programlisting

X<C<undef>; coercions>

C<undef> даёт ложь в булевом контексте. Использование C<undef> в строковом
контексте E<mdash> например, интерполяция его в строке, E<mdash> генерирует
предупреждение C<uninitialized value>:

=begin programlisting

    my $undefined;
    my $defined = $undefined . '... and so forth';

=end programlisting

E<hellip>выдаёт:

=begin screen

    Use of uninitialized value $undefined in
    concatenation (.) or string...

=end screen

X<builtins; C<defined>>

Встроенная функция C<defined> возвращает истинное значение, если её операнд
является определённым значением (любым отличным от C<undef>):

=begin programlisting

    my $status = 'suffering from a cold';

    say B<defined> $status;  # 1, истинное значение
    say B<defined> undef;    # пустая строка, ложное значение

=end programlisting

=head2 Пустой список

X<empty list>
X<C<()>; empty list>

При использовании справа от присваивания, конструкция C<()> обозначает пустой
список. В скалярном контексте он вычисляется в C<undef>. В списочном контексте
это пустой список. При использовании слева от присваивания, конструкция C<()>
налагает списочный контекст. Для подсчёта количества элементов, возвращаемых
выражением в списочном контексте, без использования временной переменной,
используйте следующую идиому (L<idioms>):

=begin programlisting

    my $count = B<()> = get_all_clown_hats();

=end programlisting

Из-за правой ассоциативности (L<associativity>) оператора присваивания, Perl
сначала вычисляет второе присваивание, вызывая C<get_all_clown_hats()> в списочном
контексте. Это генерирует список.

Присваивание пустому списоку отбрасывает все значения из списка, но это
присваивание происходит в скалярном контексте, что выдаёт количество элементов
на правой стороне присваивания. В результате C<$count> содержит количество
элементов в списке, возвращаемом C<get_all_clown_hats()>.

Если сейчас эта концепция кажется вам сбивающей с толку, не бойтесь. Когда вы
поймёте, как фундаментальные особенности дизайна Perl взаимодействуют на
практике, это будет иметь больше смысла.

=head2 Списки

X<lists>

Список E<mdash> это разделённая запятыми группа из одного или более выражений.
Списки могут появляться в исходном коде буквально как значения:

=begin programlisting

    my @first_fibs = (1, 1, 2, 3, 5, 8, 13, 21);

=end programlisting

E<hellip>как цели присваивания:

=begin programlisting

    my ($package, $filename, $line) = caller();

=end programlisting

E<hellip>или списки выражений:

=begin programlisting

    say name(), ' => ', age();

=end programlisting

Скобки не I<создают> списки. Списки создаёт оператор запятая. Скобки, там, где
они присутствуют в этих примерах, группируют выражения для изменения их
I<приоритета> (L<precedence>).

X<operators; range>
X<operators; C<..>>
X<C<..>; range operator>

Используйте оператор диапазона для создания списков литералов в компактной
форме:

=begin programlisting

    my @chars = 'a' .. 'z';
    my @count = 13 .. 27;

=end programlisting

X<operators; C<qw()>>
X<C<qw()>; quote words operator>

Используйте оператор C<qw()> чтобы разбить литеральную строку по пробелам и
получить список строк:

=begin programlisting

    my @stooges = qw( Larry Curly Moe Shemp Joey Kenny );

=end programlisting

=begin tip Без комментариев, пожалуйста

Perl покажет предупреждение, если C<qw()> содержит запятую или символ
комментария (C<#>), потому что такие символы не только редки в C<qw()>, но их
присутствие обычно указывает на недосмотр.

=end tip

Списки могут (и это часто происходит) быть результатами выражений, но эти списки
не появляются буквально в исходном коде.

Списки и массивы в Perl не взаимозаменяемы. Списки E<mdash> это значения.
Массивы E<mdash> это контейнеры. Вы можете сохранить список в массиве или
преобразовать массив в список, но это разные сущности. Например, индексация
в списке всегда происходит в списочном контексте. Индексация в массиве может
происходить в скалярном контексте (для единственного элемента) или списочном
контексте (для среза):

=begin programlisting

    # пока не беспокойтесь о деталях
    sub context
    {
        my $context = wantarray();

        say defined $context
             ? $context
                 ? 'list'
                 : 'scalar'
             : 'void';
        return 0;
    }

    my @list_slice  = (1, 2, 3)[context()];
    my @array_slice = @list_slice[context()];
    my $array_index = $array_slice[context()];

    say context(); # списочный контекст
    context();     # пустой контекст

=end programlisting
