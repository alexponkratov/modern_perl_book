=encoding utf-8

=head1 Файлы

Z<files>

Большинству программ нужно как-то взаимодействовать с реальным миром.
Большинству программ нужно писать, читать или другими способами манипулировать с
файлами. Происхождение Perl как инструмента для системных администраторов
привело к созданию языка, отлично подходящего для обработки текста.

=head2 Ввод и вывод

Z<filehandle>
X<filehandles>
X<filehandles; C<STDIN>>
X<filehandles; C<STDERR>>
X<filehandles; C<STDOUT>>
X<C<STDIN>>
X<C<STDERR>>
X<C<STDOUT>>

I<Дескриптор файла> представляет текущее состояние одного конкретного канала ввода или
вывода. В каждой программе на Perl доступны три стандартных дескриптора файлов,
C<STDIN> (ввод программы), C<STDOUT> (вывод программы) и C<STDERR> (вывод ошибок
программы). По умолчанию всё, что вы выводите с помощью C<print> или C<say>,
отправляется на C<STDOUT>, тогда как ошибки, предупреждения и всё, что вы выводите с
помощью C<warn()>, отправляется на C<STDERR>. Такое разделение вывода позволяет
вам перенаправить полезный вывод и ошибки в два разных места E<mdash> например, в
выходной файл и лог ошибок.

X<builtins; C<open>>

Используйте встроенную функцию C<open> для получения дескриптора файла. Так
файл открывается для чтения:

=begin programlisting

    open my $fh, '<', 'filename'
        or die "Cannot read '$filename': $!\n";

=end programlisting

Первый операнд E<mdash> это лексическая переменная, которая будет содержать
результирующий дескриптор файла. Второй оператор E<mdash> I<режим файла>,
определяющий тип операций с дескриптором файла. Последний операнд E<mdash> это
имя файла. Если C<open> провалится, оператор C<die> выбросит исключение, с
содержимым C<$!>, описывающим причину, по которой открытие файла не удалось.

Кроме этого, вы можете открывать файлы для записи, добавления, чтения и записи
и т. д. Здесь перечислены наиболее важные режимы файлов:

=begin table Режимы файлов

Z<file_modes_table>

=headrow

=cell B<Символ>

=cell B<Описание>

=bodyrows

=row

=cell C<< < >>

=cell Открыть для чтения

=row

=cell C<< > >>

=cell Открыть для записи, перезаписывая существующее содержимое, если файл
существует, и создавая новый файл в противном случае.

=row

=cell C<<< >> >>>

=cell Открыть для записи, добавляя к существующему контенту или создавая новый
файл.

=row

=cell C<< +< >>

=cell Открыть для чтения и записи.

=row

=cell C<< -| >>

=cell Открыть канал к внешнему процессу для чтения.

=row

=cell C<< |- >>

=cell Открыть канал к внешнему процессу для записи.

=end table

Вы даже можете создавать дескрипторы файлов, который могут читать или писать в
простые скаляры Perl, используя любой существующий режим файла:

=begin programlisting

    open my $read_fh,  '<', \$fake_input;
    open my $write_fh, '>', \$captured_output;

    do_something_awesome( $read_fh, $write_fh );

=end programlisting

=begin tip Помните C<autodie>?

Все примеры в этом разделе имеют включенный режим C<use autodie;>, а потому
могут безопасно игнорировать обработку ошибок. Если вы выбрали не использовать
C<autodie>, хорошо E<mdash> но не забудьте проверить возвращаемые значения всех
системных вызовов, чтобы соответствующим образом обработать ошибки.

=end tip

X<builtins; C<sysopen>>

C<perldoc perlopentut> предлагает гораздо больше деталей о более экзотических
применениях C<open>, включая её способность запускать и контролировать другие
процессы, а также использование C<sysopen> для более точного контроля ввода и
вывода. C<perldoc perlfaq5> приводит рабочий код для многих задач ввода/вывода.

=head3 Двухаргументный вызов C<open>

Старый код часто использует двухаргументную форму C<open()>, которая объединяет
режим файла с именем открываемого файла:

=begin programlisting

    open my $fh, B<< "> $some_file" >>
        or die "Cannot write to '$some_file': $!\n";

=end programlisting

Соответственно, Perl должен извлечь режим файла из имени файла, и здесь лежат
потенциальные проблемы. Каждый раз, когда Perl приходится догадываться, что вы
имеете ввиду, вы получаете риск того, что он может догадаться неверно. Хуже
того, если C<$some_file> приходит из недоверенного пользовательского ввода, у
вас возникает потенциальная проблема безопасности, так как любые неожиданные
символы могут изменить поведение вашей программы.

Трёхаргументный вызов C<open()> E<mdash> более безопасная замена для этого кода.

=begin tip Многие имена C<DATA>

X<C<DATA>>
X<C<__DATA__>>
X<C<__END__>>

Дескриптор файла C<DATA>, специальная глобальная переменная пакета, представляет текущий
файл. Когда Perl заканчивает компиляцию файла, он оставляет C<DATA> открытым на
конце компилируемой части, I<если> файл содержит секцию C<__DATA__> или
C<__END__>. Любой текст, находящийся за пределами этого токена, доступен для
чтения через C<DATA>. Это полезно для коротких, самодостаточных программ. См.
C<perldoc perldata> для дальнейших подробностей.

=end tip

=head3 Чтение из файлов

X<builtins; C<readline>>
X<<< C<< <> >>; circumfix readline operator >>>
X<<< operators; C<< <> >> >>>

Имея открытый для ввода дескриптор файла, прочитать из него можно с помощью
встроенной функции C<readline>, также записываемой как C<< <> >>.
Распространённая идиома читает по строке за раз в цикле C<while()>:

=begin programlisting

    open my $fh, '<', 'some_file';

    while (<$fh>)
    {
        chomp;
        say "Read a line '$_'";
    }

=end programlisting

X<builtins; C<eof>>

В скалярном контексте C<readline> итерирует по строкам файла, пока не достигнет
его конца (C<eof()>). Каждая итерация возвращает следующую строку. После
достижения конца файла, каждая итерация возвращает C<undef>. Эта идиома с
C<while> явно проверяет определённость переменной, используемой для итерации,
так что только достижение конца файла завершит цикл. Другими словами, это
сокращение для следующего:

=begin programlisting

    open my $fh, '<', 'some_file';

    while (defined($_ = <$fh>))
    {
        chomp;
        say "Read a line '$_'";
        last if eof $fh;
    }

=end programlisting

=begin tip Почему использовать C<while>, а не C<for>?

C<for> налагает списочный контекст на свой операнд. В случае C<readline> Perl
прочитает I<весь> файл, прежде чем обработать I<какую-либо> его часть. C<while>
выполняет итерацию и читает по строке за раз. Когда использование памяти имеет
значение, используйте C<while>.

=end tip

X<builtins; C<chomp>>

Каждая строка, прочитанная с помощью C<readline>, содержит символ или символы,
отмечающие конец строки. В большинстве случаев это платформозависимая
последовательность, состоящая из перевода строки (C<\n>), возврата каретки
(C<\r>), или сочетания их обоих (C<\r\n>). Используйте C<chomp> для их удаления.

Наиболее ясный способ прочитать файл строка за строкой в Perl 5 такой:

=begin programlisting

    open my $fh, '<', $filename;

    while (my $line = <$fh>)
    {
        chomp $line;
        ...
    }

=end programlisting

X<builtins; C<binmode>>

Perl по умолчанию работает с файлами в текстовом режиме. Если вы читатете
I<двоичные> данные, такие как медиафайл или сжатый файл E<mdash> используйте
C<binmode> прежде чем выполнять какой-либо ввод/вывод. Это укажет Perl
обрабатывать данные файла как чистые данные, никаким образом их не
модифицируяN<Модификации включают перевод C<\n> в платформозависимую
последовательность новой строки.>. Хотя на Unix-подобных платформах C<binmode>
может быть не всегда I<обязателен>, переносимые программы играют наверняка
(L<unicode>).

=head3 Запись в файлы

X<builtins; C<print>>
X<builtins; C<say>>

Имея открытый для вывода дескриптор файла, осуществляйте вывод в него с помощью
C<print> или C<say>:

=begin programlisting

    open my $out_fh, '>', 'output_file.txt';

    print $out_fh "Here's a line of text\n";
    say   $out_fh "... and here's another";

=end programlisting

Обратите внимание на отсутствие запятой между дескриптором файла и следующим
операндом.

=begin tip Неоднозначность дескрипторов файлов

X<Conway, Damian>

I<Perl Best Practices> Демьена Конвея (Damian Conway) рекомендует придерживаться
привычки заключать дескриптор файла в фигурные скобки. Это необходимо для
устранения неоднозначности парсинга дескриптора файла, содержащегося в
агрегатной переменной, и ничему не повредит в более простых случаях.

=end tip

X<C<$,>>
X<global variables; C<$,>>
X<C<$\>>
X<global variables; C<$\>>

И C<print>, и C<say> принимают список операндов. Perl 5 использует магическую
глобальную переменную C<$,> как разделитель значений списка. Perl также
использует любое значение C<$\> как последний аргумент C<print> или C<say>.
Так что эти две строки кода дают один и тот же результат:

=begin programlisting

    my @princes = qw( Corwin Eric Random ... );

    print @princes;
    print join( $,, @princes ) . $\;

=end programlisting

=head3 Закрытие файлов

X<builtins; C<close>>

Когда вы закончили работать с файлом, закройте его дескриптор явно с помощью
C<close>, или дайте ему выйти из области видимости. Perl закроет его для вас.
Преимущество явного вызова C<close> в том, что вы можете проверить E<mdash> и
восстановиться после них E<mdash> специфические ошибки, такие как недостаток
места на устройстве хранения или разорванное сетевое соединение.

Как обычно, C<autodie> выполнит эти проверки за вас:

=begin programlisting

    use autodie;

    open my $fh, '>', $file;

    ...

    close $fh;

=end programlisting

=head3 Специальные переменные обработки файлов

Z<file_handling_variables>
X<C<$.>>
X<global variables; C<$.>>

Для каждой прочитанной строки Perl 5 инкрементирует значение переменной C<$.>,
которая служит счётчиком строк.

X<C<$/>>
X<global variables; C<$/>>

C<readline> использует текущее содержимое C<$/> как последовательность
завершения строки. По умолчанию значение этой переменной содержит
последовательность символов завершения строки, наиболее подходяющую для текстовых файлов на
текущей платформе. По правде говоря, слово I<строка> E<mdash> неправильное
название. Вы можете установить в C<$/> любую последовательность
символовN<E<hellip>но, к сожалению, не регулярное выражение. Perl 5 этого не
поддерживает.>. Это полезно для сильно структурированных данных, в которых вы
хотите считывать I<запись> за раз. Имея файл с записями, разделёнными двумя
пустыми строками, установите C<$/> в C<\n\n> для чтения по записи за раз.
Применение C<chomp> к прочитанной из файла записи удалит последовательность
двойного перевода строки.

X<C<$|>>
X<global variables; C<$|>>
X<buffering>

Perl по умолчанию I<буферизует> свой вывод, выполняя ввод/вывод только когда
ожидающий вывод превышает порог по размеру. Это позволяет Perl группировать дорогие
операции ввода/вывода вместо того, чтобы всегда записывать очень малые
количества данных. Однако иногда вам нужно отправить данные как только вы их
получаете, не ожидая буферизации E<mdash> особенно если вы пишете фильтр для
командной строки, соединённый с другими программами, или строко-ориентированный
сетевой сервис.

Переменная C<$|> контролирует буферизацию на текущем активном файловом
дескрипторе вывода. При установке ненулевого значения Perl будет сбрасывать
вывод после каждой записи в дескриптор файла. При установке нулевого значения
Perl будет использовать свою стратегию буферизации по умолчанию.

=begin tip Автоматический сброс

Для файлов по умолчанию действует стратегия полной буферизации. C<STDOUT>,
присоединённый к активному терминалу E<mdasy> но I<не> к другой программе
E<mdash> использует стратегию построчной буферизации, при которой Perl будет
сбрасывать C<STDOUT> каждый раз, как встретит в выводе перевод строки.

=end tip

X<C<autoflush()>>
X<C<IO::File>; C<autoflush()>>

Вместо глобальной переменной, используйте на лексическом дескрипторе файла
метод C<autoflush()>:

=begin programlisting

    open my $fh, '>', 'pecan.log';
    $fh->autoflush( 1 );

    ...

=end programlisting

X<C<IO::File>>
X<C<FileHandle>>

Начиная с Perl 5.14, вы можете использовать на дескрипторе файла любые методы,
предоставляемые C<IO::File>. Вам не требуется явно загружать C<IO::File>. В
Perl 5.12 вы должны сами загрузить C<IO::File>. В Perl 5.10 и раньше вы должны
вместо этого загрузить C<FileHandle>.

X<C<IO::File>; C<input_line_number()>>
X<C<IO::File>; C<input_record_separator()>>
X<C<IO::Handle>>
X<C<IO::Seekable>; C<seek()>>

Методы C<IO::File> C<input_line_number()> и C<input_record_separator()>
обеспечивают пофайловый доступ к тому, для чего обычно вам пришлось бы
использовать глобальные C<$.> и C<$/>. Смотрите документацию по C<IO::File>,
C<IO::Handle> и C<IO::Seekable> для большей информации.

=head2 Директории и пути

X<builtins; C<opendir>>

Работа с директориями похожа на работу с файлами, за исключением того, что вы
не можете I<писать> в директорииN<Вместо этого вы сохраняете, перемещаете,
переименовываете и удаляете файлы.>. Открыть дескриптор директории можно с
помощью встроенной функции C<opendir>:

=begin programlisting

    opendir my $dirh, '/home/monkeytamer/tasks/';

=end programlisting

X<builtins; C<readdir>>

Встроенная функция C<readdir> читает из директории. Как и с C<readline>, вы
можете выполнить итерацию по содержимому директории по одному элементу за раз,
или вы можете присвоить их списку сразу:

=begin programlisting

    # итерация
    while (my $file = readdir $dirh)
    {
        ...
    }

    # разглаживание в список
    my @files = readdir $otherdirh;

=end programlisting

Perl 5.12 добавил возможность, благодаря которой C<readdir> в C<while>
устанавливает C<$_>:

=begin programlisting

    use 5.012;

    opendir my $dirh, 'tasks/circus/';

    while (readdir $dirh)
    {
        next if /^\./;
        say "Found a task $_!";
    }

=end programlisting

X<Unix>
X<files; hidden>

Любопытное регулярное выражение в этом примере пропускает так называемые
I<скрытые файлы> в Unix и Unix-подобных системах, где ведущая точка предотвращает
появление их в листинге директории по умолчанию. Оно также пропускает два
специальных файла C<.> и C<..>, которые представляют текущую директорию и
родительскую директорию соответственно.

X<files; relative paths>
X<files; absolute paths>

Имена, возвращаемые из C<readdir>, I<относительны> к самой директории. Другими
словами, если директория F<tasks/> содержит три файла, F<eat>, F<drink> и
F<be_monkey>, C<readdir> вернёт C<eat>, C<drink> и C<be_monkey>, а I<не>
F<tasks/eat>, F<tasks/drink> и F<task/be_monkey>. Напротив, I<абсолютный> путь
E<mdash> это путь, полностью определённый в файловой системе.

X<builtins; C<closedir>>

Закройте дескриптор директории, позволив ему выйти за пределы области видимости,
или с помощью встроенной функции C<closedir>.

=head3 Манипулирование путями

Perl 5 предлагает взгляд в стиле Unix на вашу файловую систему и будет интерпретировать
пути в стиле Unix соответствующим образом для вашей операционной системы и
файловой системы. Другими словами, если вы используете Microsoft Windows, вы
можете использовать путь F<C:/My Documents/Robots/Bender/> так же легко, как
F<C:\My Documents\Robots\Caprica Six\>.

X<C<File::Spec>>

Хотя операциями Perl и управляет семантика файлов Unix, кросс-платформенные
манипуляции файлами намного легче осуществлять с помощью модуля. Семейство
базовых модулей C<File::Spec> предоставляет абстракции, позволяющие вам
манипулировать путями к файлам безопасным и переносимым образом. Эти модули
уважаемы и легко понимаемы, хотя и громоздки.

X<CPAN; C<Path::Class>>
X<CPAN; C<Path::Class::Dir>>
X<CPAN; C<Path::Class::File>>

Дистрибутив C<Path::Class> из CPAN предоставляет более приятный интерфейс.
Используйте фукнцию C<dir()> для создания объекта, представляющего директорию,
и функцию C<file()> для создания объекта, представляющего файл:

=begin programlisting

    use Path::Class;

    my $meals = dir( 'tasks', 'cooking' );
    my $file  = file( 'tasks', 'health', 'robots.txt' );

=end programlisting

Вы можете получить объекты файлов из директорий и т. д.:

=begin programlisting

    my $lunch      = $meals->file( 'veggie_calzone' );
    my $robots_dir = $robot_list->dir();

=end programlisting

Вы даже можете отрыть дескрипторы файлов для директорий и файлов:

=begin programlisting

    my $dir_fh    = $dir->open();
    my $robots_fh = $robot_list->open( 'r' )
                        or die "Open failed: $!";

=end programlisting

И C<Path::Class::Dir>, и C<Path::Class::File> предлагают и другие полезные
поведения E<mdash> хотя имейте ввиду, что если вы используете какой-нибудь
объект C<Path::Class> с другим кодом на Perl 5, таким как оператор или функция,
ожидающая строку, содержащую путь к файлу, вам придётся самостоятельно
преобразовать объект в строку. Это постоянное, но небольшое раздражение.

=begin programlisting

    my $contents = read_from_filename( B<">$lunchB<"> );

=end programlisting

=head2 Манипуляции с файлами

X<C<-X>; file test operators>
X<operators; C<-X>>

Помимо чтения и записи файлов, вы также можете манипулировать ими, как делали бы
это напрямую из командной строки или файлового менеджера. Операторы проверки
файлов, все вместе называемые операторы C<-X>, из-за того, что все они
представляют собой дефис и одну букву, проверяют атрибуты файла и директории.
Например, так можно проверить, что файл существует:

X<C<-e>; file exists operator>
X<operators; C<-e>>

=begin programlisting

    say 'Present!' if -e $filename;

=end programlisting

Оператор C<-e> имеет один операнд, имя файла или дескриптор файла или
директории. Если файл существует, выражение вернёт истинное значение.
C<perldoc -f -X> содержит список всех остальных проверок файлов; наиболее
популярны следующие:

X<C<-d>; directory test operator>
X<C<-f>; file test operator>
X<C<-r>; readable file test operator>
X<C<-s>; non-empty file test operator>
X<operators; C<-d>>
X<operators; C<-f>>
X<operators; C<-r>>
X<operators; C<-s>>

=over 4

=item C<-f>, возвращающий истинное значение, если его операнд E<mdash> простой
файл;

=item C<-d>, возвращающий истинное значение, если его операнд E<mdash>
директория;

=item C<-r>, возвращающий истинное значение, если настройка доступа к файлу,
указанному как его операнд, позволяет чтение текущим пользователем;

=item C<-s>, возвращающий истинное значение, если его операнд E<mdash> непустой
файл.

=back

Начиная с Perl 5.10.1, вы можете искать документацию по любому из этих операторов,
например, как C<perldoc -f -r>.

X<builtins; C<rename>>

Встроенная функция C<rename> может переименовать файл или переместить его между
директориями. Они принимает два операнда, старое и новое имя файла:

=begin programlisting

    rename 'death_star.txt', 'carbon_sink.txt';

    # или если вы стильный:
    rename 'death_star.txt' => 'carbon_sink.txt';

=end programlisting

X<C<File::Copy>>
X<builtins; C<unlink>>
X<builtins; C<delete>>
X<files; copying>
X<files; moving>
X<files; removing>
X<files; deleting>

Встроенной функции для копирования файла нет, но базовый модуль C<File::Copy>
предоставляет как фукнцию C<copy()>, так и C<move()>. Используйте встроенную функцию
C<unlink> для удаления одного или нескольких файлов. (Встроенная функция
C<delete> удаляет элемент из хеша, а не файл из файловой системы.) Все эти
функции возвращают истинные значения в случае успеха и устанавливают C<$!> при
ошибке.

=begin tip Лучше чем C<File::Spec>

C<Path::Class> предоставляет удобные методы для проверки некоторых атрибутов
файла, а также для полного удаления файла, в кросс-платформенной манере.

=end tip

X<builtins; C<chdir>>
X<C<Cwd>>
X<C<Cwd>; C<cwd()>>

Perl отслеживает свою текущую рабочую директорию. По умолчанию, это активная
директория, из которой запущена программа. Функция C<cwd()> базового модуля
C<Cwd> возвращает имя текущей рабочей директории. Встроенная функция C<chdir>
пытается сменить текущую рабочую директорию. Работа из корректной директории
важна для работы с файлами с относительными путями.
