=encoding utf-8

=head1 Прототипы

Z<prototypes>

X<prototypes>

I<Прототип> E<mdash> это набор необязательных метаданных, присоединённых к
функции, которые влияют на то, как парсер понимает её аргументы. Хотя внешне
они могут выглядеть как сигнатуры функций в других языках, на самом деле они
очень отличаются.

X<builtins; C<push>>

Прототипы позволяют пользователям определять свои собственные функции, ведущие
себя как встроенные. Рассмотрим встроенную фукнцию C<push>, которая принимает
массив и список. Хотя обычно Perl 5 разгладил бы массив и список в единый
список, переданный в C<push>, парсер знает, что не нужно разглаживать массив, чтобы
C<push> мог модифицировать его на месте.

Прототипы функций являются частью объявления:

=begin programlisting

    sub foo        B<(&@)>;
    sub bar        B<($$)> { ... }
    my  $baz = sub B<(&&)> { ... };

=end programlisting

Любой прототип, привязанный к предварительному объявлению, должен совпадать с
прототипом, привязанным к объявлению функции. Perl выдаст предупреждение, если
это не так. Как ни странно, вы можете опустить прототип в предварительном
объявлении и включить его в полное объявление E<mdash> но делать так нет причин.

X<builtins; C<prototype>>

Встроенная функция C<prototype> принимает имя функции и возвращает строку,
представляющую её прототип. Используйте форму C<CORE::>, чтобы увидеть прототип
встроенной функции:

=begin screen

    $ B<perl -E "say prototype 'CORE::push';">
    \@@
    $ B<perl -E "say prototype 'CORE::keys';">
    \%
    $ B<perl -E "say prototype 'CORE::open';">
    *;$@

=end screen

C<prototype> вернёт C<undef> для тех встроенных функций, которые вы не можете
эмулировать:

=begin screen

    B<say prototype 'CORE::system' // 'undef'>
    # undef; невозможно эмулировать встроенную функцию C<system>

    B<say prototype 'CORE::prototype' // 'undef'>
    # undef; встроенная функция C<prototype> не имеет прототипа

=end screen

Помните C<push>?

=begin screen

    $ B<perl -E "say prototype 'CORE::push';">
    \@@

=end screen

Символ C<@> представляет список. Обратный слеш принуждает к использованию
I<ссылки> для соответствующего аргумента. Этот прототип обозначает, что C<push>
принимает ссылку на массив и список значений. Вы можете написать C<mypush> так:

=begin programlisting

    sub mypush (\@@)
    {
        my ($array, @rest) = @_;
        push @$array, @rest;
    }

=end programlisting

Другие символы прототипов включают C<$> для скалярного аргумента, C<%> для
обозначения хеша (чаще всего используется как ссылка) и C<&> для указания на
блок кода. См. C<perldoc perlsub> для полной документации.

=head2 Проблемы с прототипами

Прототипы изменяют то, как Perl парсит ваш код, и могут вызывать приведение типов
аргументов. Они не документируют количество или типы аргументов, которые функция
ожидает, как и не устанавливают соответствие аргументов именованным параметрам.

Приведение типов при использовании прототипов работает неочевидным образом, как
навязывание скалярного контекста входным аргументам:

=begin programlisting

    sub numeric_equality($$)
    {
        my ($left, $right) = @_;
        return $left == $right;
    }

    my @nums = 1 .. 10;

    say 'They're equal, whatever that means!'
        if numeric_equality @nums, 10;

=end programlisting

E<hellip>но работает только с простыми выражениями:

=begin programlisting

    sub mypush(\@@);

    # ошибка компиляции: несоответствие прототипов
    # (ожидался массив, получено скалярное присваивание)
    mypush( my $elems = [], 1 .. 20 );

=end programlisting

Чтобы отладить это, пользователи C<mypush> должны знать как то, что прототип
существует, так и ограничения прототипов массивов. Хуже того, это I<простые>
ошибки, которые могут вызывать прототипы.

=head2 Хорошее использование прототипов

X<builtins; overriding>
X<pragmas; C<subs>>
X<C<subs> pragma>

Немногие использования прототипов достаточно интересны, чтобы перевесить их
недостатки, но они существуют.

Во-первых, они могут позволить вам переопределить встроенные функции. Сначала
проверьте, что вы I<можете> переопределить встроенную функцию, проверив её
прототип в маленькой тестовой программе. Затем используйте прагму C<subs>, чтобы
сказать Perl, что вы собираетесь переопределить встроенную функцию, и, наконец,
объявите ваше переопределение с корректным прототипом:

=begin programlisting

    use subs 'push';

    sub push (\@@) { ... }

=end programlisting

Имейте ввиду, что прагма C<subs> действует для всей оставшейся части I<файла>,
независимо от лексической области видимости.

X<constants>

Вторая причина использования прототипов E<mdash> это определение констант
времени компиляции. Когда Perl встречает функцию, объявленную с пустым
прототипом (в противоположность I<отсутствию> прототипа), I<и> эта функция
возвращает единственное константное выражение, оптимизатор превратит все вызовы
этой функции в константы вместо вызовов функции:

=begin programlisting

    sub PI () { 4 * atan2(1, 1) }

=end programlisting

Весь последующий код будет использовать вычисленное значение Пи на месте
голого слова C<PI> или вызова C<PI()>, с учётом области видимости.

X<C<constant> pragma>
X<pragmas; C<constant>>
X<CPAN; C<Const::Fast>>

Базовая прагма C<constant> справляется с этими деталями за вас. Модуль
C<Const::Fast> из CPAN создаёт константные скаляры, которые вы можете
интерполировать в строки.

X<CPAN; C<Test::Exception>>
X<CPAN; C<Test::Fatal>>

Разумное использование прототипов E<mdash> это расширение синтаксиса Perl 5 для
оперирования анонимными функциями как блоками. CPAN-модуль C<Test::Exception>
использует это во благо для предоставления приятного API с отложенными
вычислениямиN<См. также C<Test::Fatal>>. Его функция C<throws_ok()> принимает
три аргумента: блок кода для выполнения, регулярное выражение для сравнения со
строкой исключения и необязательное описание теста:

=begin programlisting

    use Test::More tests => 1;
    use Test::Exception;

    throws_ok
        { my $unobject; $unobject->yoink() }
        qr/Can't call method "yoink" on an undefined/,
        'Method on undefined invocant should fail';

=end programlisting

Экспортируемая функция C<throws_ok()> имеет протоип C<&$;$>. Его первый аргумент
E<mdash> это блок, который становится анонимной функцией. Второй аргумент
E<mdash> скаляр. Третий аргумент не обязателен.

Внимательные читатели, возможно, заметили отсутствие запятой после блока. Это
причуда парсера Perl 5, который ожидает после прототипированного блока пробел,
а не оператор запятой. Это недостаток синтаксиса прототипов.

Вы можете использовать C<throws_ok()>, не пользуясь прототипами:

=begin programlisting

    use Test::More tests => 1;
    use Test::Exception;

    throws_okB<(>
        B<sub> { my $unobject; $unobject->yoink() }B<,>
        qr/Can't call method "yoink" on an undefined/,
        'Method on undefined invocant should fail' B<)>;

=end programlisting

X<builtins; C<sort>>

Последнее хорошее применение прототипов E<mdash> при определении произвольной
именованной функции для использования с C<sort>N<Бен Тилли (Ben Tilly)
предложил этот пример.>:

=begin programlisting

    sub length_sort ($$)
    {
        my ($left, $right) = @_;
        return length($left) <=> length($right);
    }

    my @sorted = sort length_sort @unsorted;

=end programlisting

Прототип C<$$> заставляет Perl передавать сортируемые пары в C<@_>. Документация
C<sort> предполагает, что это немного медленнее, чем использование глобальных
переменных пакета C<$a> и C<$b>, но использование лексических переменных
зачастую оправдывает любое снижение скорости.
