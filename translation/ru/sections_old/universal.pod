=encoding utf-8

=head1 Пакет UNIVERSAL

Z<universal>

X<C<UNIVERSAL>>

Встроенный пакет C<UNIVERSAL> в Perl 5 E<mdash> предок всех остальных пакетов
E<mdash> в объектно-ориентированном смысле (L<moose>). C<UNIVERSAL>
предоставляет несколько методов, которые его потомки могут унаследовать или
переопределить.

=head2 Метод isa()

X<C<UNIVERSAL::isa>>
X<C<isa()>>

Метод C<isa()> принимает строку, содержащую имя класса или имя встроенного типа.
Вызывайте его как метод класса или метод экземпляра на объекте. Он возвращает
истинное значение, если его инвокант является указанным классом или происходит от
него, или если инвокант E<mdash> благословлённая ссылка на заданный тип.

Пусть есть объект C<$pepper> (ссылка на хеш, благословлённая в класс C<Monkey>,
наследующий от класса C<Mammal>), тогда:

=begin programlisting

    say $pepper->isa( 'Monkey'  );  # выводит 1
    say $pepper->isa( 'Mammal'  );  # выводит 1
    say $pepper->isa( 'HASH'    );  # выводит 1
    say Monkey->isa(  'Mammal'  );  # выводит 1

    say $pepper->isa( 'Dolphin' );  # выводит 0
    say $pepper->isa( 'ARRAY'   );  # выводит 0
    say Monkey->isa(  'HASH'    );  # выводит 0

=end programlisting

X<C<SCALAR>>
X<C<ARRAY>>
X<C<HASH>>
X<C<Regexp>>
X<C<IO>>
X<C<CODE>>

Встроенные типы Perl 5 E<mdash> C<SCALAR>, C<ARRAY>, C<HASH>, C<Regexp>, C<IO>
и C<CODE>.

X<CPAN; C<Test::MockObject>>
X<CPAN; C<Test::MockModule>>

Любой класс может переопределить C<isa()>. Это может быть полезно при работе
с объектами-моками (см. C<Test::MockObject> и C<Test::MockModule> в CPAN) или
с кодом, не использующим ролей (L<roles>). Имейте ввиду, что любой класс,
I<переопределяющий> C<isa()>, обычно имеет для этого хорошую причину.

=head2 Метод can()

X<C<UNIVERSAL::can>>
X<C<can()>>

Метод C<can()> принимает строку, содержащую имя метода. Он возвращает ссылку
на функцию, имплементирующую этот метод, если она существует. В противном
случае он возвращает ложное значение. Вы можете вызвать его на классе, объекте
или имени пакета. В последнем случае он возвращает ссылку на функцию, а не
методN<E<hellip>не то чтобы вы могли определить разницу, имея только ссылку.>.

=begin tip Существует ли класс?

Хотя и C<UNIVERSAL::isa()>, и C<UNIVERSAL::can()> E<mdash> методы
(L<method_sub_equivalence>), вы можете I<безопасно> использовать последний как
функцию единственно для определения, существует ли класс в Perl 5. Если
C<UNIVERSAL::can( $classname, 'can' )> возвращает истинное значение, кто-то
где-то определил класс с именем C<$classname>. Этот класс может быть непригодным
к использованию, но он существует.

=end tip

Имея класс, названный C<SpiderMonkey>, с методом, названным C<screech>, получить
ссылку на метод можно так:

=begin programlisting

    if (my $meth = SpiderMonkey->can( 'screech' )) {...}

    if (my $meth = $sm->can( 'screech' )
    {
        $sm->$meth();
    }

=end programlisting

X<builtins; C<require>>
X<CPAN; C<UNIVERSAL::require>>

Используйте C<can()> чтобы проверить, что класс имплементирует конкретную
функцию или метод:

=begin programlisting

    use Class::Load;

    die "Couldn't load $module!"
        unless load_class( $module );

    if (my $register = $module->can( 'register' ))
    {
        $register->();
    }

=end programlisting

=begin tip C<Module::Pluggable>

X<CPAN; C<Class::Load>>
X<CPAN; C<Module::Pluggable>>

В то время как CPAN-модуль C<Class::Load> упрощает работу по загрузке классов
по имени E<mdash> вместо танцев с C<require> E<mdash> C<Module::Pluggable>
выполняет большую часть работы по сборке и управлению системой плагинов.
Ознакомьтесь с обоими дистрибутивами.

=end tip

=head2 Метод VERSION()

X<C<UNIVERSAL::VERSION>>
X<C<VERSION()>>

Метод C<VERSION> возвращает значение переменной C<$VERSION> соответствующего
пакета или класса. Если вы укажете номер версии как необязательный параметр,
метод выбросит исключение, если опрашиваемая C<$VERSION> не равна или больше
чем параметр.

Пусть есть модуль C<HowlerMonkey> версии C<1.23>, тогда:

=begin programlisting

    say HowlerMonkey->VERSION();    # выводит 1.23
    say $hm->VERSION();             # выводит 1.23
    say $hm->VERSION( 0.0  );       # выводит 1.23
    say $hm->VERSION( 1.23 );       # выводит 1.23
    say $hm->VERSION( 2.0  );       # исключение!

=end programlisting

Нет особых причин переопределять C<VERSION()>.

=head2 Метод DOES()

X<C<UNIVERSAL::DOES>>
X<C<DOES()>>

Метод C<DOES()> появился в Perl 5.10.0. Он существует для поддержки
использования в программах ролей (L<roles>). Передайте ему инвокант и имя роли,
и метод вернёт истинное значение, если соответствующий класс как-либо выполняет
эту роль E<mdash> будь то через наследование, делегирование, композицию,
применение роли или любой другой механизм.

По умолчанию реализация C<DOES> откатывается к C<isa()>, потому что наследование
E<mdash> единственный механизм, с помощью которого класс может выполнять роль.
Пусть есть C<Cappuchin>:

=begin programlisting

    say Cappuchin->DOES( 'Monkey'       );  # выводит 1
    say $cappy->DOES(    'Monkey'       );  # выводит 1
    say Cappuchin->DOES( 'Invertebrate' );  # выводит 0

=end programlisting

Переопределите C<DOES()>, если вы вручную предоставляете роль или предоставляете
другое алломорфичное поведение.

=head2 Расширение UNIVERSAL

Возникает соблазн сохранять в C<UNIVERSAL> другие методы, чтобы сделать их
доступными для всех других классов и объектов в Perl 5. Избегайте этого
соблазна; это глобальное поведение можеть иметь неочевидные побочные эффекты,
потому что оно не ограничено.

X<CPAN; C<UNIVERSAL::ref>>
X<CPAN; C<UNIVERSAL::isa>>
X<CPAN; C<UNIVERSAL::can>>
X<CPAN; C<Perl::Critic>>

Учитывая сказанное, редкое злоупотребление C<UNIVERSAL> для целей I<отладки> и
для исправления неправильного поведения по умолчанию можеть быть извинено.
Например, дистрибутив C<UNIVERSAL::ref> Джошуа бен Джоре (Joshua ben Jore)
делает практически бесполезный оператор C<ref()> полезным. Дистрибутивы
C<UNIVERSAL::can> и C<UNIVERSAL::isa> могут помочь вам отладить анти-полиморфные
баги (L<method_sub_equivalence>). C<Perl::Critic> может обнаружить эти и другие
проблемы.

За пределами очень осторожно контролируемого кода и очень специфичных, очень
прагматичных ситуаций, нет причин напрямую помещать код в C<UNIVERSAL>. Почти
всегд есть намного лучшие альтернативы дизайна.
