=encoding utf-8

=head1 Связывание

Z<tie>

Тогда как перегрузка (L<overloading>) позволяет вам настраивать поведение
классов и объектов для конкретных случаев приведения типа, механизм, называемый
I<связыванием>, позволяет вам настраивать поведение простых переменных (скаляров,
массивов, хешей и дескрипторов файлов). Любая операция, которую вы можете
выполнить на связанной переменной, транслируется в определённый вызов метода.

X<builtins; C<tie>>
X<C<Tie::File>>

Встроенная директива C<tie> изначально позволяла вам использовать место на диске
как резервную память для хешей, так что Perl мог осуществлять доступ к файлам,
которые больше, чем можно поместить в память. Базовый модуль C<Tie::File>
предоставляет похожую систему и позволяет вам обращаться с файлами как если бы
они были массивами.

X<C<Tie::StdScalar>>
X<C<Tie::StdArray>>
X<C<Tie::StdHash>>

Класс, с которым вы связываете переменную с помощью C<tie()>, должен
соотвествовать определённому интерфейсу для конкретных типов данных. Смотрите
C<perldoc perltie> для получения общего представления, затем обратитесь к
базовым модулям C<Tie::StdScalar>, C<Tie::StdArray> и C<Tie::StdHash> за
более конкретными деталями. Начните с наследования от одного из этих классов,
затем переопределите любые конкретные методы, которые вам нужно модифицировать.

=begin tip Когда имена класса и пакета вступают в конфликт

Как будто бы C<tie> уже не достаточно сбивающий с толку, C<Tie::Scalar>,
C<Tie::Array> и C<Tie::Hash> определяют необходимые интерфейсы для связывания
скаляров, массивов и хешей, но реализацию по умолчанию предоставляют
C<Tie::StdScalar>, C<Tie::StdArray> и C<Tie::StdHash>.

=end tip

=head2 Связывание переменных

Так можно связать переменную:

=begin programlisting

    use Tie::File;
    tie my @file, 'Tie::File', @args;

=end programlisting

Первый аргумент E<mdash> это переменная для связывания, второй E<mdash> имя
класса, с которым её нужно связать, а C<@args> E<mdash> необязательный список
аргументов, требуемый для связывающей функции. В случае C<Tie::File> это
допустимое имя файла.

X<builtins; C<tie>>
X<builtins; C<tied>>

Связывающие функции напоминают конструкторы: C<TIESCALAR>, C<TIEARRAY()>,
C<TIEHASH()> или C<TIEHANDLE()> для скаляров, массивов, хешей и дескрипторов
файлов соответственно. Каждая функция возвращает новый объект, представляющий
связанную переменную. Обе встроенные директивы, C<tie> и C<tied>, возвращают
этот объект. Однако, большинство использует C<tied> в булевом контексте.

=head2 Реализация связанных переменных

Чтобы реализовать класс связанных переменных, унаследуйте от встроенного модуля,
такого как C<Tie::StdScalar>N<У C<Tie::StdScalar> отсутствует собственный файл
F<.pm>, так что используйте C<Tie::Scalar>, чтобы сделать его доступным.>, затем
переопределите конкретные методы для операций, которые вы хотите изменить. В
случае связанного скаляра это, скорее всего, будут C<FETCH> и C<STORE>, возможно,
C<TIESCALAR()>, и, вероятно, не C<DESTROY()>.

Вы можете создать класс, который логирует все операции чтения и записи скаляра, с
помощью очень небольшого количества кода:

=begin programlisting

    package Tie::Scalar::Logged
    {
        use Modern::Perl;

        use Tie::Scalar;
        use parent -norequire => 'Tie::StdScalar';

        sub STORE
        {
            my ($self, $value) = @_;
            Logger->log("Storing <$value> (was [$$self])", 1);
            $$self = $value;
        }

        sub FETCH
        {
            my $self = shift;
            Logger->log("Retrieving <$$self>", 1);
            return $$self;
        }
    }

    1;

=end programlisting

Допустим, метод C<log()> класса C<Logger> принимает строку и количество фреймов
вверх по стеку вызовов, которые нужно вывести.

Внутри методов C<STORE()> и C<FETCH()>, C<$self> работает как благословлённый
скаляр. Присваивание этой ссылке на скаляр изменяет значение скаляра, а чтение из
неё возвращает его значение.

Аналогично, методы C<Tie::StdArray> и C<Tie::StdHash> воздействуют на
благословлённые ссылки на массив и хеш сооветственно. Документация в C<perldoc
perltie> объясняет обширное количество методов, которые они поддерживают, как
например, вы можете читать или записывать множественные значения в них, помимо
других операций.

=begin tip Разве C<tie> не веселье?

Опция C<-norequire> предотвращает прагму C<parent> от попытки загрузить файл
для C<Tie::StdScalar>, поскольку этот модуль является частью файла
F<Tie/Scalar.pm>.

=end tip

=head2 Когда использовать связанные переменные?

Связанные переменные выглядять как весёлые возможности для проявления ума, но
они могут приводить к сбивающим с толку интерфейсам. Если у вас нет очень
хорошей причины для того, чтобы заставлять объект вести себя так, как если бы он
был встроенным типом данных, избегайте создания собственных связываний. К тому
же, C<tie> намного медленнее, чем использование встроенных типов данных, ввиду
различных причин, кроющихся в реализации.

Хорошие причины включают облегчение отладки (используйте логгируемый скаляр,
чтобы понять, где изменяется значение) и необходимость сделать
некоторые невозможные операции возможными (доступ к большим файлам способом с
эффективным использованием памяти). Связанные переменнные менее полезны как
первичные интерфейсы к объектам; зачастую слишком трудно и ограничивающе
пытаться вместить весь ваш интерфейс в тот, что поддерживается C<tie()>.

Последнее слово предупреждения одновременно печально и убедительно; слишком
много кода сбивается со своего пути, чтобы I<предотвратить> использование
связанных переменных, зачастую по случайности. Это неудачно, но нарушение
ожиданий библиотечного кода склонно к раскрытию багов, исправить которые
зачастую не в ваших силах.
