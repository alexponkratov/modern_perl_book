=encoding utf-8

=head1 Объявление функций

Z<functions>

X<functions; declaration>
X<builtins; C<sub>>

Используйте встроенную директиву C<sub> для объявления функции:

=begin programlisting

    B<sub> greet_me  { ... }

=end programlisting

Теперь функция C<greet_me()> доступна для вызова в любом месте программы.

X<functions; forward declaration>

Вы не обязаны I<определять> функцию в той точке, в которой вы её объявляете.
I<Предварительное объявление> указывает Perl запомнить имя функции, несмотря на
то, что вы объявите её позже:

=begin programlisting

    sub greet_sun;

=end programlisting

=head1 Вызов функций

X<functions; invoking>

Используйте постфиксные (L<fixity>) круглые скобки и имя функции для вызова этой
функции и передачи необязательного списка аргументов:

=begin programlisting

    greet_me( 'Jack', 'Brad' );
    greet_me( 'Snowy' );
    greet_me();

=end programlisting

Хотя эти скобки не являются строго обязательными для этих примеров E<mdash> даже
с включенной прагмой C<strict> E<mdash> они обеспечивают ясность для читателей
и парсера Perl. Если есть сомнения, используйте их.

Аргументы функций могут быть произвольными выражениями, включая простые
переменные:

=begin programlisting

    greet_me( $name );
    greet_me( @authors );
    greet_me( %editors );

=end programlisting

E<hellip>хотя стандартная обработка параметров в Perl 5 иногда удивляет новичков.

=head1 Параметры функций

Z<function_parameters>

X<parameters>
X<functions; parameters>
X<C<@_>>
X<parameters; flattening>

Функция получает свои параметры в едином массиве, C<@_>
(L<default_array_variables>). Perl I<разглаживает> все входные параметры в единый
список. Функция должна либо распаковать все параметры в переменные, или работать
с C<@_> напрямую:

=begin programlisting

    sub greet_one
    {
        B<my ($name) = @_>;
        say "Hello, $name!";
    }

    sub greet_all
    {
        say "Hello, B<$_!" for @_>;
    }

=end programlisting

Большая часть кода использует C<shift> или распаковку списка, однако C<@_> ведёт
себя как обычный массив, так что вы можете ссылаться на отдельные элементы по
индексу:

=begin programlisting

    sub greet_one_shift
    {
        B<my $name = shift>;
        say "Hello, $name!";
    }

    sub greet_two_no_shift
    {
        my ($hero, $sidekick) = @_;
        say "Well if it isn't $hero and $sidekick. Welcome!";
    }

    sub greet_one_indexed
    {
        B<my $name = $_[0]>;
        say "Hello, $name!";

        # or, less clear
        say "Hello, $_[0]!";
    }

=end programlisting

E<hellip> или использовать C<shift>, C<unshift>, C<push>, C<pop>, C<splice> и
C<slice> с @_.

=begin tip Неявное E<laquo>ихE<raquo>

Вспомните, что встроенные функции работы с массивами используют C<@_> как
операнд по умолчанию I<внутри функций>. Пользуйтесь этой идиомой.

=end tip

Присваивание скалярного параметра из C<@_> требует использования C<shift>,
доступа по индексу к C<@_> или скобок списочного контекста в левом значении.
В противном случае, Perl 5 с удовольствием вычислит для вас C<@_> в скалярном
контексте и присвоит количество переданных параметров:

=begin programlisting

    sub bad_greet_one
    {
        B<my $name = @_>;  # бажно
        say "Hello, $name; you look numeric today!"
    }

=end programlisting

Списочное присваивание нескольких параметров зачастую яснее, чем несколько
строчек C<shift>. Сравните:

=begin programlisting

    sub calculate_value
    {
        # несколько вызовов shift
        my $left_value  = shift;
        my $operation   = shift;
        my $right_value = shift;
        ...
    }

=end programlisting

E<hellip>и:

=begin programlisting

    sub calculate_value
    {
        B<my ($left_value, $operation, $right_value) = @_;>
        ...
    }

=end programlisting

Иногда требуется извлечь несколько параметров из C<@_>, а остальные передать в
другую функцию:

=begin programlisting

    sub delegated_method
    {
        my $self = B<shift>;
        say 'Calling delegated_method()'

        $self->delegate->delegated_method( B<@_> );
    }

=end programlisting

Используйте C<shift>, если ваша функция требует только одного параметра.
Используйте списочное присваивание для доступа к нескольким параметрам.

=begin tip Настоящие сигнатуры функций

X<CPAN; C<signatures>>
X<CPAN; C<Method::Signatures>>
X<CPAN; C<MooseX::Method::Signatures>>
X<CPAN; C<Method::Signatures::Simple>>

Несколько дистрибутивов из CPAN расширяют обработку параметров в Perl 5
дополнительным синтаксисом и опциями. C<signatures> и C<Method::Signatures>
очень мощны. C<Method::Signatures::Simple> E<mdash> прост, но удобен.
C<MooseX::Method::Signatures> отлично работает с Moose (L<moose>).

=end tip

=head2 Разглаживание

Разглаживание параметров в C<@_> происходит на стороне вызывающего кода вызова
функции. Передача хеша в качестве аргумента генерирует список пар ключ/значение:

=begin programlisting

    my %pet_names_and_types = (
        Lucky   => 'dog',
        Rodney  => 'dog',
        Tuxedo  => 'cat',
        Petunia => 'cat',
    );

    show_pets( %pet_names_and_types );

    sub show_pets
    {
        my %pets = @_;
        while (my ($name, $type) = each %pets)
        {
            say "$name is a $type";
        }
    }

=end programlisting

Когда Perl разглаживает C<%pet_names_and_types> в список, порядок пар
ключ/значение из хеша будет различаться, но список всегда будет включать
значение, следующее сразу за своим ключом. Присваивание хеша внутри
C<show_pets()> работает по существу также, как более явное присваивание
C<%pet_names_and_types>.

Разглаживание часто полезно, но остерегайтесь смешивать в списке параметров
скаляры с разглаживаемыми агрегатными переменными. При написании функции
C<show_pets_of_type()>, в которой один параметр E<mdash> это тип животного для
вывода, передавайте этот тип как I<первый> аргумент (или используйте C<pop> для
удаления его из конца C<@_>):

=begin programlisting

    sub show_pets_by_type
    {
        B<my ($type, %pets) = @_>;

        while (my ($name, $species) = each %pets)
        {
            B<next unless $species eq $type;>
            say "$name is a $species";
        }
    }

    my %pet_names_and_types = (
        Lucky   => 'dog',
        Rodney  => 'dog',
        Tuxedo  => 'cat',
        Petunia => 'cat',
    );

    show_pets_by_type( 'dog',   %pet_names_and_types );
    show_pets_by_type( 'cat',   %pet_names_and_types );
    show_pets_by_type( 'moose', %pet_names_and_types );

=end programlisting

=head2 Проглатывание

Z<parameter_slurping>
X<parameters; slurping>

Списочное присваивание агрегатной переменной всегда проявляет жадность, поэтому
присваивание C<%pets> I<проглатывает> все оставшиеся значения из C<@_>. Если
параметр C<$type> находится в конце C<@_>, Perl предупредит о присваивании
нечётного числа элементов хешу. Вы I<можете> обойти это:

=begin programlisting

    sub show_pets_by_type
    {
        B<my $type = pop;>
        B<my %pets = @_;>

        ...
    }

=end programlisting

E<hellip>ценой ясности. Тот же самый принцип, конечно же, применим к
присваиванию массиву как параметру. Используйте ссылки (L<references>) чтобы
избежать нежелательного разглаживания и проглатывания агрегатных значений.

=head2 Создание псевдонимов

X<parameters; aliasing>
X<functions; aliasing parameters>

C<@_> имеет тонкость; он I<создаёт псевдонимы> для аргументов функции, так что
вы можете модифицировать их напрямую. Например:

=begin programlisting

    sub modify_name
    {
        $_[0] = reverse $_[0];
    }

    my $name = 'Orange';
    modify_name( $name );
    say $name;

    # выводит C<egnarO>

=end programlisting

Модифицируйте элемент C<@_> напрямую, и вы модифицируете исходный параметр.
Будьте осторожны, и тщательно распаковывайте C<@_>.

=head1 Функции и пространства имён

Каждая функция содержится в некотором пространстве имён (L<packages>). Функции
в необъявленном пространстве имён E<mdash> функции, объявление которых не
расположено после явной директивы C<package> E<mdash> находятся в пространстве
имён C<main>. Кроме того, вы можете объявить функцию в другом пространстве имён,
добавив префикс к её имени:

=begin programlisting

    sub B<Extensions::Math::>add {
        ...
    }

=end programlisting

Это объявит функцию и создаст необходимое пространство имён. Помните, что пакеты
в Perl 5 открыты для изменений в любой точке. Вы можете объявить только одну
функцию с определённым именем в одном пространстве имён. В противном случае
Perl 5 выдаст предупреждение о переопределении функции. Отключите эти
предупреждения с помощью C<no warnings 'redefine'> E<mdash> если точно уверены,
что это именно то, что вам нужно.

Вызов функций в других пространствах имён осуществляется с помощью их полностью
определённых имён:

=begin programlisting

    package main;

    Extensions::Math::add( $scalar, $vector );

=end programlisting

Функции в пространствах имён I<видимы> снаружи этих пространств имён по их
полностью определённым именам. Внутри пространства имён вы можете использовать
короткие имена для доступа к любой функции, объявленной в этом пространстве
имён. Также вы можете импортировать имена из других пространств имён.

=head2 Импорт

Z<importing>

X<functions; importing>
X<builtins; C<use>>

При загрузке модуля с помощью встроенной директивы C<use> (L<modules>), Perl
автоматически вызывает метод C<import()> этого модуля. Модули могут предоставлять
свои собственные методы C<import()>, делающие некоторые или все определённые символы
доступными в вызывающем пакете. Любые аргументы после имени модуля в директиве
C<use> будут переданы в метод C<import()> модуля. Так:

=begin programlisting

    use strict;

=end programlisting

E<hellip>загружает модуль F<strict.pm> и вызывает C<< strict->import() >> без
аргументов, тогда как:

=begin programlisting

    use strict 'refs';
    use strict qw( subs vars );

=end programlisting

E<hellip>загружает модуль F<strict.pm>, вызывает
C<< strict->import( 'refs' ) >>, а затем вызывает
C<< strict->import( 'subs', vars' ) >>.

C<use> имеет специальное поведение по отношению к C<import()>, но вы можете
вызвать C<import()> и напрямую. Пример использования C<use> эквивалентен
следующему:

=begin programlisting

    BEGIN
    {
        require strict;
        strict->import( 'refs' );
        strict->import( qw( subs vars ) );
    }

=end programlisting

Встроенная директива C<use> добавляет неявный блок C<BEGIN> вокруг этих
выражений, так что вызов C<import()> происходит I<сразу> после того, как парсер
скомпилирует всю директиву C<use>. Это гарантирует, что любые импортируемые
символы будут видимы при компиляции остальной части программы. В противном
случае любые функции, I<импортированные> из других модулей, но не I<объявленные>
в текущем файле, будут выглядеть как голые слова, тем самым нарушая режим
C<strict>.

=head1 Оповещение об ошибках

Z<reporting_errors>
X<builtins; C<caller>>

Внутри функции проверить контекст её вызова можно с помощью встроенной функции
C<caller>. Если не передано никаких аргументов, она возвращает список из трёх
элементов, содержащий имя вызывающего пакета, имя файла, содержащего вызов, и
номер строки файла, на которой произошёл вызов:

=begin programlisting

    package main;

    main();

    sub main
    {
        show_call_information();
    }

    sub show_call_information
    {
        my ($package, $file, $line) = caller();
        say "Called from $package in $file:$line";
    }

=end programlisting

Для инспектирования доступна полная цепочка вызовов. Передайте единственный
целочисленный аргумент I<n> в C<caller()> чтобы просмотреть вызов вызова вызова
I<n> раз. Другими словами, если бы C<show_call_information()> использовала
C<caller(0)>, то получила бы информацию о вызове из C<main()>. Если же она
использовала бы C<caller(1)>, то получила бы информацию о вызове из начала программы.

Этот необязательный аргумент также требует от C<caller> предоставить
дополнительные возвращаемые значения, включая имя функции и контекст вызова:

=begin programlisting

    sub show_call_information
    {
        my ($package, $file, $lineB<, $func>) = caller(B<0>);
        say "Called B<$func> from $package in $file:$line";
    }

=end programlisting

X<C<Carp>>
X<C<Carp>; C<croak()>>
X<C<Carp>; C<carp()>>

Стандартный модуль C<Carp> успешно использует эту технику для оповещения об
ошибках и выбрасывания предупреждений в функциях. При использовании вместо
C<die> в коде библиотеки, C<croak()> выбрасывает исключение с точки зрения
своего вызывающего кода. C<carp()> сообщает о предупреждении из файла, сообщая
номер строки своего вызывающего кода (L<producing_warnings>).

Это поведение наиболее полезно при валидации параметров и предварительных
условий фукнций, для указания того, что вызывающий код в чём-то неверен.

=head2 Валидация аргументов

Хотя Perl старается как может делать то, что имеет ввиду программист, он
предоставляет немного нативных способов проверки валидности аргументов,
передаваемых в функции. Для определения того, что I<количество> параметров,
переданных в функцию, корректно, вычислите C<@_> в скалярном контексте:

=begin programlisting

    sub add_numbers
    {
        croak 'Expected two numbers, received: ' . @_
            unless @_ == 2;

        ...
    }

=end programlisting

X<CPAN; C<Params::Validate>>

Проверка типа более трудна из-за свойственного Perl оператор-ориентированного
преобразования типов (L<context_philosophy>). Модуль C<Params::Validate> из CPAN
предлагает больше точности.

=head1 Продвинутые функции

Функции E<mdash> фундамент многих продвинутых возможностей Perl.

=head2 Учёт контекста

X<context>
X<C<wantarray>>
X<builtins; C<wantarray>>

Встроенные функции Perl 5 знают, вызвали ли вы их в пустом, скалярном или
списочном контексте. Как могут и ваши функции. Неудачно названнаяN<См.
C<perldoc -f wantarray> для подтверждения.> директива C<wantarray> возвращает
C<undef> для обозначения пустого контекста, ложное значение для обозначения
скалярного контекста и истинное значение для обозначения списочного контекста.

=begin programlisting

    sub context_sensitive
    {
        my $context = wantarray();

        return qw( List context )   if         $context;
        say    'Void context'   unless defined $context;
        return 'Scalar context' unless         $context;
    }

    context_sensitive();
    say my $scalar = context_sensitive();
    say context_sensitive();

=end programlisting

Это может быть полезно для функций, которые могут производить дорогие
возвращаемые значения, чтобы избежать этого в пустом контексте. Некоторые
идиоматические функции возвращают список в списочном контексте и первый элемент
списка или ссылку на массив в скалярном контексте. Но помните, что для
использования C<wantarray> не существует единых наилучших рекомендаций. Иногда
понятнее будет написать отдельные однозначные функции.

=begin tip Поместите это в контекст

X<C<Want>>
X<C<Contextual::Return>>

Дистрибутивы C<Want> Робина Хьюстона (Robin Houston) и C<Contextual::Return>
Демиена Конвея (Damian Conway) из CPAN предлагают множество возможностей для
написания мощных и практичных интерфейсов, учитывающих контекст.

=end tip

=head2 Рекурсия

Z<recursion>
X<recursion>
X<call frame>
X<functions; call frame>

Предположим, вы хотите найти элемент в отсортированном массиве. Вы I<можете>
в поисках цели обойти в цикле каждый элемент массива отдельно, но в среднем вам
придётся проверить половину элементов в массиве. Другой подход E<mdash>
разделить массив пополам, выбрать элемент посередине, сравнить, затем повторить
либо с нижней, либо с верхней половиной. Разделяй и властвуй. Когда закончатся
элементы для проверки или будет найден искомый, остановитесь.

Автоматизированный тест для этой техники может быть таким:

=begin programlisting

    use Test::More;

    my @elements =
    (
        1, 5, 6, 19, 48, 77, 997, 1025, 7777, 8192, 9999
    );

    ok   elem_exists(     1, @elements ),
            'found first element in array';
    ok   elem_exists(  9999, @elements ),
             'found last element in array';
    ok ! elem_exists(   998, @elements ),
            'did not find element not in array';
    ok ! elem_exists(    -1, @elements ),
            'did not find element not in array';
    ok ! elem_exists( 10000, @elements ),
            'did not find element not in array';

    ok   elem_exists(    77, @elements ),
            'found midpoint element';
    ok   elem_exists(    48, @elements ),
            'found end of lower half element';
    ok   elem_exists(   997, @elements ),
            'found start of upper half element';

    done_testing();

=end programlisting

Рекурсия E<mdash> обманчиво простое понятие. Каждый вызов функции в Perl
создаёт новый I<фрейм вызова>, внутреннюю структуру данных, представляющую сам
вызов, включая лексическое окружение текущего вызова функции. Это значит, что
функция может вызвать сама себя, I<рекурсивно>.

Чтобы добиться прохождения предыдущего теста, напишите функцию под названием
C<elem_exists()>, которая знает, как вызывать себя, каждый раз деля список
пополам:

=begin programlisting

    sub elem_exists
    {
        my ($item, @array) = @_;

        # прервать рекурсию, если не осталось элементов для поиска
        return unless @array;

        # смещаемся вниз при нечётном количестве элементов
        my $midpoint = int( (@array / 2) - 0.5 );
        my $miditem  = $array[ $midpoint ];

        # возвращаем истину если элемент найден
        return 1 if $item  == $miditem;

        # возвращаем ложь, если остался только один элемент
        return   if @array == 1;

        # разбиваем массив надвое и продолжаем рекурсивно
        return B<elem_exists>(
            $item, @array[0 .. $midpoint]
        ) if $item < $miditem;

        # разбиваем массив надвое и продолжаем рекурсивно
        return B<elem_exists>(
             $item, @array[ $midpoint + 1 .. $#array ]
        );
    }

=end programlisting

Хотя вы I<можете> написать этот код в процедурном виде и самостоятельно
управлять делением списка, этот рекурсивный подход позволяет Perl управлять
процессом.

=head2 Лексические переменные

Каждый новый вызов функции создаёт собственный I<экземпляр> лексической
области видимости. Даже несмотря на то, что объявление C<elem_exists()> создаёт
единственную область видимости для лексических переменных C<$item>, C<@array>,
C<$midpoint> и C<$miditem>, каждый I<вызов> C<elem_exists()> E<mdash> даже
рекурсивный E<mdash> сохраняет значения этих лексических переменных отдельно.

C<elem_exists()> не только может вызывать саму себя, но и лексические переменные
каждого вызова будут защищены и разделены:

=begin programlisting

    B<use Carp 'cluck';>

    sub elem_exists
    {
        my ($item, @array) = @_;

        B<cluck "[$item] (@array)";>

        # далее следует другой код
        ...
    }

=end programlisting

=head2 Хвостовые вызовы

Z<tail_calls>
X<recursion; guard conditions>

Один из I<недостатков> рекурсии E<mdash> то, что вы должны корректно указать
условия возврата, иначе ваша функция вызовет себя саму бесконечное количество
раз. По этой причине функция C<elem_exists()> имеет несколько директив
C<return>.

Perl выводит полезное предупреждение C<Deep recursion on subroutine>, если
подозревает неконтролируемую рекурсию. Ограничение в 100 рекурсивных вызовов
произвольно, но зачастую удобно. Отключите это предупреждение, указав
C<no warnings 'recursion'> в области видимости рекурсивного вызова.

Так как каждый вызов функции требует нового фрейма вызова и пространства для
хранения лексических переменных, глубокорекурсивный код может использовать
больше памяти, чем итеративный код. I<Устранение хвостовых вызовов> может
помочь.

I<Хвостовой вызов> E<mdash> это вызов функции, который напрямую возвращает
результаты этой функции. Эти рекурсивные вызовы C<elem_exists()>:

=begin programlisting

    # разбиваем массив надвое и продолжаем рекурсивно
    return B<elem_exists>(
        $item, @array[0 .. $midpoint]
    ) if $item < $miditem;

    # разбиваем массив надвое и продолжаем рекурсивно
    return B<elem_exists>(
         $item, @array[ $midpoint + 1 .. $#array ]
    );

=end programlisting

E<hellip>кандидаты для устранения хвостовых вызовов. Эта оптимизация позволит
избежать возврата в текущий вызов и последующего возврата в родительский вызов.
Вместо этого, она возвращается в родительский вызов напрямую.

X<C<goto>>
X<functions; C<goto>>
X<builtins; C<goto>>

К сожалению, Perl 5 не устраняет хвостовые вызовы автоматически. Это делается
вручную с помощью специальной формы встроенной директивы C<goto>. В отличие от
формы, зачастую производящей спагетти-код, функциональная форма C<goto> заменяет
текущий вызов функции вызовом другой функции. Вы можете указывать функцию с
помощью имени или ссылки. Для передачи аргументов присваивайте напрямую в C<@_>:

=begin programlisting

    # разбиваем массив надвое и продолжаем рекурсивно
    if ($item < $miditem)
    {
        @_ = ($item, @array[0 .. $midpoint]);
        B<goto &elem_exists;>
    }

    # разбиваем массив надвое и продолжаем рекурсивно
    else
    {
        @_ = ($item, @array[$midpoint + 1 .. $#array] );
        B<goto &elem_exists;>
    }

=end programlisting

Иногда оптимизации довольно уродливы.

=head1 Ловушки и недостатки

X<functions; misfeatures>
X<functions; Perl 4>
X<functions; Perl 1>
X<C<&>; sigil>
X<sigils; C<&>>
X<builtins; C<do>>

Perl 5 всё ещё поддерживает старомодный вызов функций, полученный в наследство
от старших версий Perl. Тогда как сейчас вы можете вызывать Perl-функции по
имени, предыдущие версии Perl требовали их вызова с использованием ведущего
символа амперсанда (C<&>). Perl 1 требовал использования встроенной директивы
C<do>:

=begin programlisting

    # устаревший стиль; избегайте
    my $result = &calculate_result( 52 );

    # стиль Perl 1; избегайте
    my $result = do calculate_result( 42 );

    # сумасшедшая мешанина; в самом деле избегайте, правда
    my $result = do &calculate_result( 42 );

=end programlisting

Кроме того, что этот рудиментарный синтаксис E<mdash> визуальный хаос, форма с
ведущим амперсандом имеет несколько неожиданных поведений. Во-первых, она
отключает любую проверку прототипа. Во-вторых, она I<неявно> передаёт содержимое
C<@_> немодифицированным, если вы сами не укажете аргументы. И то, и другое
может приводить к неожиданному поведению.

Последняя ловушка проистекает из опускания скобок из вызова фукнции. Парсер
Perl 5 использует несколько эвристических методов для разрешения неоднозначных
голых слов и количества параметров, передаваемых в функцию. Эвристики могут
ошибаться:

=begin programlisting

    # внимание; содержит хитрый баг
    ok elem_exists 1, @elements, 'found first element';

=end programlisting

Вызов C<elem_exists()> поглотит описание теста, которое должно было быть вторым
аргументом C<ok()>. Так как C<elem_exists()> использует проглатывающий второй
параметр, это может пройти незамеченным до тех пор, пока Perl не выдаст
предупреждение о сравнении нечислового значения (описание теста, которое он не
может сконвертировать в число) с элементом в массиве.

Хотя лишние скобки можут препятствовать читаемости, обдуманное
использование скобок может прояснить код и сделать коварные баги маловероятными.

