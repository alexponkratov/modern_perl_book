=encoding utf-8

=head1 Поток управления

Z<control_flow>

X<control flow>

Базовый I<поток управления> в Perl E<mdash> прямой. Выполнение программы
начинается с начала (первая строка исполняемого файла) и продолжается до конца:

=begin programlisting

    say 'At start';
    say 'In middle';
    say 'At end';

=end programlisting

X<control flow directives>

I<Директивы потока управления> в Perl изменяют порядок выполнения E<mdash> что
в программе произойдёт следущим E<mdash> в зависимости от значений их выражений.

=head2 Директивы ветвления

X<control flow directives; C<if>>

Директива C<if> выполняет связанное действие только если её условное выражение
возвращает I<истинное> значение:

=begin programlisting

    say 'Hello, Bob!' if $name eq 'Bob';

=end programlisting

Эта постфиксная форма удобна для простых выражений. Блочная форма группирует
несколько выражений воедино:

=begin programlisting

    if ($name eq 'Bob')
    {
        say 'Hello, Bob!';
        found_bob();
    }

=end programlisting

Блочная форма требует скобок вокруг своего условия, постфиксная же форма
E<mdash> нет:

Условное выражение может состоять из нескольких подвыражений, до тех пор пока
оно вычисляется в одно выражение верхнего уровня:

=begin programlisting

    if ($name eq 'Bob' && not greeted_bob())
    {
        say 'Hello, Bob!';
        found_bob();
    }

=end programlisting

В постфиксной форме добавление скобок может прояснить замысел кода ценой
визуальной чистоты:

=begin programlisting

    greet_bob() if ($name eq 'Bob' && not greeted_bob());

=end programlisting

X<control flow directives; C<unless>>

Директива C<unless> E<mdash> отрицательная форма C<if>. Perl выполнит действие
в случае, если условное выражение возвращает I<ложь>:

=begin programlisting

    say "You're not Bob!" unless $name eq 'Bob';

=end programlisting

Как и C<if>, C<unless> тоже имеет блочную форму, хотя многие программисты
избегают её, потому что со сложными условиями она очень быстро становится
сложной для чтения:

=begin programlisting

    unless (is_leap_year() and is_full_moon())
    {
        frolic();
        gambol();
    }

=end programlisting

C<unless> очень хорошо работает для постфиксных условий, особенно для валидации
параметров в функциях (L<postfix_parameter_validation>):

=begin programlisting

    sub frolic
    {
        return unless @_;

        for my $chant (@_) { ... }
    }

=end programlisting

X<control flow directives; C<else>>

Блочные формы как C<if>, так и C<unless>, работают с директивой C<else>,
предоставляющей код для выполнения в случае, если условное выражение не
возвращает истину (для C<if>) или ложь (для C<unless>):

=begin programlisting

    if ($name eq 'Bob')
    {
        say 'Hi, Bob!';
        greet_user();
    }
    else
    {
        say "I don't know you.";
        shun_user();
    }

=end programlisting

Блоки C<else> позволяют переписать условия C<if> и C<unless> в терминах друг
друга:

=begin programlisting

    unless ($name eq 'Bob')
    {
        say "I don't know you.";
        shun_user();
    }
    else
    {
        say 'Hi, Bob!';
        greet_user();
    }

=end programlisting

Однако, подразумеваемое двойное отрицание при использовании C<unless> с блоком
C<else> может сбивать с толку. Этот пример, возможно, единственное место, где вы
его когда-либо увидите.

Perl не только предоставляет вам и C<if>, и C<unless>, чтобы дать возможность
выразить ваши условия наиболее читаемым способом, вы также можете выбирать между
положительными и отрицательными условными операторами:

=begin programlisting

    if ($name B<ne> 'Bob')
    {
        say "I don't know you.";
        shun_user();
    }
    else
    {
        say 'Hi, Bob!';
        greet_user();
    }

=end programlisting

E<hellip>хотя двойное отрицание, создаваемое присутствием блока C<else>, наводит
на мысль инвертировать условие.

X<control flow directives; C<elsif>>

Одна или более директив C<elsif> может следовать за блочной формой C<if> и
предшествовать единственной директиве C<else>:

=begin programlisting

    if ($name eq 'Bob')
    {
        say 'Hi, Bob!';
        greet_user();
    }
    elsif ($name eq 'Jim')
    {
        say 'Hi, Jim!';
        greet_user();
    }
    else
    {
        say "You're not my uncle.";
        shun_user();
    }

=end programlisting

Цепочка C<unless> тоже может использовать блок C<elsif>N<Удачи с расшифровкой
этого!>. Однако, не существует директивы C<elseunless>.

Написание C<else if> E<mdash> синтаксическая ошибкаN<Ларри предпочитает C<elsif>
исходя из эстетических причин, а также предшествующего искусства языка
програмирования Ada.>:

=begin programlisting

    if ($name eq 'Rick')
    {
        say 'Hi, cousin!';
    }

    # внимание, синтаксическая ошибка
    else if ($name eq 'Kristen')
    {
        say 'Hi, cousin-in-law!';
    }

=end programlisting

=head2 Тернарный условный оператор

X<ternary conditional>
X<control flow directives; ternary conditional>

I<Тернарный условный> оператор вычисляет условное выражение и возвращает одну из
двух альтернатив:

=begin programlisting

    my $time_suffix = after_noon($time)
                    ? 'afternoon'
                    : 'morning';

=end programlisting

Условное выражение предшествует символу вопросительного знака (C<?>), а символ двоеточия
(C<:>) разделяет альтернативы. Альтернативы E<mdash> это выражения произвольной
сложности, включая другие тернарные условные выражения.

=begin sidebar

Интересная, хотя и малоизвестная, идиома E<mdash> использование тернарного
условия для выбора между альтернативными I<переменными>, а не только значениями:

=begin programlisting

    push @{ rand() > 0.5 ? \@red_team : \@blue_team },
        Player->new;

=end programlisting

И снова, взвесьте выгоды ясности против выгод краткости.

=end sidebar

=head3 Короткое замыкание

Z<short_circuiting>
X<short-circuiting>

Perl проявляет поведение, называемое I<коротким замыканием>, когда встречается
со сложными условными выражениями. Если Perl может определить, будет ли сложное
выражение истинно или ложно, не вычисляя каждое подвыражение, он не будет
вычислять последующие подвыражения. Это наиболее очевидно на примере:

=begin programlisting

    say "Both true!" if ok( 1, 'subexpression one' )
                     && ok( 1, 'subexpression two' );

    done_testing();

=end programlisting

Возвращаемое значение C<ok()> (L<testing>) E<mdash> это булево значение,
полученное при вычислении первого аргумента, поэтому этот код выведет:

=begin screen

    ok 1 - subexpression one
    ok 2 - subexpression two
    Both true!

=end screen

Если первое подвыражение E<mdash> первый вызов C<ok> E<mdash> возвращает
истинное значение, Perl должен будет вычислить второе подвыражение. Если бы
первое подвыражение вернуло ложное значение, то не было бы необходимости
проверять последующие подвыражения, так как всё выражение уже не может быть истинным:

=begin programlisting

    say "Both true!" if ok( 0, 'subexpression one' )
                     && ok( 1, 'subexpression two' );

=end programlisting

Этот пример выводит:

=begin screen

    not ok 1 - subexpression one

=end screen

Хотя второе подвыражение очевидно вернёт истину, Perl никогда не вычислит его.
То же самое короткое замыкание очевидно для операций логического или:

=begin programlisting

    say "Either true!" if ok( 1, 'subexpression one' )
                       || ok( 1, 'subexpression two' );

=end programlisting

Этот пример выводит:

=begin screen

    ok 1 - subexpression one
    Either true!

=end screen

В случае истинности первого подвыражения, Perl может избежать вычисления второго
подвыражения. Если бы первое подвыражение было ложным, результат вычисления
второго подвыражения определил бы результат вычисления всего выражения.

Короткое замыкание позволяет вам не только избежать потенциально дорогих
вычислений, но и избежать ошибок и предупреждений, как в случае, когда
использование неопределённого значения может вызвать предупреждение:

=begin programlisting

    my $bbq;
    if (defined $bbq and $bbq eq 'brisket') { ... }

=end programlisting

=head2 Контекст в условных директивах

X<context; conditional>
X<boolean; true>
X<true>
X<false>

Все условные директивы E<mdash> C<if>, C<unless> и тернарный условный оператор
E<mdash> вычисляют выражение в булевом контексте (L<context_philosophy>). В то
время как операторы сравнения, такие как C<eq>, C<==>, C<ne> и C<!=>, возвращают
булевы значения при их вычислении, результаты других выражений E<mdash>
включая переменные и значения E<mdash> Perl преобразует в булевы формы.

В Perl 5 нет единого истинного значения, как и единого ложного. Любое число,
преобразуемое в 0, ложно. Это относится к C<0>, C<0.0>, C<0e0>, C<0x0> и т. д.
Пустая строка (C<''>) и C<'0'> преобразуются в ложное значение, но строки
C<'0.0'>, C<'0e0'> и т. д. E<mdash> нет. Идиома C<'0 but true'> преобразуется
в 0 в числовом контексте, но истинно в булевом контексте, благодаря своему
строковому содержанию.

Пустой список и C<undef> преобразуются в ложное значение. Пустые массивы и хеши
возвращают число 0 в скалярном контексте, поэтому в булевом контексте
преобразуются в ложь. Массив, содержащий хотя бы один элемент, пусть даже
C<undef>, преобразуется в истину в булевом контексте. Хеш, содержащий
хотя бы один элемент, даже если и ключ, и значение E<mdash> C<undef>,
преобразуется в истинное значение в булевом контексте.

=begin tip Более глубокий контроль контекста

X<CPAN; C<Want>>
X<pragmas; C<overloading>>

Модуль C<Want> из CPAN позволяет вам определять булев контекст с помощью своих
собственных функций. Встроенная прагма C<overloading> (L<overloading>) позволяет
вам указать, что ваши собственные типы данных возвращают при вычислении в разных
контекстах.

=end tip

=head2 Директивы циклов

Z<looping_directives>

X<looping directives; C<for>>
X<looping directives; C<foreach>>

Perl предоставляет несколько директив для организации циклов и итераций. Цикл
в стиле I<foreach> вычисляет выражение, возвращающее список, и выполняет
инструкцию или блок, пока не израсходует весь этот список:

=begin programlisting

    foreach (1 .. 10)
    {
        say "$_ * $_ = ", $_ * $_;
    }

=end programlisting

Этот пример использует оператор диапазона для генерации списка целых чисел от
единицы до десяти включительно. Директива C<foreach> циклически проходит по ним,
устанавливая переменную-топик C<$_> (L<default_scalar_variable>) в каждое из них
по очереди. Perl выполняет блок для каждого целого числа и выводит их квадраты.

=begin tip C<foreach> versus C<for>

X<builtins; C<for>>
X<builtins; C<foreach>>

Многие Perl-программисты подразумевают под итерациями циклы C<foreach>, но Perl
считает имена C<foreach> и C<for> взаимозаменяемыми. Последующий код определяет
тип и поведение цикла.

=end tip

Как и C<if> и C<unless>, этот цикл имеет постфиксную форму:

=begin programlisting

    say "$_ * $_ = ", $_ * $_ for 1 .. 10;

=end programlisting

Цикл C<for> может использовать именованную переменную вместо переменной-топика:

=begin programlisting

    for my $i (1 .. 10)
    {
        say "$i * $i = ", $i * $i;
    }

=end programlisting

Когда цикл C<for> использует переменную-итератор, область видимости этой
переменной E<mdash> I<внутри> цикла. Perl будет назначать этой лексической
переменной значение каждого элемента итерации. Perl не будет модифицировать
переменную-топик (C<$_>). Если вы объявили лексическую переменную C<$i> во
внешней области видимости, её значение сохранится снаружи цикла:

=begin programlisting

    my $i = 'cow';

    for my $i (1 .. 10)
    {
        say "$i * $i = ", $i * $i;
    }

    is( $i, 'cow', 'Value preserved in outer scope' );

=end programlisting

Эта локализация происходит даже если вы не переобъявляли переменную итерации как
лексическуюN<E<mdash>однако I<объявляйте> ваши переменные итераций как лексические,
чтобы уменьшить их область видимости.>:

=begin programlisting

    my $i = 'horse';

    for $i (1 .. 10)
    {
        say "$i * $i = ", $i * $i;
    }

    is( $i, 'horse', 'Value preserved in outer scope' );

=end programlisting

=head2 Итерации и псевдонимы

X<iteration; aliasing>
X<aliasing>
X<aliasing; iteration>

Цикл C<for> создаёт переменную-итератор как I<псевдоним> для значения в
итерации, так что любые модификации значения итератора сразу же изменяют исходное
значение:

=begin programlisting

    my @nums = 1 .. 10;

    $_ **= 2 for @nums;

    is( $nums[0], 1, '1 * 1 is 1' );
    is( $nums[1], 4, '2 * 2 is 4' );

    ...

    is( $nums[9], 100, '10 * 10 is 100' );

=end programlisting

Создание псевдонимов также работает с блочным стилем цикла C<for>:

=begin programlisting

    for my $num (@nums)
    {
        $num **= 2;
    }

=end programlisting

E<hellip>как и в итерациях с переменной-топиком:

=begin programlisting

    for (@nums)
    {
        $_ **= 2;
    }

=end programlisting

Однако, вы не можете использовать псевдонимы для изменения значения I<констант>:

=begin programlisting

    for (qw( Huex Dewex Louid ))
    {
        $_++;
        say;
    }

=end programlisting

Вместо этого Perl выбросит исключение о модификации значения, предназначенного
только для чтения.

Иногда вы можете увидеть использование цикла C<for> с единственной скалярной
переменной, для создания псевдонима этой переменной в C<$_>:

=begin programlisting

    for ($user_input)
    {
        s/\A\s+//;      # удалить ведущие пробелы
        s/\s+\z//;      # удалить завершающие пробелы

        $_ = quotemeta; # экранировать символы, не являющиеся словарными символами
    }

=end programlisting

=head2 Итерации и область видимости

X<iteration; scoping>
X<scope; iterator>
X<C<my $_>>
X<C<$_>; lexical>

Учёт области видимости итератора в случае переменной-топика создаёт общий
источник путаницы. Рассмотрим функцию C<topic_mangler()>, целенаправленно
модифицирующую C<$_>. Если код, итерирующий по списку, вызывает
C<topic_mangler()>, не защитив C<$_>, весёлая отладка гарантированна:

=begin programlisting

    for (@values)
    {
        topic_mangler();
    }

    sub topic_mangler
    {
        s/foo/bar/;
    }

=end programlisting

Если вам I<приходится> использовать C<$_> вместо именованной переменной,
сделайте переменную-топик лексической с помощью объявления C<my $_>:

=begin programlisting

    sub topic_mangler
    {
        # было $_ = shift;
        B<my> $_ = shift;

        s/foo/bar/;
        s/baz/quux/;

        return $_;
    }

=end programlisting

Использование именованной переменной итерации также предотвращает нежелательное
создание псевдонима в C<$_>.

=head2 Цикл for в стиле C

X<loops; C<for>>

Цикл C<for> в стиле C требует управления условиями итерации:

=begin programlisting

    for (my $i = 0; $i <= 10; $i += 2)
    {
        say "$i * $i = ", $i * $i;
    }

=end programlisting

Вы должны явно назначить значение итерационной переменной в конструкции цикла,
так как этот цикл не выполняет ни создания псевдонима, ни присвоения
переменной-топику. Хотя все переменные, объявленные в конструкции цикла, имеют
лексическую область видимости в блоке цикла, переменные, объявленные снаружи
конструкции цикла, не локализуются:

=begin programlisting

    my $i = 'pig';

    for ($i = 0; $i <= 10; $i += 2)
    {
        say "$i * $i = ", $i * $i;
    }

    isnt( $i, 'pig', '$i overwritten with a number' );

=end programlisting

Конструкция цикла может иметь три подвыражения. Первое подвыражение E<mdash>
секция инициализации E<mdash> выполняется только один раз, перед выполнением
тела цикла. Perl вычисляет второе подвыражение E<mdash> условное сравнение
E<mdash> перед каждой итерацией тела цикла. Если оно возвращает истинное
значение, выполняется итерация. Если оно возвращает ложное значение, итерация
прекращается. Последнее подвыражение выполняется после каждой итерации тела
цикла.

=begin programlisting

    for (
        # подвыражение инициализации цикла
        say 'Initializing', my $i = 0;

        # подвыражение условного сравнения
        say "Iteration: $i" and $i < 10;

        # подвыражение завершения итерации
        say 'Incrementing ' . $i++
    )
    {
        say "$i * $i = ", $i * $i;
    }

=end programlisting

Обратите внимание на отсутствие точки с запятой после последнего подвыражения, а
также на использование оператора запятой и низкоприоритетного C<and>; этот
синтаксис на удивление привередлив. По возможности, предпочтите
использование цикла в стиле C<foreach>, а не C<for>.

Все три подвыражения необязательны. Бесконечный цикл C<for> может выглядеть так:

=begin programlisting

    for (;;) { ... }

=end programlisting

=head2 While и Until

X<loops; C<while>>

Цикл I<while> продолжается до тех пор, пока условие цикла не вернёт ложное
булево значение. Идиоматический бесконечный цикл выглядит так:

=begin programlisting

    while (1) { ... }

=end programlisting

В отличие от итерации в цикле стиля C<foreach>, условие цикла C<while> само по
себе не имеет побочных эффектов. То есть, если C<@values> содержит один или
несколько элементов, этот код тоже будет бесконечным циклом:

=begin programlisting

    while (@values)
    {
        say $values[0];
    }

=end programlisting

X<destructive update>

Чтобы предотвратить подобный бесконечный цикл C<while>, используйте
I<деструктивное изменение> массива C<@values>, модифицируя массив на каждой
итерации цикла:

=begin programlisting

    while (@values)
    {
        my $value = shift @values;
        say $value;
    }

=end programlisting

Модификация C<@values> внутри условия C<while> тоже работает, но имеет ряд
тонкостей, связанных с истинностью каждого значения.

=begin programlisting

    while (my $value = shift @values)
    {
        say $value;
    }

=end programlisting

Этот цикл прекратится, как только он достигнет элемента, являющегося ложным
значением, а не обязательно, когда весь массив будет израсходован. Это может
быть ожидаемым поведением, но часто удивляет новичков.

X<loops; C<until>>

Цикл I<until> меняет на противоположный смысл проверки цикла C<while>. Итерация
продолжается, пока условное выражение цикла возвращает ложное значение:

=begin programlisting

    until ($finished_running)
    {
        ...
    }

=end programlisting

Каноническое использование цикла C<while> E<mdash> итерация по входным данным из
дескриптора файла:

=begin programlisting

    use autodie;

    open my $fh, '<', $file;

    while (<$fh>)
    {
        ...
    }

=end programlisting

Perl 5 интерпретирует этот цикл C<while> как если бы вы написали:

=begin programlisting

    while (defined($_ = <$fh>))
    {
        ...
    }

=end programlisting

Без явного C<defined>, любая строка, прочитанная из дескриптора файла, которая в
скалярном контексте даёт ложное значение E<mdash> пустая строка, или строка,
содержащая один только символ C<0> E<mdash> завершит цикл. Оператор C<readline>
(C<< <> >>) возвращает неопределённое значение только когда достигает конца
файла.

=begin tip Обкусывайте ваши строчки

X<builtins; C<chomp>>

Используйте встроенную функцию C<chomp> для удаления символов конца строки из
каждой строчки. Многие новички забывают это делать.

=end tip

И C<while>, и C<until> имеют постфиксные формы, такие как бесконечный цикл
C<1 while 1;>. Любое одиночное выражение годится для постфиксной формы
C<while> или C<until>, включая классический пример E<laquo>Hello, world!E<raquo>
из 8-битных компьютеров ранних 1980-ых:

=begin programlisting

    print "Hello, world!  " while 1;

=end programlisting

Бесконечные циклы более полезны, чем кажется на первый взгляд, особенно для
петель событий в программах с графическим интерфейсом, интерпретаторах или
сетевых серверах:

=begin programlisting

    $server->dispatch_results() until $should_shutdown;

=end programlisting

X<loops; C<do>>

Используйте блок C<do>, чтобы сгруппировать несколько выражений воедино:

=begin programlisting

    do
    {
        say 'What is your name?';
        my $name = <>;
        chomp $name;
        say "Hello, $name!" if $name;
    } until (eof);

=end programlisting

Блок C<do> воспринимается парсером как единое выражение, которое может содержать
несколько других выражений. В отличие от блочной формы цикла C<while>, блок
C<do> с постфиксным C<while> или C<until> выполнит своё тело хотя бы раз. Эта
конструкция менее распространена, чем другие формы циклов, но не менее
действенна.

=head2 Циклы внутри циклов

X<loops; nested>

Вы можете вкладывать циклы друг в друга:

=begin programlisting

    for my $suit (@suits)
    {
        for my $values (@card_values) { ... }
    }

=end programlisting

Когда вы это делаете, объявляйте именованные итерационные переменные! В
противном случае вероятность возникновения путаницы с переменной-топиком и её
областью видимости слишком высока.

Распространённая ошибка при вложении циклов C<foreach> и C<while> заключается в
том, что легко израсходовать дескриптор файла в цикле C<while>:

=begin programlisting

    use autodie;

    open my $fh, '<', $some_file;

    for my $prefix (@prefixes)
    {
        # НЕ ИСПОЛЬЗУЙТЕ; с большой вероятностью ошибочный код
        while (<$fh>)
        {
            say $prefix, $_;
        }
    }

=end programlisting

Открытие дескриптора файла снаружи цикла C<for> сохраняет позицию в файле между
итерациями цикла C<for>. На его второй итерации циклу C<while> будет нечего
читать, и он не будет выполнен. Чтобы разрешить эту проблему, переоткрывайте файл
внутри цикла C<for> (просто для понимания, но не всегда хорошее использование
системных ресурсов), считайте весь файл в память (что может не сработать, если
файл большой) или сбрасывайте дескриптор файла назад к началу файла на каждой
итерации с помощью функции C<seek> (опция, которую зачастую упускают):

=begin programlisting

    use autodie;

    open my $fh, '<', $some_file;

    for my $prefix (@prefixes)
    {
        while (<$fh>)
        {
            say $prefix, $_;
        }

        seek $fh, 0, 0;
    }

=end programlisting

=head2 Контроль циклов

X<loops; control>

Иногда вам нужно разорвать цикл раньше, чем условия итерации будут исчерпаны.
Стандартные механизмы управления Perl 5 E<mdash> исключения и C<return> E<mdash>
работают, но кроме того вы можете использовать операторы I<контроля цикла>.

X<loops; C<next>>

Оператор I<next> перезапускает цикл со следующей его итерации. Используйте его,
если вы сделали всё, что нужно, в текущей итерации. Для цикла по строкам в файле
с пропуском любой строки, начинающейся с символа комментария C<#>, напишите:

=begin programlisting

    while (<$fh>)
    {
        B<next> if /\A#/;
        ...
    }

=end programlisting

=begin tip Несколько выходов против вложенных условий

Сравните использование C<next> с альтернативой: заворачивание оставшейся части
тела блока в C<if>. Представьте, что произойдёт, если у вас есть несколько
условий, которые могут вызвать пропуск строки. Модификатры контроля цикла с
постфиксными условиями могут сделать ваш код намного более читабельным.

=end tip

X<loops; C<last>>

Оператор I<last> немедленно завершает цикл. Чтобы закончить обработку файла, как
только вы достигли признака завершения, напишите:

=begin programlisting

    while (<$fh>)
    {
        next if /\A#/;
        B<last> if /\A__END__/
        ...
    }

=end programlisting

X<loops; C<redo>>

Оператор I<redo> перезапускает текущую итерацию без повторного вычисления
условия. Это может быть полезно в тех немногих случаях, когда вы хотите
сразу же изменить прочитанную строку, а затем начать обработку с начала, не
затирая её следующей строкой. Так можно реализовать простой парсер файла,
который объединяет строки, завершающиеся обратным слешем:

=begin programlisting

    while (my $line = <$fh>)
    {
        chomp $line;

        # поиск обратного слеша в конце строки
        if ($line =~ s{\\$}{})
        {
            $line .= <$fh>;
            chomp $line;
            redo;
        }

        ...
    }

=end programlisting

X<loops; labels>

Использование операторов контроля цикла во вложенных списках может сбивать с
толку. Если вы не можете избежать вложенных циклов E<mdash> выделив внутренние
циклы в именованные функции E<mdash> используйте I<метку цикла> для прояснения:

=begin programlisting

    LINE:
    while (<$fh>)
    {
        chomp;

        PREFIX:
        for my $prefix (@prefixes)
        {
            next LINE unless $prefix;
            say "$prefix: $_";
            # здесь подразумевается next PREFIX
        }
    }

=end programlisting

=head2 Continue

X<loops; C<continue>>

Конструкция C<continue> ведёт себя как третье подвыражение цикла C<for>; Perl
выполняет её блок перед следующей итерацией цикла, как при нормальном повторении
цикла, так и при преждевременном повторе итерации с помощью C<next>N<Эквивалент
C<continue> языка C в Perl E<mdash> это C<next>.>. Вы можете использовать её с
циклами C<while>, C<until>, C<when> или C<for>. Примеры употребления <continue>
редки, но она полезна, если вам нужна гарантия того, что нечто произойдёт на
каждой итерации цикла, независимо от того, как заканчивается итерация:


=begin programlisting

    while ($i < 10 )
    {
        next unless $i % 2;
        say $i;
    }
    continue
    {
        say 'Continuing...';
        $i++;
    }

=end programlisting

Имейте ввиду, что блок C<continue> I<не> выполняется, когда поток управления
выходит из цикла вследствие срабатывания C<last> или C<redo>.

=head2 given/when

Z<given_when>

X<builtins; C<given>>

Конструкция C<given> E<mdash> новая возможность Perl 5.10. Она присваивает
значение выражения переменной-топику и предваряет блок:

=begin programlisting

    given ($name) { ... }

=end programlisting

В отличие от C<for>, она не итерирует по агрегатной переменной. Она вычисляет своё выражение
в скалярном контексте и всегда осуществляет присваивание переменной-топику:

=begin programlisting

    given (my $username = find_user())
    {
        is( $username, $_, 'topic auto-assignment' );
    }

=end programlisting

C<given> также локализует переменную-топик:

=begin programlisting

    given ('mouse')
    {
        say;
        mouse_to_man( $_ );
        say;
    }

    sub mouse_to_man { s/mouse/man/ }

=end programlisting

X<builtins; C<when>>
X<topicalization>

C<given> наиболее полезна при использовании совместно с C<when>
(L<smart_match>). C<given> I<топикализирует> значение внутри блока, так что
несколько инструкций C<when> могут проверять соответствие топика выражениям,
используя семантику I<умного сопоставления>. Так можно написать игру
E<laquo>камень, ножницы, бумагаE<raquo>.

=begin programlisting

    my @options  = ( \&rock, \&paper, \&scissors );
    my $confused = "I don't understand your move.";

    do
    {
        say "Rock, Paper, Scissors!  Pick one: ";
        chomp( my $user = <STDIN> );
        my $computer_match = $options[ rand @options ];
        $computer_match->( lc( $user ) );
    } until (eof);

    sub rock
    {
        print "I chose rock.  ";

        given (shift)
        {
            when (/paper/)    { say 'You win!' };
            when (/rock/)     { say 'We tie!'  };
            when (/scissors/) { say 'I win!'   };
            default           { say $confused  };
        }
    }

    sub paper
    {
        print "I chose paper.  ";

        given (shift)
        {
            when (/paper/)    { say 'We tie!'  };
            when (/rock/)     { say 'I win!'   };
            when (/scissors/) { say 'You win!' };
            default           { say $confused  };
        }
    }

    sub scissors
    {
        print "I chose scissors.  ";

        given (shift)
        {
            when (/paper/)    { say 'I win!'   };
            when (/rock/)     { say 'You win!' };
            when (/scissors/) { say 'We tie!'  };
            default           { say $confused  };
        }
    }

=end programlisting

Perl выполняет правило C<default>, если ни одно из других условий не подошло.

=begin tip Упрощённая диспетчеризация с Multimethods

X<CPAN; C<MooseX::MultiMethods>>

CPAN-модуль C<MooseX::MultiMethods> предоставляет другую технику для упрощения
этого кода.

=end tip

=head2 Хвостовые вызовы

Z<tailcalls>
X<tailcalls>

I<Хвостовой вызов> происходит, когда последнее выражение в функции E<mdash>
вызов другой функции: возвращаемое значение внутренней функции будет
возвращаемым значением внешней функции:

=begin programlisting

    sub log_and_greet_person
    {
        my $name = shift;
        log( "Greeting $name" );

        return greet_person( $name );
    }

=end programlisting

Возврат из C<green_person()> напрямую в код, вызывающий
C<log_and_greet_person()>, более эффективен, чем возврат I<в>
C<log_and_greet_person()> и сразу же возврат I<из> C<log_and_greet_person()>.
Возврат напрямую I<из> C<greet_person()> в код, вызывающий
C<log_and_greet_person()> E<mdash> I<оптимизация хвостового вызова>.

Код с тяжёлой рекурсией (L<recursion>), особенно взаимнорекурсивный код, может
потреблять много памяти. Хвостовые вызовы уменьшают количество памяти, требуемое
для внутренней организации потока управления, и делают дорогие алгоритмы легко
обрабатываемыми. К сожалению, Perl 5 не выполняет эту автоматизацию
автоматически; вы должны сделать это сами, если необходимо.

X<builtins; C<goto>>

Встроенный оператор C<goto> имеет форму, которая вызывает функцию, как если бы
текущая функция никогда не была вызвана, по существу, обнуляя управление
ресурсами для вызова новой функции. Уродливый синтаксис смущает людей, на слуху
у которых E<laquo>никогда не используйте C<goto>E<raquo>, но это работает:

=begin programlisting

    sub log_and_greet_person
    {
        B<my ($name) = @_;>
        log( "Greeting $name" );

        B<goto &greet_person>;
    }

=end programlisting

Этот пример имеет две важных особенности. Во-первых, C<goto &function_name> или
C<goto &$function_reference> требует использования сигила функции (C<&>), чтобы
парсер знал, что нужно выполнить хвостовой вызов вместо перехода к метке.
Во-вторых, эта форма вызова функции неявно передаёт содержимое C<@_> в
вызываемую функцию. Вы можете модифицировать C<@_> для изменения передаваемых
аргументов.

Эта техника относительно редка; она наиболее полезна, когда вы хотите вмешаться
в поток управления, чтобы убраться с пути других функций, проверяющих C<caller>
(например, если вы реализуете специальное логирование или какую-нибудь
возможность отладки), или когда используете алгоритм, требующий большого
количества рекурсии.
