=encoding utf-8

=head1 Область видимости

Z<scope>

X<scope>
X<encapsulation>

I<Область видимости> в Perl обозначает продолжительность жизни и видимость
именованных сущностей. В Perl всё, что имеет имя (переменная, функция), имеет
область видимости. Ограничение области видимости помогает усилить
I<инкапсуляцию> E<mdash> сохранение связанных понятий вместе и предотвращение их
вытекания наружу.

=head2 Лексическая область видимости

Z<lexical_scope>

X<lexical scope>
X<scope; lexical>

I<Лексическая область видимости> E<mdash> это область видимости, видимая по ходу
I<чтения> программы. Компилятор Perl определяет эту область видимости во время
компиляции. Блок, ограниченный фигурными скобками, создаёт новую область
видимости, будь это голый блок, блок конструкции цикла, блок объявления C<sub>,
блок C<eval> или любой другой блок, не заключающий в кавычки.

X<variables; lexical>

Лексическая область видимости определяет видимость переменных, объявленных с
помощью C<my> E<mdash> I<лексических> переменных. Лексическая переменная,
объявленная в одной области видимости, видима в этой области видимости и любых
областях видимости, вложенных в неё, но невидима в областях видимости,
находящихся на том же уровне вложенности или выше:

=begin programlisting

    # внешняя лексическая область видимости
    {
        package Robot::Butler

        # внутренняя лексическая область видимости
        my $battery_level;

        sub tidy_room
        {
            # более глубокая вложенная область видимости
            my $timer;

            do {
                # самая глубокая лексическая область видимости
                my $dustpan;
                ...
            } while (@_);

            # лексическая область видимости, находящаяся на том же уровне
            for (@_)
            {
                # отдельная самая глубокая лексическая область видимости
                my $polish_cloth;
                ...
            }
        }
    }

=end programlisting

E<hellip>переменная C<$battery_level> видима во всех четырёх областях видимости.
C<$timer> видима в методе, блоке C<do> и цикле C<for>. C<$dustpan> видима только
в блоке C<do>, а C<$polish_cloth> E<mdash> только в цикле C<for>.

X<lexical shadowing>
X<scope; lexical shadowing>

Объявление во внутренней области видимости лексической переменной с тем же
именем, что и лексическая переменная во внешней области видимости, скрывает, или
I<затеняет>, внешнюю переменную во внутренней области видимости. Зачастую это
именно то, что вам нужно:

=begin programlisting

    my $name = 'Jacob';

    {
        my $name = 'Edward';
        say $name;
    }

    say $name;

=end programlisting

=begin tip Конфликты имён

Лексическое затенение может происходить по случайности. Ограничивайте область
видимости переменных и вложенность областей видимости для уменьшения риска.

=end tip

Эта программа выводит C<Edward> и затем C<Jacob>N<Члены семьи, а не вампиры.>,
несмотря на то, что переобъявление лексической переменной с тем же именем и
типом I<в той же самой лексической области видимости> приводит к
предупреждающему сообщению. Затенение лексической переменной E<mdash>
особенность инкапсуляции.

Некоторые лексические объявления имеют тонкости, как, например, лексическая
переменная, используемая как переменная-итератор в цикле C<for>. Её объявление
находится снаружи блока, но её область видимости E<mdash> I<внутри> блока цикла:

=begin programlisting

    my $cat = 'Brad';

    for my $cat (qw( Jack Daisy Petunia Tuxedo Choco ))
    {
        say "Iterator cat is $cat";
    }

    say "Static cat is $cat";

=end programlisting

X<lexical topic>
X<topic; lexical>

Аналогично, C<given> (L<given_when>) создаёт I<лексический топик> (как C<my $_>)
внутри своего блока:

=begin programlisting

    $_ = 'outside';

    given ('inner')
    {
        say;
        $_ = 'this assignment does nothing useful';
    }

    say;

=end programlisting

E<hellip>так что выход из блока восстанавливает предыдущее значение C<$_>.

Функции E<mdash> именованные и анонимные E<mdash> создают лексическую область
видимости для своих тел. Это помогает созданию замыканий (L<closures>).

=head2 Область видимости our

Z<our>
X<builtins; C<our>>
X<packages; scope>
X<scope; packages>

Внутри заданной области видимости можно объявить псевдоним переменной пакета с
помощью встроенной директивы C<our>. Как и C<my>, C<our> обеспечивает
лексическую область видимости псевдонима. Полностью определённое имя доступно
из любого места, но лексический псевдоним виден только внутри своей области
видимости.

C<our> наиболее полезна в применении к глобальным переменным пакета, таким как
C<$VERSION> и C<$AUTOLOAD>.

=head2 Динамическая область видимости.

Z<dynamic_scope>

X<dynamic scope>
X<scope; dynamic>

Динамическая область видимости похожа на лексическую область видимости по своим
правилам видимости, но вместо поиска наружу в области видимости времени
компиляции, поиск проходит назад через контекст вызова. В то время как
глобальная переменная пакета может быть I<видима> внутри всех областей
видимости, её I<значение> изменяется в зависимости от локализации (C<local>) и
присваивания:

=begin programlisting

    our $scope;

    sub inner
    {
        say $scope;
    }

    sub main
    {
        say $scope;
        local $scope = 'main() scope';
        middle();
    }

    sub middle
    {
        say $scope;
        inner();
    }

    $scope = 'outer scope';
    main();
    say $scope;

=end programlisting

Программа начинается с объявления C<our>-переменной, C<$scope>, а так же трёх
функций. Заканчивается она присваиванием C<$scope> и вызовом C<main()>.

X<builtins; C<local>>

Внутри C<main()> программа выводит текущее значение C<$scope>, C<outer scope>,
затем локализует переменную с помощью C<local>. Это изменяет видимость символа
внутри текущей лексической области видимости, I<так же как> и в любых функциях,
вызываемых из I<текущей> лексической области видимости. Таким образом, C<$scope>
содержит C<main() scope> внутри тела как C<middle()>, так и C<inner()>. После
возврата из C<main()>, когда поток управления достигает конца её блока, Perl
восстанавливает исходное значение локализованной C<$scope>. Последняя директива
C<say> снова выводит C<outer scope>.

X<lexicals; pads>
X<lexpads>
X<symbol tables>

Переменные пакетов и лексические переменные в Perl имеют разные правила
видимости и механизмы хранения. Каждая область видимости, содержащая лексические
переменные, имеет специальную структуру данных, называемую I<лексическая
записная книжка> (I<lexical pad>, или I<lexpad>), которая может хранить значения
содержащихся в ней лексических переменных. Каждый раз, когда поток управления
входит в одну из этих областей видимости, Perl создаёт ещё одну лексическую
записную книжку для значений этих лексических переменных для этого конкретного вызова.
Это позволяет функции работать корректно, особенно в рекурсивных вызовах
(L<recursion>).

Каждый пакет имеет единую I<символьную таблицу>, содержащую переменные пакета, а
также именованные функции. Импорт (L<importing>) инспектирует и манипулирует
этой символьной таблицей. Также делает и C<local>. Вы можете локализовать только
глобальные переменные и глобальные переменные пакета E<mdash> но не лексические
переменные.

X<C<$/>>
X<magic variables; C<$/>>
X<C<$!>>
X<magic variables; C<$!>>
X<C<$@>>
X<magic variables; C<$@>>
X<C<$|>>
X<magic variables; C<$|>>

C<local> чаще всего используется с магическими переменными. Например, C<$/>,
разделитель входных записей, определяет, сколько данных операция C<readline>
прочитает из дескриптора файла. C<$!>, переменная системной ошибки, содержит
номер ошибки последнего системного вызова. C<$@>, переменная ошибки C<eval>,
содержит любую ошибку из последней операции C<eval>. C<$|>, переменная
автосброса, определяет, будет ли Perl сбрасывать текущий выбранный (C<select>)
дескриптор файла после каждой операции записи.

Локализация этих переменных в как можно более узкой области видимости
ограничивает эффект ваших изменений. Это может предотвратить странное поведение
в других частях вашего кода.

=head2 Область видимости state

Z<state_scope>

X<C<state>>
X<builtins; C<state>>
X<scope; state>

Perl 5.10 добавил новую область видимости для поддержки встроенной директивы
C<state>. Область видимости state похожа на лексическую область видимости в
отношении условий видимости, но добавляет однократную инициализацию, а также
персистентность значения:

=begin programlisting

    sub counter
    {
        B<state> $count = 1;
        return $count++;
    }

    say counter();
    say counter();
    say counter();

=end programlisting

При первом вызове C<counter> Perl выполняет единственную инициализацию
C<$count>. При последующих вызовах C<$count> сохраняет своё предыдущее значение.
Эта программа выведет C<1>, C<2> и C<3>. Замените C<state> на C<my>, и программа
будет выводить C<1>, C<1> и C<1>.

Вы можете использовать выражение для установки начального значения
C<state>-переменной:

=begin programlisting

    sub counter
    {
        state $count = shift;
        return $count++;
    }

    say counter(B<2>);
    say counter(B<4>);
    say counter(B<6>);

=end programlisting

Несмотря на то, что простое прочтение кода может привести к предположению, что
выведено будет C<2>, C<4> и C<6>, на самом деле выведено будет C<2>, C<3> и
C<4>. Первый вызов процедуры C<counter> установит значение переменной C<$count>.
Последующие вызовы не будут изменять её значение.

C<state> может быть полезна для установки значения по умолчанию или подготовки
кеша, но если вы её используете, убедитесь, что понимаете её инициализационное
поведение:

=begin programlisting

    sub counter
    {
        state $count = shift;
        say 'Second arg is: ', shift;
        return $count++;
    }

    say counter(2, 'two');
    say counter(4, 'four');
    say counter(6, 'six');

=end programlisting

Счётчик для этой программы выведет C<2>, C<3> и C<4>, как и ожидалось, но
значения подразумеваемого второго аргумента вызовов C<counter()> будут C<two>,
C<4> и C<6> E<mdash> потому что C<shift> для первого аргумента происходит только
при первом вызове C<counter()>. Или измените API для предотвращения этой ошибки,
или защититесь от неё:

=begin programlisting

    sub counter
    {
        my ($initial_value, $text) = @_;

        state $count = $initial_value;
        say "Second arg is: $text";
        return $count++;
    }

    say counter(2, 'two');
    say counter(4, 'four');
    say counter(6, 'six');

=end programlisting
