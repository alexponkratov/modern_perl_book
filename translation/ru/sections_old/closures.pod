=encoding utf-8

=head1 Замыкания

Z<closures>
X<functions; higher order>
X<higher order functions>

Каждый раз, когда поток управления входит в функцию, эта функцию получает новое
окружение, представляющее лексическую область видимости (L<scope>) этого вызова.
Это в той же мере применимо и к анонимным функциям (L<anonymous_functions>).
Следствия этого очень значимы. Термин компьютерных наук I<функции высшего
порядка> ссылается на функции, манипулирующие другими функциями. Замыкания
E<mdash> пример этой значимости.

=head2 Создание замыканий

X<closures>
X<functions; closures>

I<Замыкание> E<mdash> это функция, использующая лексические переменные из
внешней области видимости. Вы, вероятно, уже создавали и использовали замыкания,
не осознавая этого:

=begin programlisting

    package Invisible::Closure;

    my $filename = shift @ARGV;

    sub get_filename { return $filename }

=end programlisting

Если этот код выглядит для вас очевидным, отлично! I<Конечно> функция
C<get_filename()> может видеть лексическую переменную C<$filename>. Именно так
работают области видимости!

Предположим, вы хотите пройти в цикле по списку элементов без необходимости
самостоятельно управлять итератором. Вы можете создать функцию, которая
возвращает функцию, которая, будучи вызванной, вернёт следующий элемент в
итерации:

=begin programlisting

    sub make_iterator
    {
        my @items = @_;
        my $count = 0;

        return sub
        {
            return if $count == @items;
            return $items[ $count++ ];
        }
    }

    my $cousins = make_iterator(
        qw( Rick Alex Kaycee Eric Corey Mandy Christine )
    );

    say $cousins->() for 1 .. 5;

=end programlisting

Хотя и произошёл возврат из C<make_iterator()>, анонимная функция, сохранённая в
C<$cousins>, замкнула значения этих переменных как они существовали внутри
вызова C<make_iterator()>. Их значения продолжают существовать
(L<reference_counts>).

Так как каждый вызов C<make_iterator()> создаёт отдельное лексическое окружение,
анонимная функция, которую она создаёт и возвращает, замыкается на уникальном
лексическом окружении:

=begin programlisting

    my $aunts = make_iterator(
        qw( Carole Phyllis Wendy Sylvia Monica Lupe )
    );

    say $cousins->();
    say $aunts->();

=end programlisting

Так как C<make_iterator()> не возвращает эти лексические переменные по значению
или по ссылке, никакой другой Perl-код, кроме замыкания, не сможет получить к
ним доступ. Они инкапсулированы так же эффективно, как любая другая лексическая
инкапсуляция, хотя любой код, разделяющий лексическое окружение, может получить
доступ к этим значениями. Эта идиома предоставляет лучшую инкапсуляцию того, что
в ином случае было бы глобальной переменной файла или пакета:

=begin programlisting

    {
        my $private_variable;

        sub set_private { $private_variable = shift }
        sub get_private { $private_variable }
    }

=end programlisting

Имейте ввиду, что вы не можете I<вкладывать> именованные функции. Именованные
функции имеют глобальную область видимости пакета. Любые лексические переменные,
разделяемые между вложенными функциями, перестанут быть разделяемыми, как только
внешняя функция уничтожит своё первое лексическое окружениеN<Если это приводит
вас в замешательство, представьте реализацию.>.

=begin tip Вторжение в частную жизнь

X<CPAN; C<PadWalker>>

CPAN-модуль C<PadWalker> позволяет вам нарушать лексическую инкапсуляцию, но
любой, кто использовал его и сломал ваш код, заслуживает права исправить любые
сопутствующие баги без вашей помощи.

=end tip

=head2 Использование замыканий

Итерирование по списку постоянного размера с помощью замыкания E<mdash>
интересный пример, но замыкания могут делать гораздо больше, как, например,
итерирование по списку, который слишком дорог для вычисления или слишком велик,
чтобы держать его в памяти целиком. Рассмотрим функцию, создающую
последовательность чисел Фибоначчи по мере того, как вам понадобятся её
элементы. Вместо повторного вычисления последовательности рекурсивно,
используйте кеш и ленивое создание требуемых элементов:

=begin programlisting

    sub gen_fib
    {
        my @fibs = (0, 1);

        return sub
        {
            my $item = shift;

            if ($item >= @fibs)
            {
                for my $calc (@fibs .. $item)
                {
                    $fibs[$calc] = $fibs[$calc - 2]
                                 + $fibs[$calc - 1];
                }
            }
            return $fibs[$item];
        }
    }

=end programlisting

Каждый вызов функции, возвращаемой C<get_fib()>, принимает один аргумент,
I<n>-ный элемент последовательности Фибоначчи. Функция генерирует все
предшествующие значения в последовательности по мере необходимости, кеширует их
и возвращает запрошенный элемент E<mdash> и даже откладывает вычисление до
абсолютной необходимости. Однако здесь шаблон, характерный для кеширования,
переплетается с числовыми последовательностями. Что получится, если вы
выделите связанный с кешированием код (инициализация кеша, выполнение нужного
кода для заполнения элементов кеша и возврат вычисленного или полученного из
кеша значения) в функцию C<generate_caching_closure()>?

=begin programlisting

    sub gen_caching_closure
    {
        my ($calc_element, @cache) = @_;

        return sub
        {
            my $item = shift;

            $calc_element->($item, \@cache)
                unless $item < @cache;

            return $cache[$item];
        };
    }

=end programlisting

=begin tip Обернуть, применить и отфильтровать

Встроенные функции C<map>, C<grep> и C<sort> сами по себе E<mdash> функции
высшего порядка.

=end tip

Теперь C<gen_fib()> превращается в:

=begin programlisting

    sub gen_fib
    {
        my @fibs = (0, 1, 1);

        return gen_caching_closure(
            sub
            {
                my ($item, $fibs) = @_;

                for my $calc ((@$fibs - 1) .. $item)
                {
                    $fibs->[$calc] = $fibs->[$calc - 2]
                                   + $fibs->[$calc - 1];
                }
            },
            @fibs
        );
    }

=end programlisting

Программа ведёт себя так же, как и раньше, но использование ссылок на функции и
замыканий отделяет инициализирующее кеш поведение от вычисления следующего числа
последовательности Фибоначчи. Кастомизация поведения кода E<mdash> в данном
случае C<get_caching_closure()> E<mdash> с помощью передачи функции обеспечивает
потрясающую гибкость.

=head2 Замыкания и частичное применение

Z<partial_application>

Также замыкания могут I<удалить> нежелательную универсальность. Рассмотрим
случай функции, принимающей несколько параметров:

=begin programlisting

    sub make_sundae
    {
        my %args = @_;

        my $ice_cream = get_ice_cream( $args{ice_cream} );
        my $banana    = get_banana( $args{banana} );
        my $syrup     = get_syrup( $args{syrup} );
        ...
    }

=end programlisting

Мириады возможностей кастомизации могут быть очень полезны в полноценном
магазине мороженого, но в случае передвижного фургончика с мороженым, в котором
подают только мороженое Французская ваниль на бананах Кавендиш, каждый вызов
C<make_sundae()> требует передачи аргументов, которые никогда не изменяются.

X<partial application>

Техника, называемая I<частичное применение>, позволяет вам привязать
I<некоторые> из аргументов к функции, а остальные предоставлять позже. Оберните
функцию, которую намереваетесь вызывать, в замыкание, и передайте связанные
аргументы.

Рассмотрим фургончик с мороженым, продающий только мороженое Французская ваниль
на бананах Кавендиш:

=begin programlisting

    my $make_cart_sundae = sub
    {
        return make_sundae( @_,
            ice_cream => 'French Vanilla',
            banana    => 'Cavendish',
        );
    };

=end programlisting

X<CPAN; C<Sub::Install>>

Вместо вызова C<make_sundae()> напрямую, вызовите ссылку на функцию в
C<$make_cart_sundae> и передайте только нужные аргументы, не опасаясь позабыть о
неизменяющихся или передать их некорректноN<Вы можете даже использовать
C<Sub::Install> из CPAN для импорта этой функции напрямую в другое пространство
имён.>.

X<I<Higher Order Perl>>

Это только начало того, что вы можете делать с функиями высшего порядка.
I<Higher Order Perl> Марка Джейсона Доминуса (Mark Jason Dominus) E<mdash>
канонический справочник по функциям первого класса и замыканиям в Perl. Вы
можете прочитать его онлайн по адресу U<http://hop.perl.plover.com/>.
